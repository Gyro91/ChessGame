/* --- PURSUIT APP ---
 * Version 3.2.1
 * Developed by Tante Persone, Fabio Stroppa, Nicola Mastronicola
 */

SET SCENE_FOV = 60;
SET SCENE_NEAR = 0.05;
SET SCENE_FAR = 1000;

#define _S3D_ALLOW_OBSOLETE_FUNCTIONS
//==============================================================================================================
// Includes
//==============================================================================================================
#include <Script3d.h>
#include "physics.s3d"	// for physx
#include "ReachingHelp.s3d"
#include "Transformation.s3d"
//==============================================================================================================
// Define
//==============================================================================================================
#define ENABLE_STEREO   // OCCHIO ... ATTIVO IN DEMOLEXOS
//#define __DEBUG
//#define __DEBUG2
//#define __DEBUG_GUI
// NO XPC TARGET PRESENT (DEBUG)
#define NOTARGET 
// SHADOW DEFINITION: ONLY FOR 3-DIM VIEW
#define SHADOW
// GRASPING AND RELEASE MODALITY
//#define HOLD_MOVE	// GRASP AND AUTOMATIC HOLD, OTHERWISE GRASP&HOLD
// KINEMATICS AND DYNAMICS PARAMETERS
#define cubeDensity 100 // era 35 higher value could lead to instability (maybe need the introduction of viscosity)
#define staticFriction 0.4
#define dynamicFriction 0.3
#define MAXSPEEDFORTHROW	0.006	// BASKET: SET THE PROXY SPEED TO LET THE CUBE THROW IN THE BASKET
#define SELECT_DISTANCE		0.015	//0.015
#define PIGRECO 3.141592
#define CUBE_SIZE	0.15
#define ROOM_SIZE	3.0
#define BASKET_LIMITX	0.5
#define BASKET_LIMITZ	1
#define INTRO_ 	0
#define INTRO2_ 1
#define PUZZLE_ 2
#define CLOCK_	3
#define BASKET_	4
#define END_ 	5
#define END2_ 	6
#define NUM_SOUNDS 	7
#define SFX_INTRO 	0
#define SFX_BUMP 	1
#define SFX_PICK 	2
#define SFX_CLAP	3 
#define SFX_FINISH 	4
#define SFX_CLACK	5
#define SFX_DROP	6

///added by Antonio and Nicola  TO BE REMOVED
var temp_check_force=false;



var file_ext="";
var Mode = 0;					// Identifier for Control Modality: NOMODE
var checkApp = false;			// Flag to check the type of application
var EndInit = 0;				// End of Reset Encoders (=0 NOT FINISHED; =1 FINISHED)
// SCORE VARIABLES
var date="";
var scores = 0;
var scoreloaded = false;
var reqscore = false;
var immagini = {"haring","numbers","foca","spade","grape","italy","mini","roma01","parigi01","parigi02","parigi03","deserto","canyon","papaveri","londra01","londra02"};

var puzzle = "foca";
var temp_puzzle = "";				
var session = "Puzzle";
var on_session = array(3);								
var prev_session = "-";
var v = vector(3);
var cubePos=[0.0, 0.0, 0.0];
var mod=0.0;
var HFor = [0.0,0.0,0.0];
var HiJointPos = [0.0,0.0,0.0,0.0,0.0];
var HiVel= [0.0,0.0,0.0];
var application = CVmWebBrowser();
var Fgrab = 0.0;		// FORCE TO EVALUATE THE GRAB
var pazienteSelected = false; 
var paziente="<Paziente>";
var task="C";		// P:Puzzle - B:Basket - C:Clock
var lista_pazienti = {};
var Scale;			// EXOS POSITION AMPLIFIER
var Hoff,Voff,Doff;	// = PosOffset [CARTESIAN EXOS REFERENCE]
var Pos_Offset_Dev = [ 0,0,0 ];
var Pos_Offset_VR = [ 0,0,0 ];
var dev_pos = [0,0,0];
var dev_pos_old = [ 0,0,0 ];

// TEMPORARY SCORES (KT)
var timer = 0.0;
var total_time = 0.0;
var NUM_CUBES=12;
var IsPressed = false;  	//check pressed button
var sel_obj	= 0; 			//Index of selected object
var matched_cubes = {};
var free_cubes = {1,2,3,4,5,6,7,8,9};
var mat_obj = 0;
var floor_colgr = 20;			// Roof Collision group
var CIRCLE_RADIUS = 3;			// Circle Radius Factor
//variabili temporanee da precedente codice
var HB_ini = [0,0,0];
var HB_curr = [0,0,0];
var HB_old = [0,0,0];
var HB_speed = [0,0,0];
//forze verso l'haptic device
var Force = [0.0,0.0,0.0]; //visualized force
var ModuleForce = 0;
var NFor = [0.0,0.0,0.0];
var HiForces = [0.0,0.0,0.0];
var HiGrasp = [0.0,0.0];
var pos = vector(3);			//Position of the grabber
var time = vector(1);			//time since the grab started
var forzaSx = vector(3);		//force applied on the left grabber
var dSx = vector(3);  			//position and speed
var ddSx = vector(3);	
var deltaSim = 1.0;				//delta time (ms)
var sfera1, sfera2;				//grabber cursors
var Device_EE_sfera;
var App_EE_sfera;
var App_EE_sfera_Pos;
var xVR_Device_Target_Pos;

var matRosso;					//cursors material
var maton;
var matoff;
var ForceStatus=0;
/* --- NEWS FABIO NICOLA --- */
	var h_class;
	var h_required=false;
	var counter_help=0;
	var possoIniziare=false;
	var assistSet=0;
	var t_class = Transformation(3,[0,0,0.45],"x",-PIGRECO/2); //(scale, offset, Rotation Matrix x-axis)
    var space_grasp=false;
    var oldHoff,oldDoff,oldVoff,oldScale;
    var posInit=vector(3); 
    var Init_pos = false;
    var activeInitPos=false;
    var ADC_TSHOLD;
    var ADC_Bool = false;    
    var firstFrame;
    var reduce_stiffness_count = -1;
	var reduce_stiffness_maxIteration = 300.0;	//50 volte 0.01s --> 0.5s
	var cube_to_reach = -1;
	var clock_inc = 0;
/* --- NEWS FABIO NICOLA --- */
var StiffSfera = 250;
var StiffSferaExos = StiffSfera;
var ScalaStiffObjSel=1.0; 
var StiffCubo = 150;
var BiHB = 15.0;
var temp_dist=0.0;
var temp_pos=[0.0,0.0,0.0];
var temp_pos_sfera=[0.0,0.0,0.0];
var temp_isSelected=false;
var isSelected=false;
// IF 2-DIM VIEW
var CenterPuzzle = [0.0,0.0,0.0];//[0.0, 0.0, CUBE_SIZE*5/2 ];
var CenterBasket = CenterPuzzle;// - [-5*CUBE_SIZE,1.4*CUBE_SIZE,7.2*CUBE_SIZE];
var CamDir      = [0,0,-1];				//camera direction
var CamPos      = [0.0, 0.7, 1.6];  	//camera position
#ifdef ENABLE_STEREO
var CamPos2D    = [0.0, 0.001, CenterPuzzle[2]+0];//[0.0, 2.1, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#else
var CamPos2D    = [0.0, 2.1, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#endif
var CamTarget   = [0.0, 0.45, 0.0];
var CamTarget2D = CenterPuzzle;
//Light
var Luce;
var PosL = [3, 5.0, 1.5];		//default light position
//Meshes and graphic objects
var m_stanza, o_stanza;
var m_basket, o_basket;
var m_cesto = array(4), o_cesto=array(4);
var m_cube = array(NUM_CUBES);		// MESH OF CUBES
var o_cube = array(NUM_CUBES);		// PHYSICS CUBES
var mv_cube = array(NUM_CUBES);		// MESH OF VIRTUAL CUBES
var v_cube = array(NUM_CUBES);		// VIRTUAL CUBES (ONLY FOR CLOCK SESSION)
var cube_position = array(NUM_CUBES);
var clock_position = array(NUM_CUBES);
var cube_grid = array(NUM_CUBES*2);
var TargetPos = [0.0,0.0,0.0];
var IniGrid = array(NUM_CUBES);
var stickyMaterial;		//Physic material for the cursors
var rigidMaterial;		//Physic material for the cubes and the floor
var Map;
var isForceEnabled=false;
var stato = INTRO_;	
var SoundFX = array(NUM_SOUNDS);
var UDP_Channel;
var XVR_Port = 12345;
var GUI_Port = 12346;
#ifdef SHADOW
	var fbo;
	var shader;
	// additional OpenGL constants
	#define GL_DEPTH_COMPONENT16	0x81A5
	#define GL_DEPTH_COMPONENT24	0x81A6
	#define GL_DEPTH_COMPONENT32	0x81A7	
	// additional XVR constants
	//#define VR_FBO_COLOR			0x0001
	//#define VR_FBO_DEPTH			0x0002
	//#define VR_FBO_SHADOW			0x0003
	var shader_name = "shadows_tex.sh";
	// a couple of handy application constants
	#define SCENE_CAMERA 0
	#define LIGHT_CAMERA 1
	#define LIGHT_CAMERA2 2
	var light,light2;
#endif
/****************** SEND PROTOCOL VARIABLES *******************/
var GravityComp=0.0;	// Percentage of the patient's arm mass
var GravityOn = 0.0;
var BodyMass = 0.0;		// Patient Body Mass
var weight = [1,1,1,1];	// PESI PER LA CINEMATICA INVERSA DEL REACHING
var kp = [0,0,0,0];
var damper = 30.0;	// VISCOSITY FACTOR (Ns/m) OF RESISTANCE FORCE
var forcecontrol_flag=1;
/**************************************************************/





//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define DEVICE_INTERFACE_TH20
#define DEVICE_INTERFACE_ALEX20

#define HI_xVR_PATH		".\\..\\..\\HI_xVR"
#include "..\..\HI_xVR\Device_Interface_Include.s3d"

var Device;
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX



//==============================================================================================================
//MS functions & variables which are used for communication with external GUI
//==============================================================================================================
function ReceiveData(UDP_Channel);
function SendData(data);
function ProcessData(data); 
function attachCube();
function attachClock();
function Grabbed();
function DrawGrid();
function MoveCameraTo(x,y,z,startangle);
function InitPositions();
function SetIniGrid();
function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y);
function DrawLine(pos1,pos2,r,g,b);
function LoadBasket();
function LoadPuzzle();
function ReloadPuzzle();
function LoadCube();		//ONLY FOR CLOCK SESSION
function max(a);
function disp(x,y,stri,row,col,fontsize,transparency);
function ThrowBasket();
function TaskBar();
function modul(v);
function Load_Score();
function plot(data,title);
function HandleDataIn(separator);
function view_plot();
function ManageCollision();
function CameraMoveMouse();

// get commands from the web page.
function HandleDataIn(separator)
{
	var s = DataIn();
	var aa;
	trace(s);
	if(len(s) != 0)
	{
		if(separator!="")
			aa = split(s,separator);
		else
			aa = s;
		return aa;
	}
}

function Load_Score()
{
	var filescore = LoadFile("TotalScores.dat");
	var score_data = {0.0};
	var j=0;
	var data;

	trace(filescore);
	if(filescore!=void)
	{
		foreach(var a in filescore)
		{
			trace(a);
			if(a!="")
			{
				var b=split(a,",");
				outputln(b[0],"==",paziente," - ",b[2],"==",session);
				data=val(b[3]);
				trace(data);
				if( (b[0]==paziente)&&(b[2]==session) )
				{
					aadd(score_data,data);
				}
				trace(score_data);
			}
		}
		adel(score_data,0);
	}
	trace(score_data);
	return score_data;
}

function SetIniGrid()
{
	var i, ii;
	var Grid = array(NUM_CUBES);
	var seed;
	/* inizializza la griglia */
	for(i=0;i<NUM_CUBES;i++)
		Grid[i] = i;	
	/* diamo le carte */
	for (i=0;i<NUM_CUBES;i++)
	{
		seed = NUM_CUBES - i - 1;
		if (seed == 0)
			ii = 0;
		else
			ii= rand(seed);
	   	IniGrid[i] = Grid[ii];
	   	Grid[ii] = Grid[seed];
	}
}

function LoadBasket()
{
	var meshtoload = "Objects\\cesto.aam";
	m_basket = CVmNewMesh(meshtoload);
	m_basket.Normalize(3*CUBE_SIZE);
	m_basket.CenterBoundingBox();
	o_basket=CVmObj();
	o_basket.LinkToMesh(m_basket);
	o_basket.setposition(CenterBasket);
}

function ReloadPuzzle()
{
	if(session!="Clock")	NUM_CUBES = 9;
	
	var meshtoload="";
	var i;	
	var dir = GetCurrentDir();
	trace(dir);
	outputln(puzzle);
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
	dir = GetCurrentDir();
	trace(dir);  
	
	if(session=="Clock")
	{
//		var dir = GetCurrentDir();
//		trace(dir);  
//		SetLocalDir(sprintf(".\\Cubes\\clock" ));
//		dir = GetCurrentDir();
//		trace(dir);  
		
		clock_inc = 0;
		if(on_session[2]==0)	// IF THE FIRST CALL OF CLOCK
		{
			for (var j=0;j<NUM_CUBES;j++){
				meshtoload = sprintf("a_%d.aam",j+1);
				m_cube[j] = CVmNewMesh(meshtoload);
				m_cube[j].Normalize(CUBE_SIZE);
				mv_cube[j] = CVmNewMesh(meshtoload);
				mv_cube[j].Normalize(CUBE_SIZE);
				v_cube[j]=CvmObj();	
				v_cube[j].LinkToMesh(mv_cube[j]);
				v_cube[j].ModulateMaterials(1,1,1,0.5);
			}
			// LOAD THE OBJECT CUBE TIL 12th FOR THE CLOCK SESSION 
			for (var j=9;j<NUM_CUBES;j++)
			{
				o_cube[j] = manager_psx.AddPhConvexShape([0.0,0.0,0.0], [0.0,0.0,0.0], m_cube[j], PHX_DYNAMIC, cubeDensity, 10, rigidMaterial);
				
//				o_cube[j] = manager_psx.AddPhCube([0.0,0.0,0.0], [0.0,0.0,0.0], [CUBE_SIZE, CUBE_SIZE, CUBE_SIZE], PHX_DYNAMIC, cubeDensity, 10, rigidMaterial);
//				//o_cube[j].LinkToMesh(m_cube[j]);
				
				o_cube[j].AssignCollisionGroup(j+1);
				o_cube[j].SetBarycenterREL([0.0, -CUBE_SIZE/4, 0.0]);				
				//o_cube[j].SetInertiaTensor([10000, 10000, 10000]);	//increasing inertia to avoid rotation
				o_cube[j].SetInertiaTensor([100000, 100000, 100000]);	//increasing inertia to avoid rotation			
			}

			on_session[2]=1;
		}	
			
		for (var j=0;j<NUM_CUBES;j++)
		{
			meshtoload = sprintf("a_%d.aam",j+1);
			m_cube[j] = CVmNewMesh(meshtoload);
			m_cube[j].Normalize(CUBE_SIZE);
			mv_cube[j] = CVmNewMesh(meshtoload);
			mv_cube[j].Normalize(CUBE_SIZE);
			v_cube[j]=CvmObj();	
			v_cube[j].LinkToMesh(mv_cube[j]);
			v_cube[j].ModulateMaterials(1,1,1,0.5);
			o_cube[j].LinkToMesh(m_cube[j]);	// LINK THE FIRST 9 CUBES
			if(o_cube[j].type!=PHX_DYNAMIC)
				o_cube[j].MakeDynamic();
			o_cube[j].setvisible(true);
			o_cube[j].setgravity(true);
			// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				o_cube[j].Setvisible(false);
			}
		}
		
		manager_psx.EnableCollision(0,1);	// ENABLE COLLISION BETWEEN FIRST CUBE AND PROXY
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.DisableCollision(0,k+1);
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.EnableCollision(floor_colgr,k);
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.DisableCollision(1,k+1);			
	}
	else	// BASKET OR PUZZLE
	{	
		var dir = GetCurrentDir();
		trace(dir);
//		SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
//		dir = GetCurrentDir();
//		trace(dir);  
		
		for (var j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
			meshtoload = sprintf("a_%d.aam",i+1);
			m_cube[i] = CVmNewMesh(meshtoload);
			m_cube[i].Normalize(CUBE_SIZE);	
			if(o_cube[i].Type!=PHX_DYNAMIC)
				o_cube[i].MakeDynamic();
			o_cube[i].Setgravity(true);
			o_cube[i].LinkToMesh(m_cube[i]);
			o_cube[i].Setvisible(true);
		}

		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.EnableCollision(floor_colgr,k);
		// HIDE THE THREE CUBES CREATED IN A PREVIOUS CLOCK TASK
		if(on_session[2]==1)
		{
			for (var j=NUM_CUBES;j<NUM_CUBES+3;j++)
			{
				o_cube[j].Setvisible(false);			
				manager_psx.DisableCollision(0,j+1); // disable proxy collision
				for(var k=1; k<=NUM_CUBES; k++)
					manager_psx.DisableCollision(j+1,k);
			}
		}
		Map = CVmTexture(sprintf("Sinopia.jpg"));
	}
}

function LoadCube()
{
	var j=0;
	if(len(free_cubes)!=0)
	{
		#ifdef __DEBUG
		outputln("FreeCubes[",j,"] = ",free_cubes[j]);
		#endif
		// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
		cube_position[free_cubes[j]-1] = [ 0.0, CUBE_SIZE/2, 0.0 ] + CenterPuzzle;
		// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
		o_cube[free_cubes[j]-1].Setvisible(true);
		o_cube[free_cubes[j]-1].Setgravity(true);
		manager_psx.EnableCollision(0,free_cubes[j]);
		o_cube[free_cubes[j]-1].SetPosition(cube_position[ free_cubes[j]-1 ]);
		o_cube[free_cubes[j]-1].SetRotation(-90,[1.0,0.0,0.0]);
	}
}

function LoadPuzzle()
{
	var meshtoload="";
	var i;
	SetIniGrid();
	// Set Local Directory to .\Cubes to avoid problem in loading the *.aam and relative textures
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
	for (var j=0;j<NUM_CUBES;j++)
	{
		i = IniGrid[j];
		meshtoload = sprintf("a_%d.aam",i+1);
		m_cube[i] = CVmNewMesh(meshtoload);
		m_cube[i].Normalize(CUBE_SIZE);
		
//		o_cube[i] = manager_psx.AddPhConvexShape([0.0,0.0,0.0], [0.0,0.0,0.0], m_cube[i], PHX_DYNAMIC, cubeDensity, 10, rigidMaterial);
//		o_cube[i].LinkToMesh(m_cube[i]);
		
		o_cube[i] = manager_psx.AddPhCube([0.0,0.0,0.0], [0.0,0.0,0.0], [CUBE_SIZE, CUBE_SIZE, CUBE_SIZE], PHX_DYNAMIC, cubeDensity, 10, rigidMaterial);
		o_cube[i].LinkToMesh(m_cube[i]);
		
		o_cube[i].AssignCollisionGroup(i+1);	// CUBE COLLISION GROUP 1..10		
		o_cube[i].SetBarycenterREL([0.0, -CUBE_SIZE/4, 0.0]);		
		// INCREASING INERTIA TO AVOID ROTATION
		o_cube[i].SetInertiaTensor([100000, 100000, 100000]);		
//		PhysXVR.SetCollision(sfera1.getActor(), o_cube[i].getActor());
	}	
	InitPositions();
	ConsoleFont("Arial", 24);
	ConsoleColor( 0.364, 0.294 , 0.278, 1.0 );
	Map = CVmTexture(sprintf("Sinopia.jpg"));	
	SetLocalDir();	// Set Local Directory to the actual one
	
	if(session == "Clock"){
		clock_inc = 0;
	}
}

function OnDownload()
{		
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	DEV_Interface_Utility_Download();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	

	FileDownload("suoni.zip");
	FileDownload("Objects.zip");
	FileDownload("stanza.zip");
	#ifdef SHADOW
		FileDownload(shader_name);
	#endif		
}

function onEvent(){}

function OnError(){
	SendData("ERR");
}

var ALEX_Simulato = false;


var matred, M_light, O_light;

var circleSteps = 100;
var cosines = Array(circleSteps);
var sines = Array(circleSteps);


function OnInit(params)
{	
	var i;
		for (i=0;i<100;i++) {
		cosines[i] = cos((100-i)*2*PI/100.0);
		sines[i] = sin((100-i)*2*PI/100.0);
		
		}
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device = ALEX20;
//	Device = MOUSE_dev;

//	DEV_Interface_Utility_SelectDevice(&Device, params);
	
	Device.OnInit();
	
	if (Device.Base.ID == DEVICE_ID_ALEX20)
	{
		Device.Base.xVR_Param.Matrix_Dev_To_xVR = [ 1.0, 0.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,    0.0, 0.0, 1.0, 0.0,   0.0, 0.32, 0.204, 1.0 ];
		Device.Base.xVR_Param.Scale_Dev_To_xVR = 1.0;
	}
	if (Device.Base.ID == DEVICE_ID_TH20)
	{
		Device.Base.xVR_Param.Matrix_Dev_To_xVR = [ 0.0, 0.0, -1.0, 0.0,     -1.0, 0.0, 0.0, 0.0,    0.0, 1.0, 0.0, 0.0,   0.0, 0.525, 0.525+0.161+0.0632, 1.0 ];
		Device.Base.xVR_Param.Scale_Dev_To_xVR = 1.0;
	}
	Device.Base.xVR_Param.Matrix_xVR_To_Dev = MatrixInverse_4( Device.Base.xVR_Param.Matrix_Dev_To_xVR );

	Device.Display.OnInit(Device.Base.xVR_Param.Scale_Dev_To_xVR);
		
	for (var C=0; C<Device.Display.Wd.Sys[0].Num_Of_Dev; C++)
	{
		Device.Display.Wd.Sys[0].Dev[C].Show_Mesh.Status = false;
	}

	Device.Base.xVR_Param.Base_Status.OnFrame.Enable = true;		Device.Base.xVR_Param.Base_Status.OnFrame.Decimation = 5;
	Device.Base.xVR_Param.Dev_MiscDataIn.OnFrame.Enable = true;		Device.Base.xVR_Param.Dev_MiscDataIn.OnFrame.Decimation = 1;
	Device.Base.xVR_Param.Dev_KineDataIn.OnFrame.Enable = false;		Device.Base.xVR_Param.Dev_KineDataIn.OnFrame.Decimation = 1;

	Device.Base.xVR_Param.Base_Status.OnTimer.Enable = false;		Device.Base.xVR_Param.Base_Status.OnTimer.Decimation = 5;
	Device.Base.xVR_Param.Dev_MiscDataIn.OnTimer.Enable = false;	Device.Base.xVR_Param.Dev_MiscDataIn.OnTimer.Decimation = 1;
	Device.Base.xVR_Param.Dev_KineDataIn.OnTimer.Enable = !ALEX_Simulato;		Device.Base.xVR_Param.Dev_KineDataIn.OnTimer.Decimation = 1;
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX		

	#ifdef ENABLE_STEREO
	SceneSetParam(VR_HEADTRACKER,1);
	SceneSetParam(VR_EYE_SEPARATION,0.065);	
	SceneSetParam(VR_TRACKER_POSITION, 0, 0.0, 1.0);	
	#endif
	GlEnable(GL_NORMALIZE);
//	// GET DATE
//	var display = HandleDataIn("");
//	sscanf(display,"%s",&date);
//	trace(date);
	
	date = "1-1-2000";    // OKKIO ... NON PRESENTE IN DEMOLEXOS
	if(session!="Clock")	NUM_CUBES = 9;
	on_session[0] = 1;
	on_session[1] = 0;
	on_session[2] = 0;
	
	//================================
	// Graphic Setup
	//================================ 
	CameraSetPosition(CamPos);
	#ifndef SHADOW
	
		Luce = CVmLight();
		Luce.SetDiffuse(1,1,1);
		Luce.SetSpecular(1,1,1);
		Luce.Enable();	
		Luce.SetPosition(PosL);
		
	#else
	// SHADOW ON		
		light = CVmLight();
		light.SetDiffuse(1,1,1);
		light.Enable();	
		light.SetPosition(PosL);	
		/*
		 * Here, the Framebuffer Object (CVmFbo) is initialized
		 * 
		 * Parameters are:
		 * - type of FBO (VR_FBO_SHADOW, VR_FBO_DEPTH, VR_FBO_COLOR)
		 *     VR_FBO_COLOR is a color framebuffer
		 *     VR_FBO_DEPTH is a depth buffer
		 *     VR_FBO_SHADOW is a depth buffer with automatic depth comparison
		 *         (see Sampler2DShadow in GLSL)
		 * - width and height in pixels of FBO (if you have trouble with this,
		 *     try using square, power-of-2 dimensions)
		 * - format of framebuffer (use GL constants as GL_RGBA, GL_DEPTH_COMPONENT, etc.)
		 */
		fbo = CVmFbo(VR_FBO_SHADOW, 2048*2, 2048*2, GL_DEPTH_COMPONENT32);		
		/*
		 * You can retrieve the CVmTexture object associated to the frame buffer,
		 * but this in general is not necessary since you can pass the framebuffer object
		 * itself to SetActiveTexture()
		 */

		/*
		 * In case you are using color framebuffer objects, you may want to enable
		 * automatic mipmap generation, which is useful if you use the resulting image
		 * as a texture.
		 * Please beware that automatic mipmap generation could affect the overall performance
		 * of your application.
		 */
		shader = CVmShaderProgram(shader_name);
	 #endif
	var j;	
    forzaSx = [0.0, 0.0, 0.0];
	for (j = 0; j < NUM_SOUNDS; j++)
		SoundFX[j] = CVmVRAWav();
	
	outputln(getcurrentdir());
	var currdir = getcurrentdir();
	InitPhysicsEngine();
	outputln(getcurrentdir());
	SetCurrentDir(currdir);
	outputln(getcurrentdir());
		
	SoundFX[SFX_BUMP].Load("bump.wav");
	SoundFX[SFX_PICK].Load("tac.wav");
	SoundFX[SFX_CLAP].Load("clap.wav");
	SoundFX[SFX_FINISH].Load("fanfar1.wav");
	SoundFX[SFX_CLACK].Load("Clack.wav");
	SoundFX[SFX_DROP].Load("buttondrop.wav");
	//Graphic material for grab cursor
	matRosso = CVmMaterial();
	matRosso.diffuse = matRosso.ambient = [1,0,0,1];
	matRosso.specular = [0,0,0,1];
	matoff = CVmMaterial();	//GREY
	matoff.ambient   = 10*[0.1, 0.1, 0.1, 1.0];
	matoff.diffuse   = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.specular  = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.shininess = 1;
	maton = CVmMaterial();	//GREEN
	maton.ambient   = 10*[0.0, 0.2, 0.0, 1.0];
	maton.diffuse   = [0.0, 1.0, 0.0, 1.0];
	maton.specular  = 10*[0.1, 0.1, 0.1, 1.0];
	maton.shininess = 10;
	
	//Physic materal for grab cursor
	stickyMaterial =  manager_psx.NewMaterial(0.5, staticFriction, dynamicFriction);
	rigidMaterial = manager_psx.NewMaterial(0.5, 1, 0.6);
	
	//Init grab variable
	//posizione del primo e del secondo grab
	pos = [0.2, 0.0, 0.0, -0.2, 0.0, 0.0];	
	forzaSx = [0.0,0.0,0.0];
	setTimeStep(deltaSim);
	
	//Load and resize the meshs for the room
	m_stanza = CVmNewMesh("stanza.aam");
	m_stanza.Normalize(ROOM_SIZE);	
	o_stanza = CVmObj(m_stanza);
	o_stanza.Translate(0.0, 0.0, 0.0);
		
	//Create a plane for the floor
	var plane_handler = manager_psx.AddPhPlane([0.0,1.0,0.0], 0.0, rigidMaterial);	// floor_colgr = Collision group=20		
	plane_handler.AssignCollisionGroup(20);
	
	//Exos cursor
	sfera1 = manager_psx.AddPhSphere([pos[0]+camTarget[0], pos[1]+camTarget[1], pos[2]+camTarget[2]], [0.0,0.0,0.0], 0.015, PHX_DYNAMIC, 2000, 12, stickyMaterial);
	sfera1.SetMass(0.2);
	
	sfera1.SetGravity(false);	//Set the gravity of the cursor to zero 
	matred = CVmMaterial();
	matred.ambient   = [0.7, 0.0, 0.0, 1.0];
	matred.diffuse   = [0.4, 0.0, 0.0, 1.0];
	matred.specular  = [0.2, 0.0, 0.0, 1.0];
	matred.shininess = 0.8;
	matred.transparency = 0.5;
	
	// LIGHT SOURCE
	M_light = CVmNewMesh("sphere.aam");
	M_light.Normalize(0.5);
	O_light = CVmObj(M_light);
	O_light.ForceMaterial(matred);
	O_light.SetPosition(PosL);
	
	//With an high inertia tensor the cursor can't rotate
	sfera1.SetInertiaTensor([10000, 10000, 10000]);
	UDP_Channel = NetCreateChannel(XVR_Port, Void, VR_NO_BLOCKING);	
	//MS check for new commands from external GUI	
	LoadPuzzle();	
	LoadBasket();	
	
	
	var Sfera_Mesh = CVmNewMesh(VRP_SPHERE, 30, 0.015, 1.0);
	Device_EE_sfera = CVmObj(Sfera_Mesh);
	
	App_EE_sfera = CVmObj(Sfera_Mesh);
	App_EE_sfera_Pos = [ 0.0, 0.0, 0.0 ];
	
	
	 #ifdef SHADOW
	/*
	 * Put camera "1" where the light is and orient it towards the center of the scene.
	 * If you want to move the light, please move this camera accordingly
	 */	
	CameraActivate(LIGHT_CAMERA);
	CameraSetPosition(PosL);		
	CameraSetTarget([0, 0, 0]);
	CameraActivate(SCENE_CAMERA);
	#endif
	
	Hoff = 0.0;  // HORIZONTAL POS
	Voff = 0.0;  // VERTICAL POS       
	Doff = 0.45;//-0.5; // DEPTH
	Pos_Offset_VR = [ Hoff,Doff,Voff ];
	Pos_Offset_Dev = [ 0,0,0 ];	
	Scale = 3.0;
	pos = [0.0, 0.0, 0.0];
	oldHoff = Hoff; 
	oldVoff = Voff;  
	oldDoff = Doff;
	oldScale=Scale;
	ADC_TSHOLD=0.5;
	firstFrame=false;
	
	SendData("ONINIT_OK");
			
} 	// ONINIT

#ifdef SHADOW
// light projection and modelview matrices
var light_mat_proj=array(2);
var light_mat_modelview=array(2);

function RenderOnTexture(luce)
{
	CameraActivate(luce);	
	shader.activate(true);
	/*
	 * First of all, you have to notify your intention
	 * to draw on the offscreen framebuffer you have created
	 * (that is, render to texture)
	 */
	fbo.Start();	
	/*
	 * Then, you start drawing as usual in XVR
	 */	
	SceneBegin();		
	/*
	 * Retrieve the modelview and projection matrix of the light
	 * and save them; of course if the light is fixed, this is
	 * needed only once
	 */
	light_mat_proj[luce-1]      = glGet(GL_PROJECTION_MATRIX);
	light_mat_modelview[luce-1] = glGet(GL_MODELVIEW_MATRIX);	
	/*
	 * Polygon offset is needed in order to avoid artifacts in the
	 * final image due to low precision of depth buffer values
	 */
	glEnable(GL_POLYGON_OFFSET_FILL);
	glPolygonOffset(2, 2);		
	/*
	 * Here, draw all the objects that should CAST shadows
	 */
	var view_scale=-0.025;		
	var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];

	DrawLine(temp_pos_sfera,arrowEnd,1,0,0);	
	manager_psx.Draw();
	glDisable(GL_POLYGON_OFFSET_FILL);	
	SceneEnd();		
	/*
	 * Tell XVR that you are done with the offscreen framebuffer
	 * and that subsequent draw operations should occur on the screen
	 */
	fbo.Stop();
}
	
function FillTextureMatrix(luce)
{
	glMatrixMode (GL_TEXTURE);
	
	/*
	 * First of all, we have to clamp the values in the [0.0,1.0] range
	 * instead of the [-1.0,1.0] we obtain from the view matrices
	 */
	glLoadIdentity();
	glTranslate(0.5, 0.5, 0.5);
	glScale(0.5, 0.5, 0.5);
	
	/*
	 * Next, multiply by the previously retrieved light matrices
	 */
	glMultMatrix(light_mat_proj[luce-1]);
	glMultMatrix(light_mat_modelview[luce-1]);
	
	/*
	 * Finally, we multiply by the inverse of the *current* modelview matrix
	 * This is needed because it is already included in each vertex own modelview
	 */
	var s_mat_m = glGet(GL_MODELVIEW_MATRIX);
	
	/*
	 * This matrix should always be invertible, but still...
	 */
	if (! InvertMatrix(&s_mat_m))
		Quit("Singular view matrix!");
	
	glMultMatrix(s_mat_m);
}
#endif	//SHADOW



/*
var umbraColor = 0.9;
var umbraHeight = 0.05;
var globalCounter = 0;
var radius = 0.010;




function shadow_halo(p,s,n)
{
	var i,j;
	var h, insideHaloRadius, outsideHaloRadius, penumbraColor;
	var sphereRadius = radius;
	// disgusting hack
	// but OpenGL really does not like complanar overlapping polygons
	// this guarantees that the shadows are never complanar, and that there is no bleeding
	
	h = 0.1+n*0.2;
	
	if (s<umbraHeight) {
	
	insideHaloRadius = ((umbraHeight-s)/umbraHeight)*sphereRadius;
	outsideHaloRadius = s + sphereRadius*1.4;
	} else 
	{	
	insideHaloRadius = 0;
	outsideHaloRadius = s;
	}
	
	//shaded penumbra halo
	
	if (s<umbraHeight) {
	penumbraColor = umbraColor;
	} else {
	penumbraColor = umbraColor*(200-s)/200;
	}
	
	glBegin(GL_QUAD_STRIP);
	for (i=0;i<circleSteps+1;i+=2) {
		if(i==circleSteps) {
			j = 0;
		} else {
			j = i;
			}

		glColor(0,0,0,penumbraColor);
		glVertex(p+[cosines[j]*insideHaloRadius, h, sines[j]*insideHaloRadius]);
		glColor(0,0,0,0);
		glVertex(p+[cosines[j]*outsideHaloRadius, h, sines[j]*outsideHaloRadius]);
	}
	//consoleText(0.2,i/100,str(cosines[i]));	
	glEnd();
	
	//solid central shadow (umbra)
	glColor(0,0,0,umbraColor);
	glBegin(GL_POLYGON);
	for (i=0;i<circleSteps+1;i+=2) {
		if(i==circleSteps) {
			j = 0;
		} else {
			j = i;
		}
		glVertex(p+[cosines[j]*insideHaloRadius, h, sines[j]*insideHaloRadius]);
	}
	glEnd();
	


}

 
function Shadow_fun(p,n) //Just a simple trick
{
	// for spheres of 10 radius
	var s=(p[1]-radius);
	
	p[1]=0.7;  
	glDisable(GL_TEXTURE_2D);
	glColor(0,0,0,0.7);
	glDisable(GL_LIGHTING);
	glEnable(GL_BLEND);
	glPolygonOffset(1.0,1.0);
	shadow_halo(p,s,n);
}

 */
 
 
function DrawScene()
{	
	
				
		
	#ifdef SHADOW	// 3D VIEW
		FillTextureMatrix(LIGHT_CAMERA);	
		glMatrixMode(GL_MODELVIEW);		
		shader.Start();		
		SetActiveTexture(fbo,0,4);
		shader.SetParameter("shadowMap", 4);
		shader.SetParameter("tex", 0);			
		var view_scale=-0.025;		
		var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
		DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
		o_stanza.Draw();
		manager_psx.Draw();
		
		if ( session == "Puzzle" )	// DISPLAY THE PICTURE
		{	
			glColor(1.0,1.0,1.0,0.5);
			glEnable(GL_BLEND);													
			DrawPolygonXZ(Map,-CUBE_SIZE*3/2,CUBE_SIZE*3/2, CUBE_SIZE*3/2, -CUBE_SIZE*3/2, CUBE_SIZE);							
			glDIsable(GL_BLEND);
			glColor(1.0,1.0,1.0,1.0);
		}
		
		if ( session == "Basket" )
		{
			o_basket.draw();					
		}
		
		if (session == "Clock" )
		{
			for (var i=0;i<NUM_CUBES;i++)
				v_cube[i].Draw();
		}				

    shader.Stop();    	
		
	#else
		var view_scale=-0.025;		
		var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
	 
		DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
		o_stanza.Draw();				
		manager_psx.Draw();
		
		if ( session == "Puzzle" )	// DISPLAY THE PICTURE
		{	
			glColor(1.0,1.0,1.0,0.5);
			glEnable(GL_BLEND);					
			
			DrawPolygonXZ(Map,-CUBE_SIZE*3/2,CUBE_SIZE*3/2, CUBE_SIZE*3/2, -CUBE_SIZE*3/2, CUBE_SIZE);					
			
			glDIsable(GL_BLEND);
			glColor(1.0,1.0,1.0,1.0);
		}
		
		if ( session == "Basket" )
		{
			o_basket.draw();
		}
		
		if (session == "Clock" )
		{
			for (var i=0;i<NUM_CUBES;i++)	
				v_cube[i].Draw();
		}
		

	#endif
	TaskBar();				
}

var isgrabbed=0;	// EVENT FOR DATALOG
var grasp_on=0;
var startedtask=false;	// START OF PUZZLE FLAG
var keyon=false;
var oldpatient ="";
var plotdataon = false;
var stri_obj2="";
var t_start,t_msg;
var calibkey_on = false;
var scalekey_on = {false,false};

var	changeStatusIntro_timer = 0;
var bullet=-1;
var setRecordFlag = false;
function OnFrame()
{
//	CameraMoveMouse();
	
	if (!firstFrame)
	{
		senddata("INT");
		firstFrame=true;
	}
	
	HiVel = -(pos - dev_pos_old)*1000.0;
	dev_pos_old = pos;
	manager_psx.SetSceneGravity([0.0,-9.8,0.0]);
	
	if(keypressed("c")&&!calibkey_on)
	{
		Pos_Offset_Dev = dev_pos;
		calibkey_on=true;
		output("Offset=",Pos_Offset_Dev);
	}
	
	if(!keypressed("c"))
		calibkey_on=false;

	if(keypressed(VK_UP)&&!scalekey_on[0])
	{
		Scale=Scale+0.25;
		if(Scale >= 8.0)	
			Scale = 8.0;				
		scalekey_on[0]=true;
	}
	
	if(!keypressed(VK_UP)) 
		scalekey_on[0]=false;
	
	if(keypressed(VK_DOWN)&&!scalekey_on[1])
	{
		Scale=Scale-0.25;
		if(Scale <= 1.5)	
			Scale = 1.5;				
		scalekey_on[1]=true;
	}
	
	if(!keypressed(VK_DOWN)) 
		scalekey_on[1]=false;
		
	/* MANUAL ENABLE FORCE AND ASSIST */
//	if(keypressed("h")){
//		if(bullet==-1){
//			h_required = !h_required;
//			bullet = 0;	
//		}		
//	}
//	if(keypressed("f")){
//		if(bullet==-1){
//			isForceEnabled=!isForceEnabled;
//			bullet = 0;	
//		}		
//	}
//	if(bullet != -1)
//		bullet++;
//	if(bullet == 30)
//		bullet = -1;
	/* ------------------------------ */

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
	Device.OnFrame();
	Device_EE_sfera.SetPosition(t_class.GetPos_DevToXvr(Device.Dev_DataIn.xVR_EE_Pos));
	App_EE_sfera.SetPosition(xVR_Device_Target_Pos);
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	//MS check for new commands from external GUI
	ReceiveData(UDP_Channel);
	if(plotdataon)	
		view_plot();
	
	if (checkApp){	
			
			if (keypressed(VK_ESCAPE))
			{
				for(var i=0;i<4;i++)
					kp[i]=0.0;
				outputln("QUIT");
				application.quit();
			}
			#ifdef __DEBUG
				ConsoleColor(0.8,0.8,0.8,0.5);
				ConsoleFilledRect(0.52,0.99,0.35,0.32);
				var stri_x=0.55,stri_y=0.9,stri_dx,stri_dy=-0.03;
				ConsoleFont("Arial", 18);
				ConsoleColor( 0.0, 0.0 , 0.0, 1.0 );
				var stri = sprintf("Posizione: %f %f %f",pos[0],pos[1],pos[2]);
				Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Vel: %2.1f %2.1f %2.1f",HiVel[0],HiVel[1],HiVel[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Pos Sfera: %f %f %f",temp_pos_sfera[0],temp_pos_sfera[1],temp_pos_sfera[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Compensazione Gravita': %f", GravityComp);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Cubo selezionato: %d, Cubo Inserito: %d", sel_obj,mat_obj);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Distanza Minima %f", temp_dist);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Forza: %2.1f %2.1f %2.1f",Force[0],Force[1],Force[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Forza sx: %2.1f %2.1f %2.1f",forzaSx[0],forzaSx[1],forzaSx[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Forza Abilitata: %1.0f", ForceStatus);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Grab Forza: %2.1f", Fgrab);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			#endif		

			static var camera_angle = 0;
			#ifdef ENABLE_STEREO
			var camera_radius = 0.1;//1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#else
			var camera_radius = 1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#endif
			var cam_end,tar_end;
			var glob_end=0;
			static var sel_now = true;
			var CameraPosT;		
			switch(stato)
			{
				case INTRO_:
					// ROTATION SPEED OF CAMERA AROUND THE PUZZLE
					camera_angle += 0.005;		
					CameraPosT = [camera_radius*cos(camera_angle), camera_elevation + camera_osc*sin(camera_angle), camera_radius*sin(camera_angle)];
					CameraSetPosition(CameraPosT);
					CameraSetTarget(CamTarget2D);					
					// DISABLE COLLISION AMONG CUBES AND PROXY
					// IF THE DEVICE NOT INITIALIZED
					if((EndInit==0)&&(!plotdataon))
					{		
						disp(0.5,0.55,"EXOS NOT INITED",0,"R",40,1);
						for(var j=0; j<NUM_CUBES; j++)
						manager_psx.DisableCollision(0,j+1);
					}
					else
					{
						disp(0.5,0.55,"WAIT, PLEASE",0,"R",40,1);
						for(var j=0; j<NUM_CUBES; j++)
							manager_psx.DisableCollision(0,j+1);
					}
					// GO TO THE NEXT STATE ONLY IF ENCODERS ARE SET
					//if((mouse.ButtonL)&&(EndInit==1)&&(!plotdataon))	/* USE MOUSE LEFT BUTTON INSTEAD OF WAITING */
					if((changeStatusIntro_timer == 50)&&(EndInit==1)&&(!plotdataon))
					{
						stato = INTRO2_;
					}				
					changeStatusIntro_timer++;
					
					break;
				
				case INTRO2_:	
					changeStatusIntro_timer = 0;				
					disp(0.5,0.55,"READY...",0,"R",40,1);					
					CameraSetTarget(CamTarget2D);
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],CamPos2D[2],90-(camera_angle*180/PI)%360);
					Tar_end = 1;	
					glob_end = Cam_end + Tar_end;
	
					if (glob_end == 2)
					{
						for(var j=0; j<NUM_CUBES; j++)
							manager_psx.EnableCollision(0,j+1);						
						switch(session)
						{
							case "Puzzle":
								ManageCollision();
								stato = PUZZLE_;
								task="P";
								break;
							case "Basket":							
								stato = BASKET_;
								task="B";
								break;
							case "Clock":							
								stato = CLOCK_;
								task="C";
								break;
						}
						glob_end=0;
						t_start=getperformancetimer()/1000000.0;
						outputln(session);
					}
				break;
				
				case PUZZLE_:
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					
					#ifdef __DEBUG2
					disp(0.5,0.1,"PUZZ",0,"R",40,1);
					#endif
					#ifdef __DEBUG
					for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
					for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
					for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
					#endif
	
					if(grabbed())
					{
						#ifdef __DEBUG2
						var stri_obj=sprintf("N.%d PRESO",sel_obj);
						disp(0.2,0.8,stri_obj,0,"R",50,1);
						#endif
						attachCube(); //ENABLE THE GRID
						if (sel_now)
						{
							#ifdef __DEBUG2
							var stri_obj=sprintf("N.%d PRESO",sel_obj);
							disp(0.2,0.8,stri_obj,0,"R",50,1);
							#endif
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						// ALL CUBES MATCHED
						if((len(free_cubes)==0)&&(startedtask))
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
						sel_now = true;
					}	
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;
					}	
					break;
				
				case BASKET_:				
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}	
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
	
					#ifdef __DEBUG2
					disp(0.5,0.1,"BASK",0,"R",40,1);
					#endif
					#ifdef __DEBUG
					for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
					for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
					for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
					#endif			
					// IF CUBE GRABBED
					if(sel_obj!=0)
					{
						#ifdef __DEBUG
						var stri_obj=sprintf("N.%d PRESO",sel_obj);
						disp(0.2,0.8,stri_obj,0,"R",50,1);
						#endif
						ThrowBasket();
						if (sel_now)
						{
							#ifdef __DEBUG
							var stri_obj=sprintf("N.%d PRESO",sel_obj);
							disp(0.2,0.8,stri_obj,0,"R",50,1);
							#endif
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						if((len(free_cubes)==0)&&(startedtask))	// WHEN FREE CUBES NO MORE
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
					}					
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;					
					}							
				break;

				case CLOCK_:
					
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}
						
	
					#ifdef __DEBUG2
					disp(0.5,0.1,"CLK",0,"R",40,1);
					#endif
					#ifdef __DEBUG
					for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
					for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
					for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
					#endif
	
					#ifdef __DEBUG2
					stri_obj2 = sprintf("N.%d PRESO",sel_obj);
					disp(0.2,0.8,stri_obj2,0,"R",50,1);
					#endif
					
					if(sel_obj!=0)	// IF A CUBE IS GRABBED
					{
						attachClock();
						if (sel_now)
						{
							#ifdef __DEBUG2
							var stri_obj=sprintf("N.%d PRESO",sel_obj);
							disp(0.2,0.8,stri_obj,0,"R",50,1);
							#endif
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						if((len(free_cubes)==0)&&(startedtask))	// AT THE END OF TASK, WHEN THERE ARE NO FREE CUBES
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
						sel_now = true;
					} 
	
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;
					}				
				break;

				case END_:
		
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],0.0,0.0);
					Tar_end = 1;
					glob_end = Cam_end+Tar_end;
					SoundFX[SFX_FINISH].Play();
					SoundFX[SFX_CLAP].Play();
	
					if(!reqscore) //IF NOT ALREADY REQUESTED...
					{
						senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
						reqscore = true;
					}
					session="";
					if((glob_end == 2)&&(!scoreloaded))
					{
						stato = END2_;
					}				
				break;
				
				case END2_:	
				
					// PLOT TO CHECK
					if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
					{
						if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
						{						
							plot(scores,"CONGRATULATION!");
							if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
							}
						}
						else
						{						
							disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
							disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
							if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
							}							
						}
					}
					else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
					{					
						disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
						disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
						if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
						}
						
					}
					reqscore=false;
					scoreloaded=false;
					timer = 0.0;
					
					#ifdef _DEBUG
						outputln(session,"========",prev_session);
						for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
						for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
					#endif
					if(session!="")		
					{
						switch(session)
						{
							case "Puzzle":
								stato = PUZZLE_;
								break;
							case "Basket":
								stato = BASKET_;
								break;
							case "Clock":
								stato = CLOCK_;
								break;
						}
						glob_end=0;
					}
				break;
			}//switch(stato)

			#ifdef _DEBUG
			outputln("NUMBER OBJECTS = ",NUM_CUBES);
			outputln("SESSION = ",session);
			outputln("PREV SESSION = ",prev_session);
			outputln(" ***************************************************");
			#endif
			if((temp_isSelected)&&(sel_obj>0))
			{
//				m_cube[sel_obj-1].SubsetModulateMaterial(1,[0.5,1.0,0.5]);
//				o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
			}
			else
			{
				for (var i=0;i<NUM_CUBES;i++)
				{					
					m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
					o_cube[i].LinkToMesh(m_cube[i]);
				}
			}
			
			#ifdef SHADOW
				RenderOnTexture(LIGHT_CAMERA);	
				CameraActivate(SCENE_CAMERA);
			#endif
			
		#ifndef ENABLE_STEREO		
				SceneBegin();
				DrawScene();				
				SceneEnd();
		#else //enable stereo
				glDrawBuffer(GL_BACK_LEFT);				
				SceneBegin(VR_STEREO_LEFT);	
				DrawScene();					
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			// DEVICE
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
				Device.OnScene();
				Device_EE_sfera.ModulateMaterials(0,1,0);
				Device_EE_sfera.Draw();
				App_EE_sfera.ModulateMaterials(1,0,0);
				App_EE_sfera.Draw();
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
				SceneEnd();				
				glDrawBuffer(GL_BACK_RIGHT);
				SceneBegin(VR_STEREO_RIGHT);			
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			// DEVICE
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
				Device.OnScene();
				Device_EE_sfera.ModulateMaterials(0,1,0);
				Device_EE_sfera.Draw();
				App_EE_sfera.ModulateMaterials(1,0,0);
				App_EE_sfera.Draw();
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX									
				DrawScene();				
			
				SceneEnd();
		#endif		
	}//CHECK APP
	else
	{
		if (keypressed(VK_ESCAPE))	
			application.quit();
		consolecolor(0.5,0.5,0.5,1.0);
		consolefont("ARIAL",30);
		consoletext(0.4,0.5,"TARGET NOT ACTIVE");
		consolefont("ARIAL",20);
		consoletext(0.44,0.45,"PRESS ESC TO EXIT,");
		consoletext(0.37,0.4,"CHECK THE ETHERNET CABLE AND THEN");
		consoletext(0.35,0.35,"RESTART THE TARGET AND THE APPLICATION");

	}
}

function Select(currPos)
{
		if (IsPressed == false) //controlla se il pulsante del device è stato premuto per la prima volta
		{
			var min_dist=10;

			for(var i=0; i<len(free_cubes); i++)
			{
				// IDENTIFY THE CLOSEST OBJECT TO THE PROXY
				var dist = pos - o_cube[free_cubes[i]-1].GetPosition();
				var dist_mod = dist[0]^2+dist[1]^2+dist[2]^2;
				if (dist_mod<min_dist)
				{
					min_dist=dist_mod;
					switch(session)
					{
						case "Basket":					
							if(min_dist<SELECT_DISTANCE){
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);	
								}								
								cube_to_reach = -1;
							}									
							#ifdef __DEBUG
							outputln("SELECTED(EVA)");
							#endif
							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
						
						case "Clock":
							// SELECTION SHOULD BE LED BY MINIMUM DISTANCE
							// AND SMALLEST NUMBER OF CUBE (IN CLOCKWISE SENSE)
							if((min_dist<SELECT_DISTANCE)&&(i==0))
							{
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);		
								}
								cube_to_reach = -1;
								for(var j=0; j<NUM_CUBES; j++)
									manager_psx.DisableCollision(sel_obj,j+1);
							}
							
							#ifdef __DEBUG
							outputln("SELECTED(CLK)");
							#endif
							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))							
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
						
						case "Puzzle":
							if(min_dist<SELECT_DISTANCE){
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);		
								}
								cube_to_reach = -1;
							}	
							#ifdef __DEBUG
							outputln("SELECTED(PUZ)");
							#endif

							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
					}
				} // endif dist_mod				
			} //endfor i	
			
			temp_dist=min_dist;
			
			// Minimum Distance to activate selection
			if ((min_dist<SELECT_DISTANCE)&&(sel_obj>0))
			{
				
				currPos = o_cube[sel_obj-1].GetPosition();
				HB_ini = currPos-pos;
				HB_old = currPos;
				IsPressed = true;
				isSelected = true;
			}
			else
			{
				IsPressed = false;
				isSelected = false;
				//grasp_on = 0;	// RELEASE CUBE
			}
		}
		
	 	//trace(grasp_on,isSelected,sel_obj);
	 	
	  	if (grasp_on==1 && isSelected && sel_obj>0)
	  	{	  		
	  		temp_check_force=isSelected;
	        currPos = o_cube[sel_obj-1].GetPosition();
	        HB_curr = currPos - pos;
			HB_speed = ( currPos - HB_old )*1000;
			// Force Feedback To Device
			HFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;
			// Reaction Force To The Objetc
			NFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;// - Bi*N_speed;
			HB_old = currPos;
			
			ScalaStiffObjSel=0.5;
			
		}  //end if isSelected
		else  //this else goes with isSelected
		{
			temp_check_force=false;
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
		}
}


function bar(xmn,ymn,value,ref,max,unit,title,dim,mode)
//	xmn,ymn = Position of Bar Left Bottom Corner
//  meas   = 1dim data measured
//	ref	= 1dim reference
//  max = 1dim max value
//  unit = dimensional unit
//  title = bar title
//  dim = bar dimension (if dim<0 ==> pos/neg scale )
//  mode = display modality (0:green band, 1:switch green/red)
{
	var delta = abs(ref - value);	// Interval around Reference on the Bar
	var eps = 0.05*max;				// Width Green Band (mode=0)
	var dx, dy;
	var maxF = max;
	var ky;				// FACTOR SCALE (SCREEN UNIT/NEWTON)
	var y;	
	var text;
	var wt = 0.01;					// width of tick
	var abx = 0.004;				// Transparent Bar Border
	var aby = 0.005;				// Transparent Bar Border
	var width;
	var fontscale;
	// COLOR
	var red=0.0, green=0.0;	
	switch(abs(dim))
	{
		case 0:		//BIG
			dx = 0.08;
			dy = 0.3;
			width = 3;
			fontscale = 1;
			break;
		case 1:		//MEDIUM
			dx = 0.05;
			dy = 0.15;
			width = 2;
			fontscale = 0.7;
			break;
		default:
			dx = 0.1;
			dy = 0.3;
			width = 3;
			fontscale = 1;
			break;
	}
	
	if(dim<0)
	{
		ky = dy/(2*maxF);
		y = ky*value;
	}
	else
	{
		ky = dy/maxF;
		y = ky*value;
	}

	// BAR LABEL
	ConsoleFont("Arial",fontscale*30);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%s",title);
	Consoletext( xmn + 1/len(text)*0.01, ymn + dy + 0.01, text);
	
	// GREEN BAND
	if (mode==0){
		if ((delta>=eps)&&(ref>1))
		{
			red=1.0;
			green=0.0;
		}
		else if ((delta<eps)&&(ref>1))
		{
		// BAR BECOME GREEN ONLY INSIDE THE INTERVAL ref+/-eps
			red = (delta / eps)^4;
			green = 1 - (delta/eps)^4;
		}
		else if (ref<1)
		{
			red=0.0;
			green=1.0;
		}
	}
	
	// SWTICH GREEN-RED
	if (mode==1){
		if (ref>1)
		{
			if (value<ref)
			{
				red=1.0;
				green=0.0;
			}
			else
			{
				red=0.0;
				green=1.0;
			}
		}
		else
		{
			red=1.0;
			green=0.0;
		}
	}

	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	if (dim<0)	ConsoleFilledRect(xmn+abx, ymn+dy/2+aby, dx-2*abx, -y);
	else		ConsoleFilledRect(xmn+abx, ymn+aby, dx-2*abx, -y);
	
	if ((abs(ref)>0.5)&&(abs(ref)<max)){
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(3);
		ConsoleLines([xmn+abx, ymn + ky*ref, xmn+dx-abx, ymn + ky*ref ]);
	}
	
	// BORDER BAR
	ConsoleColor(0.0,0.0,0.0,1.0);
	ConsoleWidth(width);
	ConsoleRect(xmn,ymn,dx,-dy);

	// ACTUAL VALUE LABEL
	ConsoleFont("Arial",fontscale*35);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%2.1f%s",value,unit);
	if (len(text)<=4)	Consoletext( xmn + 0.01, ymn - (0.04-dim*0.01), text);
	if (len(text)>4)	Consoletext( xmn, ymn - (0.04-dim*0.01), text);
	
	if (dim==0){
		// TICKS & LABEL
		ConsoleFont("Arial",fontscale*20);
		ConsoleWidth(width);
		ConsoleColor(0.0,0.0,0.0,1.0);
		for(var i=0; i<=maxF/10; i++){
			text = sprintf("%2.0f",(i*10));
			ConsoleLines([xmn,ymn + ky*(i*10),xmn - wt,ymn + ky*(i*10)]);
			Consoletext( xmn - 3*wt, ymn + ky*(i*10) - 0.008, text);
		}
	}
}

function SelezionaOggetto()
{
	var currPos=[0.0,0.0,0.0];
	
	if ((Device.Dev_DataIn.Handle_Press >= ADC_TSHOLD) || space_grasp)
		ADC_Bool=true;
	else
		ADC_Bool=false;
	 
		
	if(ADC_Bool||space_grasp)   
	{
		Fgrab = 2.75;
	}
	else
	{
		Fgrab = 0;
	}
	#ifdef HOLD_MOVE	// GRASP ONLY TO CATCH THE CUBE AND AUTOMATICALLY HOLD IT TIL YOU PUT IN THE RIGHT POS		
		
		 
		if ((ADC_Bool)&&(grasp_on==0) || space_grasp)
		{
			grasp_on = 1;
		}

		// EMERGENCY MANUAL DISABLE OF GRASPING
		if(KeyPressed(VK_RETURN))
		{
			sel_obj=0;
			grasp_on=0;
		}
		
		if (grasp_on==1)
		{
			Select(currPos);
			isgrabbed=1;
		}
		else
		{
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
			isgrabbed=0;
		}
	#else	// GRASP AND RELEASE
		
		if(ADC_Bool || space_grasp)
		{
			grasp_on = 1;
		}
		else
		{
			grasp_on = 0;
		}

		if((grasp_on==0)&&(sel_obj>0))
		{			
			m_cube[sel_obj-1].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
			o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
			sel_obj=0;
		}
		
		if (grasp_on==1)
		{
			Select(currPos);
			isgrabbed=1;
		}
		else
		{
//			Select(currPos);
//			HFor = [0.0,0.0,0.0];
//			NFor = [0.0,0.0,0.0];
//			IsPressed = false;
//			isSelected = false;
//			isgrabbed=0;
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
			isgrabbed=0;
		}
	#endif	
	
	if (isSelected)
	{
		if(sel_obj>0)
	   		o_cube[sel_obj-1].AddForce(NFor[0], NFor[1], NFor[2]);
	}		 
	 temp_pos=currPos;
	 temp_isSelected=isSelected;
}

var ind=0;
var count_space_grasp = -1;
var meshForStrobo_0;
var meshForStrobo_1;
var stroboSwitch = 1;
var stroboCount = 0;
var stroboCount_max = 100;
//Called 1000 time/sec get the position of the grabbers and performs physic simulation


var PrimoGiro1234 = true;
var Delta_Pos_Old = [ 0.0, 0.0, 0.0 ];
var Tempo_Old = -1.0;
var Delta_Tempo = 0.001;


var Mouse_X0 = 0.0;
var Mouse_Y0 = 0.0;


function SimulaEsoscheletro()
{
	if (Keypressed("q"))
	{
		Device.Dev_DataIn.Dev_EE_Pos[0] = Device.Dev_DataIn.Dev_EE_Pos[0] + (Mouse.deltax-Mouse_X0)/1000.0;
		
		if (Mouse.ButtonL)
		{
			Device.Dev_DataIn.Dev_EE_Pos[2] = Device.Dev_DataIn.Dev_EE_Pos[2] + (Mouse.deltay-Mouse_Y0)/1000.0;
		}
		else
		{
		Device.Dev_DataIn.Dev_EE_Pos[1] = Device.Dev_DataIn.Dev_EE_Pos[1] - (Mouse.deltay-Mouse_Y0)/1000.0;
		}
	}
	else
	{
		Mouse_X0 = Mouse.deltax;
		Mouse_Y0 = Mouse.deltay;
	}
	
	
	Device.Base.xVR_Param.VectPos3_Device_To_xVR(Device.Dev_DataIn.Dev_EE_Pos, &Device.Dev_DataIn.xVR_EE_Pos);
	
	var EE_Position_tmp = vector(3);
	var EE_Stiffness_tmp = vector(3);
	var EE_Viscosity_tmp = vector(3);
	var EE_Force_tmp = vector(3);
	
	Device.Base.xVR_Param.VectPos3_xVR_To_Device(Device.Dev_DataOut.xVR_EE_Pos, &EE_Position_tmp);
	Device.Base.xVR_Param.Scale_xVR_To_Device(Device.Dev_DataOut.xVR_EE_Stiffness, &EE_Stiffness_tmp);
	Device.Base.xVR_Param.Scale_xVR_To_Device(Device.Dev_DataOut.xVR_EE_Viscosity, &EE_Viscosity_tmp);
	
	//================================================================
	// CONTROLLO DI IMPEDENZA
	//================================================================
	var Forza = [0.0,0.0,0.0];

	dSx =  EE_Position_tmp - Device.Dev_DataIn.Dev_EE_Pos;
	ddSx =  (dSx - Delta_Pos_Old)/Delta_Tempo; // Raw Estimation of Sphere Speed
	Delta_Pos_Old = dSx;
	
	
//	ddSx =  (Device.Dev_DataIn.Dev_EE_Pos - Delta_Pos_Old)/Delta_Tempo; // Raw Estimation of Sphere Speed
//	Delta_Pos_Old = Device.Dev_DataIn.Dev_EE_Pos;
	
	
	    
    Forza = dSx  * EE_Stiffness_tmp[0] + ddSx * EE_Viscosity_tmp[0];
    
    var ForceSaturation = 25.0;
    // Force Saturation
    if (modulus(Forza)>ForceSaturation )
	{
		Forza[0]=Forza[0]/modulus(Forza)*ForceSaturation;
		Forza[1]=Forza[1]/modulus(Forza)*ForceSaturation;
		Forza[2]=Forza[2]/modulus(Forza)*ForceSaturation;	
	}
	
	EE_Force_tmp = [ Forza[0] , Forza[1] , Forza[2] ];
	
	if (isForceEnabled)
		Device.Dev_DataIn.Dev_EE_Force = EE_Force_tmp;
	else
		Device.Dev_DataIn.Dev_EE_Force = [0,0,0];
	
	Device.Base.xVR_Param.Vect3_Device_To_xVR(Device.Dev_DataIn.Dev_EE_Force, &Device.Dev_DataIn.xVR_EE_Force);
	
}



var Delta_Tempo_Medio = 0.001;
var Delta_Tempo_Told = 0.0;
var Delta_Tempo_Counter = 0;

var deltaT = 0.01;


var GuadagnoDiForza = 0.0;



function OnTimer()
{
	
	if(keypressed(VK_SPACE)){
		if(count_space_grasp == -1){
			if(!space_grasp)
				space_grasp = true;
			else 
				space_grasp = false;
			count_space_grasp = 0;
		}
	}
	if(count_space_grasp != -1){
		count_space_grasp = count_space_grasp + 1;
	}
	if(count_space_grasp == 1000){
		count_space_grasp = -1;
	}
	
//	if(ALEX20.Dev_DataIn.ADC[10]>ADC_TSHOLD)
//	{
//		grasp_on=1;
//	}
//	else
//	{
//		grasp_on=0;
//	}
	
	/* SELEZIONA QUALE CUBO RAGGIUNGERE */
	if(((grasp_on == 0) || (grasp_on == 1 && sel_obj == 0)) && cube_to_reach == -1){
		if(session == "Clock"){			
			cube_to_reach = clock_inc;
//			clock_inc+=1;	
		} else {
			cube_to_reach = h_class.FindClosestCube(pos, o_cube, free_cubes);	
		}
	}

	/* STROBO SUL CUBO */
	if(cube_to_reach != -1 && cube_to_reach <= 11){		
		if(stroboCount < stroboCount_max){
			stroboCount++;
		} else {
			stroboCount = 0;
			if(stroboSwitch == 1){
				stroboSwitch = 0;
				/* TEXTURE ON */
				o_cube[cube_to_reach].SetVisible(true);
			} else {
				/* TEXTURE OFF */				
				o_cube[cube_to_reach].SetVisible(false);
				stroboSwitch = 1;			
			}
		}	
	}

	// IF APP HAS NOT BEEN IDENTIFIED...
	if (!checkApp)
	{
		checkApp = true;		
	}
		
	EndInit = 1;
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device.OnTimer();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	if ( (Device.Base.ID == DEVICE_ID_TH20) || (Device.Base.ID == DEVICE_ID_MOUSE) )
		dev_pos = Estrai_Pos(Device.Dev_DataIn.xVR_EE_Matrix);
	
	if ( Device.Base.ID == DEVICE_ID_ALEX20)
		dev_pos = Device.Dev_DataIn.xVR_EE_Pos;
	
	t_class = Transformation(Scale,[Hoff,Doff,Voff],"x",-PIGRECO/2);     
	

	if (oldHoff!=Hoff || oldDoff!=Doff || oldVoff!=Voff || oldScale!=Scale)
	{
		posInit = pos;
		oldHoff = Hoff; 
		oldVoff = Voff;  
		oldDoff = Doff;
		oldScale=Scale;
	}
//	trace(grasp_on,isselected,sel_obj);
	switch(stato)
	{
		case PUZZLE_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto();
		break;
		case BASKET_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto();
		break;
		case CLOCK_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto();
		    #ifdef __DEBUG2
			outputln(sprintf("ONTIMER C:OBJ %d",sel_obj));
			#endif
		break;
		default:
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
		break;

	}//switch
	
	
	//var posSfera1_ini = sfera1.GetPosition();
	
	var dev_pos = Device.Dev_DataIn.xVR_EE_Pos;
	pos  = t_class.GetPos_DevToXvr(dev_pos);	

	var result = h_class.RunHelp(&h_required, &grasp_on, sel_obj, session, pos, o_cube, free_cubes, &assistSet, cube_to_reach);
	if (assistSet==1)
	{		
		senddata("STOP_ASSIST");
		assistSet=0;
	}

   
    
    if (keypressed("F"))
    	isForceEnabled = true;
    
    if (keypressed("H"))
    	h_required = true;
    
    if (keypressed("W"))
    	Device.Dev_DataIn.Handle_Press = 1;
    else
    	Device.Dev_DataIn.Handle_Press = 0;
    Device.Dev_DataOut.xVR_EE_Force[0] = 0.0;
	Device.Dev_DataOut.xVR_EE_Force[1] = 0.0;
	Device.Dev_DataOut.xVR_EE_Force[2] = 0.0;
	Device.Dev_DataOut.xVR_EE_Imp_Matrix = MATRIX_EYE3;
    
    
    
	if ( Device.Base.ID == DEVICE_ID_ALEX20)
	{
		
		Device.Base.DLL.DEV_INTERFACE_Set_Command_DataOut(Device.Base.Command.SharedMemory_ID, COM_START);
		
		if (isForceEnabled || h_required || activeInitPos)
		{
			Device.Dev_DataOut.xVR_EE_Stiffness = 1500.0 * [1.0, 1.0, 1.0];
			Device.Dev_DataOut.xVR_EE_Stiffness_Speed = 250.0 * [1.0, 1.0, 1.0];
			Device.Dev_DataOut.xVR_EE_Viscosity = 100.0 * [1.0, 1.0, 1.0];
			Device.Dev_DataOut.xVR_EE_Viscosity_Ass = 5.0 * [1.0, 1.0, 1.0];			// VISCOSITA' ASSOLUTA
		}
		else
		{
			Device.Dev_DataOut.xVR_EE_Stiffness = [0.0, 0.0, 0.0];
			Device.Dev_DataOut.xVR_EE_Stiffness_Speed = 2000.0 * [1.0, 1.0, 1.0];
			Device.Dev_DataOut.xVR_EE_Viscosity = [0.0, 0.0, 0.0];
			Device.Dev_DataOut.xVR_EE_Viscosity_Ass = [0.0, 0.0, 0.0];			// VISCOSITA' ASSOLUTA
			sfera1.SetPosition(pos);
		}				
	
		if(result.reach)	//SE DEVE RAGGIUNGERE IL TARGET
		{
			Device.Dev_DataOut.xVR_EE_Speed = 0.1;
//			sfera1.SetPosition(result.target);
//			sfera1.SetVelocity([ 0.0, 0.0, 0.0 ]);
			xVR_Device_Target_Pos = result.target;
			GuadagnoDiForza = 0.0;
		}
		else
		{
	 		if (isForceEnabled)
			{
				if(!h_required)
				{
					if (GuadagnoDiForza < 1.0)
					{
						GuadagnoDiForza = GuadagnoDiForza + 1.0/(600.0*3);
						if (GuadagnoDiForza >= 1.0)
						{
							GuadagnoDiForza = 1.0;
						} 
					}
					Device.Dev_DataOut.xVR_EE_Speed = 1000.0;
					var ForzaSfera = - ( t_class.GetVect_DevToXvr_WS(Device.Dev_DataIn.xVR_EE_Force) + NFor ) * GuadagnoDiForza;
	    			sfera1.AddForce(forzaSfera[0], forzaSfera[1], forzaSfera[2]);
				}
			}
		}
	}
	
	
	if (PrimoGiro1234)
	{
		if (ALEX_Simulato)
		{
			Device.Dev_DataIn.Dev_EE_Pos[0] = 0.0;
			Device.Dev_DataIn.Dev_EE_Pos[1] = -0.32;
			Device.Dev_DataIn.Dev_EE_Pos[2] = -0.204;
		}
		Tempo_Old = GetPerformanceTimer()/1000000.0;
		Delta_Tempo_Told = GetPerformanceTimer()/1000000.0;
		
		PrimoGiro1234 = false;
	}
	
	
	var Tempo = GetPerformanceTimer()/1000000.0;
	Delta_Tempo = Tempo - Tempo_Old;
	Tempo_Old = Tempo;
	
	Delta_Tempo_Counter++;
	if ( (Tempo - Delta_Tempo_Told) > 1.0 )
	{
		Delta_Tempo_Medio = (Tempo - Delta_Tempo_Told) / Delta_Tempo_Counter;
		Delta_Tempo_Told = Tempo;
		Delta_Tempo_Counter = 0;
//		trace(Delta_Tempo_Medio);
	}
	
	
	if (ALEX_Simulato)
		RunPhysicsEngine(Delta_Tempo);
	else
		RunPhysicsEngine(Delta_Tempo_Medio);
	
	
	
	var posSfera1 = sfera1.GetPosition();
	
	
	
	
	if(result.reach)	//SE DEVE RAGGIUNGERE IL TARGET
	{
		xVR_Device_Target_Pos = result.target;
	}
	else
	{
 		if (isForceEnabled)
		{
			if(!h_required)
			{
				xVR_Device_Target_Pos = posSfera1;
			}
			else
			{
				sfera1.SetPosition(pos);
			}
		}
		else
			xVR_Device_Target_Pos = pos;
	}
		
		
		
		
    Device.Dev_DataOut.xVR_EE_Pos = t_class.SetPos_XvrToDev(xVR_Device_Target_Pos);
    
    Device.Dev_DataOut.Counter = 0;		
	Device.UpDate_DataOut();
		
	if (ALEX_Simulato)
		SimulaEsoscheletro();
		
		
		

	if ( (!h_required) && (GuadagnoDiForza == 1.0) )
	{
		App_EE_sfera_Pos = posSfera1;
	}
	else
	{
		App_EE_sfera_Pos = pos;				
	}
		
	
}

function OnExit()
{
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
	Device.OnExit();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
	SendData("EXT");		
	outputln("EXIT");
	manager_psx.FreeMem();
}

//Checks if a cursor touch a cube
function grabbed()
{
//	for (var j=0;j<NUM_CUBES;j++){
//		if(manager_psx.InTouch(sfera1, o_cube[j])){
//			return true;
//		}
//	}
	if(sel_obj != 0)
		return true;
	else
		return false;
}

// Throw the grabbed cube automatically in the basket
function ThrowBasket()
{
	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].Type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();
			if(i==sel_obj-1)
			{				
				#ifdef __DEBUG
				outputln("POS CUBO = ",cubePos);
				#endif				
				// DEFINE THE LIMIT WHERE THROWING THE CUBE
				if( (cubePos[0]<centerpuzzle[0]+BASKET_LIMITX*CUBE_SIZE)&&(cubePos[0]>centerpuzzle[0]-BASKET_LIMITX*CUBE_SIZE) )
				{				
					if( (cubePos[2]<centerpuzzle[2]+BASKET_LIMITZ*CUBE_SIZE)&&(cubePos[2]>centerpuzzle[2]-BASKET_LIMITZ*CUBE_SIZE) )
					{								
						if (modul(ddSx)<MAXSPEEDFORTHROW)
						{
							m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
							o_cube[i].LinkToMesh(m_cube[i]);
							mat_obj = sel_obj;
							sel_obj = 0;
							
							#ifdef __DEBUG
							outputln("MATCH=",matched_cubes);
							outputln("FREE=",free_cubes);
							#endif
							
							aadd(matched_cubes,mat_obj);
							
							for(var j=0; j<len(free_cubes); j++)
								if(free_cubes[j]==mat_obj)
									adel(free_cubes,j);
							
							manager_psx.DisableCollision(0,mat_obj);								
							
							for(var j=1; j<=NUM_CUBES; j++)
								manager_psx.DisableCollision(mat_obj,j);
							
							o_cube[i].Setvisible(false);//false
							
							#ifdef __DEBUG
							outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
							outputln("MATCH=",matched_cubes);
							outputln("FREE=",free_cubes);
							#endif
							
							SoundFX[SFX_DROP].Play();
							grasp_on=0;	// RELEASE CUBE
						}	//end ifv
					}	//end ifcubepos2
				}	//end ifcubepos0			
			}	//end ifsel_obj
		}	//end ifo_cube
}

//Moves the cube to the nearest position
//if it's in the right place plays a sound and makes the cube inamovable
function attachCube()
{
	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].Type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			if(i==sel_obj-1)
			{		
				var z,x;
				for(z=-1;z<=1;z++)
				{
					for(x=-1;x<=1;x++)
					{
						// CHECK THE DISTANCE BETWEEN PROXY AND CENTER OF CUBE TO BE GRASPED
						var b = {x*CUBE_SIZE, CUBE_SIZE, z*CUBE_SIZE};
						mod = sqrt((cubePos[0] - b[0])*(cubePos[0] - b[0]) + (cubePos[1] - b[1])*(cubePos[1] - b[1]) + (cubePos[2] - b[2])*(cubePos[2] - b[2]));
						if(mod < CUBE_SIZE/2)
						{
							if( x == i%3-1 && z == 1-floor((8-i)/3) )
							{
								o_cube[i].SetPosition([x,0.95,z]*CUBE_SIZE);
								m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
								o_cube[i].LinkToMesh(m_cube[i]);
								cube_grid[i*2] = x;
								cube_grid[i*2+1] = z;
								o_cube[i].MakeKinematic();
								o_cube[i].SetRotation(-90,[1,0,0]);
								
								mat_obj = sel_obj;
								sel_obj = 0;
								
								#ifdef __DEBUG
								outputln("MATCH=",matched_cubes);
								outputln("FREE=",free_cubes);
								#endif
								
								aadd(matched_cubes,mat_obj);
								
								for(var j=0; j<len(free_cubes); j++)
									if(free_cubes[j]==mat_obj)
										adel(free_cubes,j);										
								
								SoundFX[SFX_CLACK].Play();
								manager_psx.DisableCollision(0,mat_obj);
								
								for(var j=0; j<NUM_CUBES; j++)
									manager_psx.DisableCollision(mat_obj,j+1);
								
								#ifdef __DEBUG
								outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
								outputln("MATCH=",matched_cubes);
								outputln("FREE=",free_cubes);
								#endif
								
								grasp_on=0;	// RELEASE CUBE
							} //end ifxy
						} //end ifmod
						if(grasp_on==0)	break;
					}// end forx
					if(grasp_on==0)	break;
				}// end forz										
			}//end ifmodv
		}//end ifo_cube		
} //end function attachCube

// Attach the cube to the nearest grid-clock position
// if it's in the right place plays a sound and makes the cube inamovable
function attachClock()
{
	var i=sel_obj-1;	// SELECTED CUBE

	#ifdef __DEBUG2
	outputln(" ***** SEL=",i);
	#endif
	if (( i!=-1 )&&( o_cube[i].type==PHX_DYNAMIC ))
	{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			// MODULUS OF DISTANCE BETWEEN SELECTED CUBE AND ITS RIGHT CLOCK POSITION
			mod = modulus(cubePos - [ clock_position[i][0],CUBE_SIZE,clock_position[i][2] ] );
			#ifdef __DEBUG2
			outputln(" ***** TARGET POS =",clock_position[i]);
			outputln(" ***** CUBE POS =",cubePos);
			outputln(" ***** DIST =",mod);
			#endif
			// IF CUBE IS CLOSE TO THE RIGHT POSITION...
			if(mod < CUBE_SIZE/3)
			{
				o_cube[i].SetPosition([ clock_position[i][0],CUBE_SIZE,clock_position[i][2] ]);
				m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
				o_cube[i].LinkToMesh(m_cube[i]);
				o_cube[i].MakeKinematic();
				o_cube[i].SetRotation(-90,[1,0,0]);
				o_cube[i].Setgravity(false);
				o_cube[i].Setvisible(true);
				mat_obj = sel_obj;
				sel_obj = 0;
				
				#ifdef __DEBUG2
				outputln("MATCH=",matched_cubes);
				outputln("FREE=",free_cubes);
				#endif
				
				aadd(matched_cubes,mat_obj);
				
				for(var j=0; j<len(free_cubes); j++)
					if(free_cubes[j]==mat_obj)
						adel(free_cubes,j);
				
				SoundFX[SFX_CLACK].Play();
				manager_psx.DisableCollision(0,mat_obj);	// DISABLE COLLISION WITH PROXY
				
				// DISABLE COLLISION WITH THE OTHER CUBES
				for(var j=0; j<NUM_CUBES; j++)
					manager_psx.DisableCollision(mat_obj,j+1);
				
				#ifdef __DEBUG
				outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
				outputln("MATCH=",matched_cubes);
				outputln("FREE=",free_cubes);
				#endif
				
				grasp_on=0;	// RELEASE CUBE
				clock_inc+=1;
			} //end ifmod
			
			if(grasp_on==0)
			{
				#ifdef __DEBUG
				outputln("LOADING NEXT CUBE...");
				#endif
				
				LoadCube();
				break;
			}
	}//end ifo_cube		
} //end function attachClock


#define CAMERA_SPEED 0.97//0.97
#define CAMERA_DIST  0.05
#define CAMERA_ROT	0.96//0.94
#define ALPHA_TOL	0.002
#define TARGET_SPEED 0.95//0.95
#define TARGET_DIST  0.0001
#define ALPHAOFF	0.0
/****************************************/
/*		  	    MoveCameraTo			*/
/****************************************/
function MoveCameraTo(x,y,z,startangle)
{
	var temp;
	var dist;
	var camdir;
	var axis;
	var speed=CAMERA_SPEED;
	var alphaspeed=CAMERA_ROT;
	static var alpha=0;

	temp=CameraGetPosition();
	camdir=Cameragetdirection();
	// UPDATING ORIENTATION (ONLY FOR 2D)...
	if(abs(startangle)>0.0)	alpha = (startangle+ALPHAOFF) - ( (startangle+ALPHAOFF) - alpha )*alphaspeed;

	// UPDATING POSITION...
	temp[0] = x - (x-temp[0])*speed;
	temp[1] = y - (y-temp[1])*speed;
	temp[2] = z - (z-temp[2])*speed;

	dist=((temp[0]-x)^2)+((temp[1]-y)^2)+((temp[2]-z)^2);
	
	if(dist>=CAMERA_DIST)	CameraSetPosition(temp);
	if(abs(startangle)>0.0)
	{
		CameraFree();
		CameraRotate(alpha,-camdir);
	}
	
	if(dist<CAMERA_DIST) 
	{
		if( ((abs(startangle)>0.0)&&(abs(startangle+ALPHAOFF-alpha)<ALPHA_TOL)) || (abs(startangle)==0.0))
		{
			return 1;
		}
		else return 0;
	}
	else return 0;
}

function ManageCollision()
{
	var init_radius;
	var init_ang;

	init_radius = CIRCLE_RADIUS*CUBE_SIZE;
	
	if(session=="Clock")
	{
		for (var j=0;j<NUM_CUBES;j++)
		{	// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				manager_psx.DisableCollision(1,j+1);	// COLLISION AMONG FIRST AND ALL OTHER CUBES
				manager_psx.DisableCollision(0,j+1);	// COLLISION AMONG PROXY AND ALL OTHER CUBES
			}
		}
	}
	else
	{
		for (var j=0;j<NUM_CUBES;j++)
		{
			manager_psx.EnableCollision(floor_colgr,j+1);
			manager_psx.EnableCollision(0,j+1);
			for (var k=j;k<NUM_CUBES;k++)
				manager_psx.EnableCollision(j,k+1);
		}
		
		if(on_session[2]==1)
		{
			init_ang = 0;
			for(var j=NUM_CUBES; j<NUM_CUBES+3; j++)
			{
				cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*CUBE_SIZE, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
				o_cube[j].SetPosition(cube_position[j]);
				o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
				init_ang = init_ang - 2*PI/12;
			}
		}		
	}
}

function InitPositions()
{
	var i,j;
	var init_radius;
	var init_ang;

	if(session=="Clock")
	{
		init_radius = CIRCLE_RADIUS*CUBE_SIZE;
		init_ang = PI - 2*PI/12;	
		// DEFINE A GRID FOR THE POSITION OF CUBES AT THE CLOCK NUMBERS
		for (j=0;j<NUM_CUBES;j++)
		{	// INIT THE CUBEGRID FOR THE FINAL CHECK 
			cube_grid[j*2] = 0.0;
			cube_grid[j*2+1] = 0.0;			
			clock_position[j] = [ init_radius*sin(init_ang), 0.2*CUBE_SIZE, init_radius*cos(init_ang) ] + CenterPuzzle;
			// INIT THE VIRTUAL CUBES OF CLOCK (FOR DEBUG)
			v_cube[j].SetPosition(clock_position[j]);
			v_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
			
			// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
			if(j==0)
				cube_position[j] = [ 0.0, 0.0, 0.0 ] + CenterPuzzle;
			else
				cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*CUBE_SIZE, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
			
			o_cube[j].SetPosition(cube_position[j]);
			o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
			o_cube[j].SetMass(0.1);
			init_ang = init_ang - 2*PI/12;
		}		
		outputln("++++++++++++++++++++++++++++++");	
		for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
		outputln("++++++++++++++++++++++++++++++");	
	
	}
	else
	{	
		init_radius = CIRCLE_RADIUS*CUBE_SIZE;
		init_ang = 0;
		for (j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
			// INIT THE CUBEGRID FOR FINAL CHECK 
			cube_grid[i*2] = 0;
			cube_grid[i*2+1] = 0;
			// THE CUBE_GRID REPRESENTS ONLY A INITIAL VIRTUAL DISPLACEMENT OF THE CUBES
			// THE SAME USED IN THE 3D VIEW
			cube_position[i] = [ init_radius*sin(init_ang), CUBE_SIZE/2.0, init_radius*cos(init_ang) ] + CenterPuzzle;
			o_cube[i].SetVisible(true);	
			o_cube[i].SetPosition(cube_position[i]);
			o_cube[i].SetRotation(-90,[1.0,0.0,0.0]);
			init_ang = init_ang + 2*PI/9;
		}
		
		outputln("++++++++++++++++++++++++++++++");	
		for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
		outputln("++++++++++++++++++++++++++++++");	
	}
	h_class = Help(NUM_CUBES, CUBE_SIZE, centerpuzzle, centerbasket, clock_position);
	
	if(cube_to_reach != -1 && cube_to_reach <= 11){
		o_cube[cube_to_reach].SetVisible(true);	
	}		
	cube_to_reach = -1;
}

function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y)
{
	SetActiveTexture(my_texture);
	glDisable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glRotate(0.0,0.0,1.0,0.0);
	glBegin(GL_QUADS);
		
	glTexCoord(1,0);
	glVertex(tox, y, toz);	
			
	glTexCoord(0,0);
	glVertex(fromx, y, toz);	
				
	glTexCoord(0,1);
	glVertex(fromx, y, fromz);	
				
	glTexCoord(1,1);
	glVertex(tox, y, fromz);	
	glEnd();

	glDisable(GL_TEXTURE_2D);
	
	glColor(0.61,0.1,0.12);
	glBegin(GL_QUADS);		
	glVertex(tox  +0.005, y-0.0025, toz  +0.005);					
	glVertex(fromx-0.005, y-0.0025, toz  +0.005);	
	glVertex(fromx-0.005, y-0.0025, fromz-0.005);	
	glVertex(tox  +0.005, y-0.0025, fromz-0.005);	
	glEnd();
	glEnable(GL_LIGHTING);
}

function DrawGrid()
{
	var i;
	var size = CUBE_SIZE;
	glLineWidth(1);
	glBegin(GL_QUADS);
	for(i = -1; i<= 1; i++){
		glColor(0.7-i*0.3, 0.7-i*0.3, 0.7-i*0.3);
		glVertex(+size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2);
		glVertex(-size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2);
		glVertex(-size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2+size);
		glVertex(+size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2+size);
	}
	glEnd();
}

function DrawLine(pos1,pos2,r,g,b)
{
	glLineWidth(5);
	glColor(r, g, b);
	glEnable(GL_BLEND);
	glDisable(GL_LIGHTING);
	glBegin(GL_LINES);
	
	glVertex(pos1[0], pos1[1], pos1[2]);
	glVertex(pos2[0], pos2[1], pos2[2]);

	glEnd();
	glEnable(GL_LIGHTING);
	glDisable(GL_BLEND);
}

// simple receiver on udp port, eat all data
function ReceiveData(UDP_Channel)
{
	while(true)
	{
		var address;
		var data = NetVarReceiveFrom(UDP_Channel, &address);				
		if(data != Void) {				
		
			#ifdef __DEBUG_GUI
			OutputLN("Received ",data," from ",address);
			#endif			
			ProcessData(data);
		}
		else
			break;
	}
}

// simple sender on udp port, eat all data
function SendData(data)
{
	NetVarSendTo("127.0.0.1", GUI_port, data);
}

// Processes all instructions that are received from the UDP channel
function ProcessData(data)
{
	static var GravityPercentage=0.0;
		
	#ifdef __DEBUG_GUI
	outputln("++++++++++++++ DATA FROM GUI ++++++++++++++++++++");
	#endif

	// COMMAND TO CLOSE APPLICATION
	if(data[0] == "CloseApp") {
		application.quit();
		outputln("QUIT");
	}
	
// COMMAND TO LOAD THE PUZZLE
	if((session!="Clock")&&(data[0]=="PUZ"))
	{
		outputln(data[1]);
		if(data[1]=="Random")
		{
	 		puzzle=immagini[rand(len(immagini)-1)];	 		
	 		ReloadPuzzle();
		}
		else
		{
			puzzle=data[1];
			ReloadPuzzle();
		}

		temp_puzzle = puzzle;
	}	

	prev_session = session;
	switch(data[0])
	{
		case "Basket":		// SWITCH TO BASKET SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			on_session[1]=1;
			temp_puzzle = puzzle;
			puzzle="basket";
			ReloadPuzzle();
			stato=INTRO_;
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			InitPositions();			
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Puzzle":			// SWITCH TO PUZZLE SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			SetIniGrid();
			puzzle = temp_puzzle;	// LOAD THE PREVIOUS PUZZLE (BEFORE TO LOAD CLOCK OR BASKET)
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Clock":			// SWITCH TO CLOCK SESSION
			session = data[0];			
			NUM_CUBES=12;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9,10,11,12};
			total_time = 0.0;
			temp_puzzle = puzzle;
			puzzle = "clock";
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
	}
	
// ============== SELECT THE GRASPING THRESHOLD ==============
	if(data[0] == "GraspingValue")
	{
		ADC_TSHOLD = data[1];		
	}
// ===========================================================


// ============== SELECT THE DAMPING FACTOR ==============
	if(data[0] == "ViscosityValue") 
	{
		damper = data[1];	// DAMPING FACTOR
	}
// ===========================================================



// ============== RECEIVE SCORE DATA ==============
	if((data[0]=="SCORE")&&(!scoreloaded))
	{
		scores = data[1];
		scoreloaded = true;
	}
// ====================================================


// ============== PLOT DATA ==============
	if((data[0]=="PlotData")&&(stato==INTRO_))
	{
		plotdataon = !plotdataon;
	}
// ====================================================


// ============== COMMAND TO ENABLE FORCE ==============
	if(data[0] == "ForceOn")
	{
	    isForceEnabled=!isForceEnabled;
	}
	if(isForceEnabled)	ForceStatus=1;
	else				ForceStatus=0;
// ====================================================

// ============== COMMAND TO ENABLE CLOSE CONTROL FORCE OR FEEDFORWARD FRICTION MODEL ==============
	if(data[0] == "Compensation")
	{
		forcecontrol_flag = data[1];	
	}
// ====================================================


// ============== PATIENTS LIST FEEDBACK ==============
// Protocol: <"Patients",size,nome[0],nome[1],...,nome[size-1]>
//			 < data[0],data[1],data[2],....>
	if(data[0] == "Patients")
	{
		for (var j=0;j<data[1];j++)		aadd(lista_pazienti,data[j+2]);
	}
// ====================================================

// ========== SCALE & REPLACEMENT COMMANDS ============
// CHANGE ONLY IF FORCE IS DISABLED
	if(data[0] == "ScaleValue")
	{
			Scale = data[1];
		
	}
	if(data[0] == "HorizontalValue")
	{
			Hoff = data[1];    
	}
	if(data[0] == "VerticalValue")
	{
			Voff = data[1];    
	}
	if(data[0] == "DepthValue")
	{
			Doff = data[1];    
	}

// ====================================================

// ========== LOG COMMAND ============
	if (data[0]=="StartLog")
	{
		Device.Base.DLL.DEV_INTERFACE_Set_Command_Record(Device.Base.Command.SharedMemory_ID, COM_START);
	}
	if (data[0]=="StopLog")
	{
		Device.Base.DLL.DEV_INTERFACE_Set_Command_Record(Device.Base.Command.SharedMemory_ID, COM_STOP);
	}
	if (data[0]=="SaveLog")
	{
		Device.Base.DLL.DEV_INTERFACE_Set_Command_Record(Device.Base.Command.SharedMemory_ID, COM_SAVE);
	}

// ========== GRAVITY COMPENSATION COMMAND ============
	if(data[0] == "ChangeBodyMass") {
		BodyMass = data[1];
		if(BodyMass < 30.0)	BodyMass = 30.0;
		if(BodyMass > 120.0)	BodyMass = 120.0;
	}

	if(data[0] == "ChangeGravityCompensation") {
		GravityPercentage = 0.01*data[1];
		if(GravityPercentage < 0.0)
			GravityPercentage = 0.0;
	}

	if(data[0] == "GravCompOn") {
		GravityOn = 1.0;
	}
	if(data[0] == "GravCompOff") {
		GravityOn = 0.0;
	}

	GravityComp = GravityOn * GravityPercentage;
// ===============================================


  	if (data[0]=="PosInit")
  	{
  		activeInitPos =true;
  		Init_pos=true;  		
  	}


	if(data[0] == "EnableHelp")
	{
		h_required=true;		
	}
	
	if(data[0] == "DisableHelp")
	{
		h_required=false;		
	}
	

	#ifdef __DEBUG_GUI
	outputln("++++++++++++++ END GUI ++++++++++++++++++++");
	#endif
}

function disp(x,y,stri,row,col,fontsize,trasparency)
{
	var len_stri=len(stri)*tofloat(fontsize)/3400.0;
	var h = tofloat(fontsize)/600.0;
	var xs = x-len_stri/2;
	var ys = y-row*h;
	ConsoleFont("Impact",fontsize);
	ConsoleColor(1.0,1.0,1.0,0.7*trasparency);
	ConsoleFilledRect(xs-0.01, ys+h*5.0/6.0, len_stri+0.0, h);
	
	switch(upper(col))
	{
		case "K":	ConsoleColor(0.0,0.0,0.0,trasparency);break;
		case "R":	ConsoleColor(1.0,0.0,0.0,trasparency);break;
		case "B":	ConsoleColor(0.0,0.0,1.0,trasparency);break;
		case "G":	ConsoleColor(0.0,1.0,0.0,trasparency);break;
		default:	ConsoleColor(1.0,1.0,1.0,trasparency);break;
	}
	
	Consoletext(xs,ys,stri);
}

function plot(data,title)
{
	var t, w, h, h_1;
	var text;
	var x_0, y_0, x_1; 	// BAR DATA ORIGIN
	var alpha = 0.7;		// TRANSPARENCY
	var red = [1.0,0.0,0.0,alpha];
	var blue = [0.0,0.0,1.0,alpha];
	var green = [0.0,1.0,0.0,alpha];
	var black = [0.0,0.0,0.0,alpha];
	var gray = [0.5,0.5,0.5,alpha];
	var white = [1.0,1.0,1.0,alpha];
	var delta;	// SPACE AMONG BARS
	var wb;		// WIDTH AND HEIGHT OF EACH BAR
	var s;		// b+delta
	var max_label;
	var max_data=0;
	var xlabel="";
	var y_tick = {0.0};
	
	w = 0.6;
	x_0 = 0.6 - w/2;
	y_0 = 0.2;
	h = 0.6;
	h_1 = 0.8*h;
	t = 3;
	s = w / len(data);
	delta = 0.2*s;
	wb = s - delta;
	max_data=max(data);
	max_label=sprintf("%3.1f",h*max_data/h_1);

	// FILL PLOT
	ConsoleColor(white.r,white.g,white.b,1);
	ConsoleFilledRect(x_0,y_0,w,-h);
	ConsoleWidth(t);
	// DATA LABEL
	var tick = ceil(max_data / 4);

	if(tick>=100)
		tick=ceil(tick/100)*100;
	else
		if(tick>=10)
			tick=ceil(tick/10)*10;
		else
			tick=ceil(tick);

	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleFont("Arial",30);
	for(var i=0;i<6;i++)
	{
		Consoletext( x_0 - len(sprintf("%d",y_tick[i]))*0.025, y_0 +(h_1/max_data*y_tick[i])-0.015, sprintf("%d",y_tick[i]) );
		ConsoleLines( [x_0, y_0, x_0 - 0.01, y_0] );
		if(i>0)
		{
			ConsoleColor(gray.r,gray.g,gray.b,gray.a);
			ConsoleLines( [x_0, y_0 +(h_1/max_data*y_tick[i]), x_0 + w, y_0 +(h_1/max_data*y_tick[i])] );
			ConsoleColor(black.r,black.g,black.b,black.a);
		}
		aadd(y_tick, i*tick);
	}
	if((max_data - y_tick[5])>=tick)
	{
		Consoletext( x_0 - len(max_label)*0.02, y_0 + h - 0.015, max_label);
		ConsoleLines( [x_0, y_0 + (h-0.002), x_0 - 0.01, y_0 + (h-0.002)] );
	}	
	// PLOT DATA
	ConsoleColor(green.r,green.g,green.b,green.a);
	x_1 = x_0 + delta/2;
	for(var i=0;i<(len(data)-1);i++)
	{
		ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[i]) );
		if( ((wb<0.05)&&((i==0)||(i==4)||(i==9))) || (wb>=0.05) )
		{
			// X LABEL
			ConsoleFont("Arial",30);
			ConsoleColor(black.r,black.g,black.b,black.a);
			xlabel = sprintf("%d",i+1);
			Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);
		}
		ConsoleColor(green.r,green.g,green.b,green.a);
		x_1 = x_1 + wb + delta;
	}
	ConsoleColor(red.r,red.g,red.b,red.a);
	ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[len(data)-1]) );
	// X LABEL
	ConsoleFont("Arial",30);
	ConsoleColor(black.r,black.g,black.b,black.a);
	xlabel = sprintf("%d",len(data));
	Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);
	// BORDER PLOT
	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleRect(x_0,y_0,w,-h);
	// X LABEL
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0 + w/2 - 0.015*len("SESSIONI")/2, y_0 - 0.1, "SESSIONI");
	// Y LABEL
	var x_0label = 0.045;
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0  - (x_0label+0.008)*len("TEMPO"), y_0 + h/2, "TEMPO");
	Consoletext( x_0  - x_0label*len("TOTALE"), y_0 + h/2 - 0.05, "TOTALE");
	Consoletext( x_0  - (x_0label+0.015)*len("(s)"), y_0 + h/2 - 2*0.05, "(s)");
	// TITLE
	if(len(title)>0)
	{
		var fontsize=50;
		ConsoleFont("Arial",fontsize);
		ConsoleColor(red.r,red.g,red.b,1);
		Consoletext( x_0 + w/2 - 0.04*len(title)/2, y_0 + (h+0.05), title);
	}
}

function TaskBar()
{
	var grasp=0;
	var dark = [0.5,0.5,0.5];
	var light = [0.8,0.8,0.8];
	var plane = [0.7,0.7,0.7];
	var stri = "";
	var dim;
	var dot=0.0008;
	var x_s = 0;	// X separator
	var x_t = 0;	// X text
	var fonttype = "Impact";
	var fontsize = 25;
	var wt = fontsize*0.0005;	// Width of a char in normalized coordinates of consoletext
	var h = 0.05;
	// GRASPING
	var ref=2.5;
	var value=Fgrab;
	var maxF=6.0, max=0.1;
	var red=0.0, green=0.0;
	
	ConsoleColor(plane.r,plane.g,plane.b);
	ConsoleWidth(1);
	ConsoleFilledRect(0.0,1.0, 1.0,h);	
	// SHADOWED BORDER
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([0.0,1.0, 0.0,0.95, 1.0,0.95]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(2);
	ConsoleLines([0.0,1.0, 1.0,1.0, 1.0,0.95]);
	// PHASE NAME
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	if(paziente=="<Paziente>")
		stri = sprintf("Name:%s",session);
	else
		stri = sprintf("%s:%s",paziente,session);
	dim=len(stri)*wt;
	x_t = x_s + wt;
	x_s = x_t + dim + 0.01*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// FORCE FEEDBACK ENABLE
	ConsoleFont(fonttype,fontsize);	
	ModuleForce=0;
	stri = sprintf("%2.1fN",ModuleForce);//"FORCE";//(F7)";
	ConsoleColor(0.3,1.0,0.3,1.0);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);	
	// GRASPING FORCE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = "GRASP";
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.01*wt;
	Consoletext(x_t,0.965,stri);
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleFilledRect(x_s,1-10*dot,max,h-20*dot);
	if (ref>1)
	{
		if (value<ref)
		{
			red=1.0;
			green=0.0;
		}
		else
		{
			red=0.0;
			green=1.0;
		}
	}
	else
	{
		red=1.0;
		green=0.0;
	}
	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	ConsoleFilledRect(x_s, 1-10*dot, max/maxF*value, h-20*dot);
	if ((abs(ref)>=0.0)&&(abs(ref)<=maxF))
	{
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(2);
		ConsoleLines([x_s+max/maxF*ref, 1-h+10*dot, x_s+max/maxF*ref, 1-10*dot ]);
	}
	x_s = x_s + max + 0.01;
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// RADIUS
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
 	//stri = sprintf("Radius=%2.1fcm",(CIRCLE_RADIUS*CUBE_SIZE/3.0)*100*2);
 	if(temp_check_force)
 	 grasp = 1;
 	else
 	 grasp=0;
 	 stri = sprintf("Status %2d ",grasp);	
 	//stri = sprintf("Force=%2.1f %2.1f %2.1f",HFor[0],HFor[1],HFor[2]);		
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// BODY MASS - PERCENTAGE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("%1.0f%%OF%2.0fkg",GravityComp*100,BodyMass);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// DAMPER
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("VISC:%1.0fNs/m",damper);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
}

function modul(v)
{
	return sqrt(v[0]^2+v[1]^2+v[2]^2);
}

function max(a)
{
	var max=0.0;
	max = a[0];
	for(var i=1;i<len(a);i++)
	{
		if(a[i]>max)
		{
		max = a[i];
		}
	}
	return max;
}

function view_plot()
{
	if(!reqscore) //IF NOT ALREADY REQUESTED...
	{
		senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
		reqscore = true;		
	}

	if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
	{
		if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
		{
			plot(scores,"");
		}
		else
		{			
			disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
		}
	}
	else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
	{
		disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
	}
}

function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false;				
	static var PrecX = 0, PrecY = 0;			

	// Change these values to modify the mouse sensitivity
	var TR_SENSITIVITY  = 0.001;
	var ROT_SENSITIVITY = 0.01;

	if (Mouse.ButtonL && !Mouse.ButtonR)
	{
		/* left button: camera rotation */
		if (InMouseL)
		{			
			CameraRotate((Mouse.X - PrecX) * ROT_SENSITIVITY, 0, 1, 0);
			CameraRotateABS((Mouse.Y - PrecY) * ROT_SENSITIVITY, 1, 0, 0);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseL = true;
		InMouseR = false;
	}
	else if (Mouse.ButtonR)
	{
		/* right button: camera translation */
		if (InMouseR)
		{
			var CameraMatrix = CameraGetMatrix();
			var CameraPos = CameraGetPosition();
			if (!Mouse.ButtonL)
			{
				var z_trasl = CameraGetZAxis() * (Mouse.y - PrecY);
				var x_trasl = CameraGetXAxis() * (Mouse.X - PrecX);
				CameraPos += (TR_SENSITIVITY * (z_trasl + x_trasl));
			}
			else
			{
				var y_trasl = CameraGetYAxis() * (Mouse.y - PrecY); 
				CameraPos -= (TR_SENSITIVITY * y_trasl);
			}
			CameraSetPosition(CameraPos);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseR = true;
		InMouseL = false;
	}	
	else
	{
		InMouseR = false;
		InMouseL = false;
	}

}