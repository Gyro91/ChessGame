SET SCENE_FOV = 60;
SET SCENE_NEAR = 0.05;
SET SCENE_FAR = 1000;

#define _S3D_ALLOW_OBSOLETE_FUNCTIONS
//==============================================================================================================
// Includes
//==============================================================================================================
#define INCODE
#include <Script3d.h>
#include <GLConst.h>
#include <Impulse.h>
#include "manager.s3d"
#include "pyxvrlight.h.s3d"
#include "Classes.s3d"

#define ENABLE_STEREO   // OKKIO ... ATTIVO IN DEMOLEXOS

//#define __DEBUG
//#define __DEBUG2
//#define __DEBUG_GUI

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// NO XPC TARGET PRESENT (DEBUG)
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define NOTARGET	

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// VIEW FROM THE TOP TO THE FLOOR
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define TWOD
 
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// SHADOW DEFINITION: ONLY FOR 3-DIM VIEW
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define SHADOW
//#define TWO_LIGHT	//NOT WORK

#ifndef TWOD
	#define SHADOW
	//#define TWO_LIGHT	//NOT WORK
#endif


//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// GRASPING AND RELEASE MODALITY
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define HOLD_MOVE	// GRASP AND AUTOMATIC HOLD, OTHERWISE GRASP&HOLD


//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//	LOG DATA
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//#define LOG_DATA      // OKKIO ... ATTIVO IN DEMOLEXOS
#define LOG_STYLE "ASCII" //"MATLAB"
var file_ext="";



//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE DEFINITION
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//#define DEV_GRAB
//#define DEV_PHANTOM
//#define DEV_MOUSE
//#define DEV_VIRTUAL
//#define DEV_3DOFJOY
//#define DEV_NET
#define DEV_TRACKHOLD

#ifdef DEV_NET    // OKKIO ...   #ifndef DEV_MOUSE   IN DEMOLEXOS
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// FORCE SENSOR TO DETECT THE GRABBED OBJECT
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define HANDLE_FORCESENS    // OKKIO ... NON ATTIVO IN DEMOLEXOS
#endif

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// VIRTUAL CUBES ON GRID AT START
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//#define VIRTUAL_GRID

var AppCode = 1000;				// Identifier for this application: OPEN LOOP
var Mode = 0;					// Identifier for Control Modality: NOMODE
var checkApp = false;			// Flag to check the type of application
var ControlMode = "";
var EndInit = 0;				// End of Reset Encoders (=0 NOT FINISHED; =1 FINISHED)
var Command;

// SCORE VARIABLES
var date="";
var scores = 0;
var scoreloaded = false;
var reqscore = false;

#define NINE_CUBES

var song = {};
var immagini = {"haring","numbers","foca","spade","grape","italy","mini","roma01","parigi01","parigi02","parigi03","deserto","canyon","papaveri","londra01","londra02"};
#ifdef __DEBUG
	var index = 1;	// 0..6
#else
	var index = rand(len(immagini)-1);
#endif
var puzzle = immagini[index];	// CHANGEABLE VIA GUI BEFORE STARTING APPLICATION
var temp_puzzle = "";			// SAVE THE LAST PICTURE (PUZZLE OR BASKET) WHEN SWITCH WITH CLOCK
								// IT'S UPDATED CHOOSING A NEW PUZZLE BEFORE CALL PUZZLE OR BASKET
var session = "Puzzle";
var on_session = array(3);		// FLAG TO SHOW THE FIRST CALL OF EACH SESSION
								// 0:Puzzle, 1:Basket, 2:Clock
var prev_session = "-";

#ifdef HARING4
	#undef NINE_CUBES
	#define FOUR_CUBES
#endif

#ifdef NUMBERS4
 #undef NINE_CUBES
 #define FOUR_CUBES
#endif

#ifdef TWOD
	var POV = 2;	// PointOfView (=2 FOR TWO DIM VIEW; =3 FOR THREE DIM VIEW)
#else
	var POV = 3;	// PointOfView (=2 FOR TWO DIM VIEW; =3 FOR THREE DIM VIEW)
#endif

var v = vector(3);
var cubePos=[0.0, 0.0, 0.0];
var mod=0.0;


#define raggioAzione 0.23	// For CameraMoveGrab()

// KINEMATICS AND DYNAMICS PARAMETERS
#define cubeDensity 35 // higher value could lead to instability (maybe need the introduction of viscosity)
#define staticFriction 0.4
#define dynamicFriction 0.3


//Downloading "..\\DeviceXVR\\DevNet\\NetData.zip"
#ifdef DEV_NET
	#define DEV_XVR
	#include "..\DeviceXVR\DevBase.h"
#endif

#ifdef DEV_MOUSE
	#define DEV_XVR
	#include "..\DeviceXVR\DevBase.h"
#endif



#ifdef DEV_TRACKHOLD
 #define DEV_XVR
#endif

//#define TRACKHOLD20
//#define TH20_DISPLAY


#define ALEX10_INTERFACE
#define ALEX10_DISPLAY


#ifndef GEOM_S3D
#include "..\..\HI_xVR\Geom.s3d"
#endif

#define DEVICE_DATA_PATH					".\\..\\..\\HI_xVR"

#include "..\..\HI_xVR\Device_Interface.s3d"


#ifdef TRACKHOLD20							
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define TH20_PATH					".\\..\\..\\HI_xVR\\Trackhold20"
#include "..\..\HI_xVR\Trackhold20\Trackhold20.s3d"
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
#define TH20_PATH_DISPLAY 			"..\\..\\HI_xVR\\Trackhold20_Display"
#include "..\..\HI_xVR\Trackhold20_Display\TH20_Display.s3d"
var Display_Current_Device = TH20_DISPLAY_7DOF_V2;
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif


#ifdef ALEX10_INTERFACE							
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#define ALEX10_PATH					".\\..\\..\\HI_xVR\\ALEX10"
#include "..\..\HI_xVR\ALEX10\ALEX10.s3d"
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
#define ALEX10_PATH_DISPLAY 			"..\\..\\HI_xVR\\ALEX10_Display"
#include "..\..\HI_xVR\ALEX10_Display\ALEX10_Display.s3d"
var Display_Current_Device = ALEX10_DISPLAY_6DOF_V1;
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif




#ifndef DEV_TRACKHOLD
var Dev = Device();
#endif
var HPos = [0.0,0.0,0.0];
var HVel= [0.0,0.0,0.0];
var HFor = [0.0,0.0,0.0];
var HiPause = 0;
var HiJointPos = [0.0,0.0,0.0,0.0,0.0];
var HiVel= [0.0,0.0,0.0];
var Rrot = [1,0,0,0,0,1,0,-1,0];	// ROTATION ABOUT X OF -PI/2
var Rrot_t = [1,0,0,0,0,-1,0,1,0];	// ROTATION ABOUT X OF PI/2

var Unpause = 0;

var application = CVmWebBrowser();

var Resetta = 0;
var Stoppa = 0;
var Runna = 0;
var Spengi = 0;
var EmergencyStop=0;

//#define GRASP_THRESHOLD		2.5
var GRASP_THRESHOLD = 2.5;
var Fgrab = 0.0;		// FORCE TO EVALUATE THE GRAB

var pazienteSelected = false; 
var paziente="<Paziente>";
var task="C";		// P:Puzzle - B:Basket - C:Clock
var LogDataIterationCounter=0;
var lista_pazienti = {};

var Scale;			// EXOS POSITION AMPLIFIER
var Hoff,Voff,Doff;	// = PosOffset [CARTESIAN EXOS REFERENCE]
// ( HiPos - PosOffset)* Scale + PosZeroInVR
#ifdef DEV_TRACKHOLD
var Pos_Offset_Dev = [ 0,0,0 ];
var Pos_Offset_VR = [ 0,0,0 ];
var dev_pos = [0,0,0];
#endif


#ifdef LOG_DATA

	var BufferNum = 27;//Total Elements = BufferNum + 3
	var BufferSize;	// DEFINED IN THE ONINIT()
	var LogDataDecimation = 10;	// ==> T = about 500Hz
	var DLL_LogData;
	var DataToBeLogged = vector(BufferNum);
	var LogDataCounter = 0;
	var LogInitialized = false;
	var LogTime = 0.0;
	var StopLog = false;
	var LogStarted = false;
	var nomefile="null";
	
	function LogDataInit();
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif
	var StopLog = false;

// TEMPORARY SCORES (KT)
var timer = 0.0;
var total_time = 0.0;


var NUM_CUBES=12;
#define MAXSPEEDFORTHROW	0.006	// BASKET: SET THE PROXY SPEED TO LET THE CUBE THROW IN THE BASKET
#define SELECT_DISTANCE		0.015	//0.015

var IsPressed = false;  	//check pressed button
var sel_obj	= 0; 			//Index of selected object
var matched_cubes = {};
var free_cubes = {1,2,3,4,5,6,7,8,9};
var free_clock = {1,2,3,4,5,6,7,8,9,10,11,12};
var mat_obj = 0;
var floor_colgr = 20;			// Roof Collision group
var roof_colgr = 25;			// Roof Collision group
var underfloor_colgr = 30;		// Virtual Roof Collision group
var CIRCLE_RADIUS = 3;			// Circle Radius Factor

//variabili temporanee da precedente codice
var RelSpeed = [0,0,0];
var HB_ini = [0,0,0];
var HB_curr = [0,0,0];
var HB_old = [0,0,0];
var HB_speed = [0,0,0];


//forze verso l'haptic device
var Force = [0.0,0.0,0.0]; //visualized force
var ModuleForce = 0;
var NFor = [0.0,0.0,0.0];
var HiForces = [0.0,0.0,0.0];
var HiGrasp = [0.0,0.0];
var HiTau = [0.0,0.0,0.0,0.0];	// ARM MASS TORQUE COMPENSATION
var HiND = [0.0,0.0,0.0,0.0,0.0,0.0,0.0];		// NOT DEFINED VECTOR
var pos = vector(3);			//Position of the grabber
var time = vector(1);			//time since the grab started
var forzaDx = vector(3);		//force applied on the right grabber
var forzaSx = vector(3);		//force applied on the left grabber

var dSx = vector(3);  			//position and speed
var ddSx = vector(3);
	
var deltaSim = 1.0;				//delta time (ms)
var gestore;
var sfera1, sfera2;				//grabber cursors
var matRosso;					//cursors material
var maton;
var matoff;

var ForceStatus=0;


#define SCALEPOS 1


#ifdef  DEV_XVR
  
	var StiffSfera = 100;//250
	var h = 1.0;
	//valori stabili poco stiff
	// var StiffSfera = 100;
	//var h = 1.2;   
	   
	var hexos=h*0.1;
	var StiffSferaExos = StiffSfera;
	var ScalaStiffObjSel=1.0;
	 
	
	// valore di interazione stabile
	 //var StiffCubo = 100;
	 //var BiHB = 1.2;
	 //variabili di interazione con interfaccia aptica
	 #ifdef TWOD
	 	 var StiffCubo = 500;//150;//300;//50;    // OKKIO ... 150   IN DEMOLEXOS
	 #else
	 	 var StiffCubo = 150;
	 #endif
	 var BiHB = 15.0;//10.0;//1.5;
	 
#endif
 
var temp_dist=0.0;
var temp_pos=[0.0,0.0,0.0];
var temp_pos_sfera=[0.0,0.0,0.0];
var temp_isSelected=false;

var isSelected=false;


var scalaX = 3;



#define CUBE_SIZE	0.15
#define ROOM_SIZE	3.0

// IF 2-DIM VIEW
var CenterPuzzle = [0.0,0.0,0.0];//[0.0, 0.0, CUBE_SIZE*5/2 ];
var CenterBasket = CenterPuzzle;// - [-5*CUBE_SIZE,1.4*CUBE_SIZE,7.2*CUBE_SIZE];

#define BASKET_LIMITX	0.5
#define BASKET_LIMITZ	1

//camera
var Camera;	// Scene CVmCamera
var Camera2;// Light CVmCamera
var step = 0;
var RotX= 0, RotY=0; 
var CamDir      = [0,0,-1];				//camera direction
var CamPos      = [0.0, 0.7, 1.6];  	//camera position
#ifdef ENABLE_STEREO
var CamPos2D    = [0.0, 0.001, CenterPuzzle[2]+0];//[0.0, 2.1, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#else
var CamPos2D    = [0.0, 2.8, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#endif
var CamTarget   = [0.0, 0.45, 0.0];
var CamTarget2D = CenterPuzzle;


//Light
var Luce;
var Luce2;
#ifdef TWO_LIGHT
var PosL = [3.0, 5.0, 1.5];			//default light position
var PosL2 = [-3.0, 5.0, 1.5];			//default light position
#else
var PosL = [0.5, 5.0, -1.5];			//default light position
#endif
var lightProjectionMatrix;
var lightViewMatrix;
var grabOffSet = [0.0,0.0,0.0];


//Meshes and graphic objects
var m_stanza, o_stanza;
var m_basket, o_basket;
var m_cesto = array(4), o_cesto=array(4);

var m_cube = array(NUM_CUBES);		// MESH OF CUBES
var o_cube = array(NUM_CUBES);		// PHYSICS CUBES
var mv_cube = array(NUM_CUBES);		// MESH OF VIRTUAL CUBES
var v_cube = array(NUM_CUBES);		// VIRTUAL CUBES (ONLY FOR CLOCK SESSION)

var cube_position = array(NUM_CUBES);
var clock_position = array(NUM_CUBES);
var cube_grid = array(NUM_CUBES*2);
var TargetPos = [0.0,0.0,0.0];
var IniGrid = array(NUM_CUBES);

var stickyMaterial;		//Physic material for the cursors
var rigidMaterial;		//Physic material for the cubes and the floor

var gravity = [0.0,0.0,-9.8];	// NOT USED Defalut = [0.0,-9.8,0.0]

var shadowMapTexture;

var Map;


var isForceEnabled=false;
var ControlFlagOnF=false;


#define INTRO_ 	0
#define INTRO2_ 1
#define PUZZLE_ 2
#define CLOCK_	3
#define BASKET_	4
#define END_ 	5
#define END2_ 	6

var stato = INTRO_;

#define NUM_SOUNDS 	7

#define SFX_INTRO 	0
#define SFX_BUMP 	1
#define SFX_PICK 	2
#define SFX_CLAP	3 
#define SFX_FINISH 	4
#define SFX_CLACK	5
#define SFX_DROP	6
	
var SoundFX = array(NUM_SOUNDS);





//==============================================================================================================
//MS functions & variables which are used for communication with external GUI
//==============================================================================================================
function ReceiveData(UDP_Channel);
function SendData(data);
function ProcessData(data);
var gui;
var UDP_Channel;
var XVR_Port = 12345;
var GUI_Port = 12346;
var GUI_ScriptFile = void;//"GUI_Cubes.py";

#ifdef SHADOW

	var fbo;
	var shader;
	// additional OpenGL constants
	#define GL_DEPTH_COMPONENT16	0x81A5
	#define GL_DEPTH_COMPONENT24	0x81A6
	#define GL_DEPTH_COMPONENT32	0x81A7
	
	// additional XVR constants
	//#define VR_FBO_COLOR			0x0001
	//#define VR_FBO_DEPTH			0x0002
	//#define VR_FBO_SHADOW			0x0003

	var shader_name = "shadows_tex.sh";

	// a couple of handy application constants
	#define SCENE_CAMERA 0
	#define LIGHT_CAMERA 1
	#define LIGHT_CAMERA2 2

	var light,light2;
	//var light_pos = PosL;//[0, 0, 900];

#endif
/*
    * width,height: are the dimensions of the offscreen framebuffer (you may want to use square and power-of-2 framebuffers
      to circumvent once-common limitations in GPU adapters)
    * format: is an OpenGL format flag (such as GL_DEPTH_COMPONENT or GL_DEPTH_COMPONENT16) 
*/



/****************** SEND PROTOCOL VARIABLES *******************/
var Multifunction_Code = 1;
var GravityComp=0.0;	// Percentage of the patient's arm mass
var GravityOn = 0.0;
var BodyMass = 0.0;		// Patient Body Mass
var HiStatus;
var HiControlStatus = 0;

var weight = [1,1,1,1];	// PESI PER LA CINEMATICA INVERSA DEL REACHING
var kp = [0,0,0,0];
var damper = 0.0;	// VISCOSITY FACTOR (Ns/m) OF RESISTANCE FORCE
var handle_on = 1.0;

var forcecontrol_flag=1;
/**************************************************************/







//function to declare 
function attachCube(view);
function attachClock();
function Grabbed();
function CameraMoveGrab();
function CameraMoveMouse();
function MoveMouse();
function DrawGrid();
//function KeyboardManager();
function ManageTransition (i, Target_Pos);
function MoveCameraTo(x,y,z,startangle);
function MoveCameraTarget(x,y,z);
function CheckFinale();
function InitPositions();
function SetIniGrid();
function DrawPolygon(my_texture,fromx,fromy,fromz,tox,z);
function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y);
function initShadow();
function DrawShadow();
function drawShadowPrimoPasso();
function drawShadowFinalPass();
function prodottoMatrici4x4(a, b);
function DrawLine(pos1,pos2,r,g,b);
function bar(xmn,ymn,value,ref,max,unit,title,dim,mode);
function LoadBasket();
function LoadPuzzle();
function ReloadPuzzle();
function LoadCube();		//ONLY FOR CLOCK SESSION
function max(a);
function disp(x,y,stri,row,col,fontsize,transparency);
function ThrowBasket();
function TaskBar();
function modul(v);
function Rot_Y(a);
function Rot_Z(a);
function Load_Score();
function plot(data,title);
function HandleDataIn(separator);
function view_plot();
function ManageCollision();
function Align_Device(p);     // OKKIO ... NON PRESENTE IN DEMOLEXOS


// get commands from the web page.
function HandleDataIn(separator)
{
	var s = DataIn();
	var aa;
	trace(s);
	if(len(s) != 0)
	{
		if(separator!="")
			aa = split(s,separator);
		else
			aa = s;
		return aa;
	}
}





function Load_Score()
{
/*
	filescore = open("TotalScores.dat","a")
	filescore.write(paziente+","+date_score+","+task_score+","+data_store+"\n")
*/
	var filescore = LoadFile("TotalScores.dat");
	var score_data = {0.0};
	var j=0;
	var data;

	trace(filescore);
	if(filescore!=void)
	{
		foreach(var a in filescore)
		{
			trace(a);
			if(a!="")
			{
				var b=split(a,",");
				outputln(b[0],"==",paziente," - ",b[2],"==",session);
				data=val(b[3]);
				trace(data);
				if( (b[0]==paziente)&&(b[2]==session) )
				{
					aadd(score_data,data);
				}
				trace(score_data);
			}
		}
		adel(score_data,0);
	}
	trace(score_data);
	return score_data;

}






function SetIniGrid()
{
	var i, ii;
	var Grid = array(NUM_CUBES);
	var seed;
	/* inizializza la griglia */
	for(i=0;i<NUM_CUBES;i++)
		Grid[i] = i;
	
	/* diamo le carte */
	for (i=0;i<NUM_CUBES;i++)
	{
		seed = NUM_CUBES - i - 1;
		if (seed == 0)
			ii = 0;
		else
			ii= rand(seed);
	   	IniGrid[i] = Grid[ii];
	   	Grid[ii] = Grid[seed];
	}
}




function LoadBasket()
{

	var meshtoload = "Objects\\cesto.aam";
	m_basket = CVmNewMesh(meshtoload);
	m_basket.Normalize(3*CUBE_SIZE);
	m_basket.CenterBoundingBox();
	o_basket=CVmObj();
	o_basket.LinkToMesh(m_basket);
	o_basket.setposition(CenterBasket);


//---------------------------------------------------------
/*!
function CVmPhObj::NewPMesh(shape, pos, rot, collisionGroup, density, draw, phMat, a, b, c, d)

Adds a physical shape to the object
\param	-shape	int	specifies the shape
			-	PHX_BOX
			-	PHX_SPHERE
			-	PHX_CYLINDER
			-	PHX_CONE
			-	PHX_CONEFRUSTUM
			-	PHX_PYRAMID
\param	pos	vector[3]	position of the shape relative to the center of the object
\param	rot	vector[3]	rotation relative to the object frame
\param	collisionGroup	int	shape collision group
\param	density	float	shape density
\param	draw	bool	if true the current graphical mesh is replaced with the new shape, do nothing if false
\param	mat	int	physics material handler
\param	a, b, c, d	shape parameters, see the reference
*/
}



// obj.type = 0 (Dynamic), 2 (Kinematic)

function ReloadPuzzle()
{
	var meshtoload="";
	var i;
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
	if(session=="Clock")
	{

		if(on_session[2]==0)	// IF THE FIRST CALL OF CLOCK
		{
			// LOAD THE OBJECT CUBE TIL 12th FOR THE CLOCK SESSION 
			for (var j=9;j<NUM_CUBES;j++)
			{
				o_cube[j] = gestore.AddPhObj([0.0,0.0,0.0], [0.0,0.0,0.0], PHX_DYNAMIC);
				o_cube[j].AddBoxShape([CUBE_SIZE, CUBE_SIZE, CUBE_SIZE], [0.0,0.0,0.0], [0.0,0.0,0.0], cubeDensity, rigidMaterial);
				o_cube[j].assignCollisionGroup(j+1);
				PhysXVR.SetBarycenterREL(o_cube[j].GetActor(), [0.0, -CUBE_SIZE/4, 0.0]);
				// INCREASING INERTIA TO AVOID ROTATION
				PhysXVR.setInertiaTensor(o_cube[j].GetActor(), [10000, 10000, 10000]);
				//PhysXVR.SetCollision(sfera1.getActor(), o_cube[j].getActor()); //PIPPO
			}

			on_session[2]=1;
		}
		
		for (var j=0;j<NUM_CUBES;j++)
		{
			meshtoload = sprintf("a_%d.aam",j+1);
			m_cube[j] = CVmNewMesh(meshtoload);
			m_cube[j].Normalize(CUBE_SIZE);
			mv_cube[j] = CVmNewMesh(meshtoload);
			mv_cube[j].Normalize(CUBE_SIZE);
			v_cube[j]=CvmObj();	
			v_cube[j].LinkToMesh(mv_cube[j]);
			v_cube[j].ModulateMaterials(1,1,1,0.5);
			o_cube[j].LinkToMesh(m_cube[j]);	// LINK THE FIRST 9 CUBES
			if(o_cube[j].type!=PHX_DYNAMIC)
				o_cube[j].makeDynamic();
			o_cube[j].setvisible(true);
			o_cube[j].setgravity(true);
			// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				o_cube[j].setvisible(false);
			}
		}

		PhysXVR.enableCollision(0,1);	// ENABLE COLLISION BETWEEN FIRST CUBE AND PROXY
		for(var k=1; k<=NUM_CUBES; k++)
			PhysXVR.disableCollision(0,k+1);

		for(var k=1; k<=NUM_CUBES; k++)
			PhysXVR.enableCollision(floor_colgr,k);//roof_colgr,mat_obj);
		for(var k=1; k<=NUM_CUBES; k++)
			PhysXVR.disableCollision(1,k+1);
			
	}
	else	// BASKET OR PUZZLE
	{
	
		for (var j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
			meshtoload = sprintf("a_%d.aam",i+1);
			m_cube[i] = CVmNewMesh(meshtoload);
			m_cube[i].Normalize(CUBE_SIZE);	
			if(o_cube[i].type!=PHX_DYNAMIC)
				o_cube[i].makeDynamic();
			o_cube[i].setgravity(true);
			o_cube[i].LinkToMesh(m_cube[i]);
			o_cube[i].setvisible(true);
		}

		for(var k=1; k<=NUM_CUBES; k++)
			PhysXVR.enableCollision(floor_colgr,k);//roof_colgr,mat_obj);

		// HIDE THE THREE CUBES CREATED IN A PREVIOUS CLOCK TASK
		if(on_session[2]==1)
		{
			for (var j=NUM_CUBES;j<NUM_CUBES+3;j++)
			{
				o_cube[j].setvisible(false);//false
				// PIPPO
				PhysXVR.disableCollision(0,j+1); // disable proxy collision
				for(var k=1; k<=NUM_CUBES; k++)
					PhysXVR.disableCollision(j+1,k);

			}
		}

		Map = CVmTexture(sprintf("Sinopia.jpg"));
	}
}





function LoadCube()
{
		var j=0;
		if(len(free_cubes)!=0)
		{
			#ifdef __DEBUG
			outputln("FreeCubes[",j,"] = ",free_cubes[j]);
			#endif
			// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
			cube_position[free_cubes[j]-1] = [ 0.0, CUBE_SIZE/2, 0.0 ] + CenterPuzzle;
			// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			o_cube[free_cubes[j]-1].setvisible(true);
			o_cube[free_cubes[j]-1].setgravity(true);
			PhysXVR.enableCollision(0,free_cubes[j]);
			o_cube[free_cubes[j]-1].SetPosition(cube_position[ free_cubes[j]-1 ]);
			o_cube[free_cubes[j]-1].SetRotation(-90,[1.0,0.0,0.0]);
		}
}





function LoadPuzzle()
{
	var meshtoload="";
	var i;
	SetIniGrid();
	// Set Local Directory to .\Cubes to avoid problem in loading the *.aam and relative textures
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));

	for (var j=0;j<NUM_CUBES;j++)
	{
		i = IniGrid[j];
		meshtoload = sprintf("a_%d.aam",i+1);
		m_cube[i] = CVmNewMesh(meshtoload);
		//m_cube[i].ChangeTextureParams(1, VR_w_ANGLE,90 );
		m_cube[i].Normalize(CUBE_SIZE);
		o_cube[i] = gestore.AddPhObj([0.0,0.0,0.0], [0.0,0.0,0.0], PHX_DYNAMIC);
		o_cube[i].AddBoxShape([CUBE_SIZE, CUBE_SIZE, CUBE_SIZE], [0.0,0.0,0.0], [0.0,0.0,0.0], cubeDensity, rigidMaterial);
		o_cube[i].LinkToMesh(m_cube[i]);
		o_cube[i].assignCollisionGroup(i+1);	// CUBE COLLISION GROUP 1..10
		
		PhysXVR.SetBarycenterREL(o_cube[i].GetActor(), [0.0, -CUBE_SIZE/4, 0.0]);
		
		// INCREASING INERTIA TO AVOID ROTATION
		PhysXVR.setInertiaTensor(o_cube[i].GetActor(), [10000, 10000, 10000]);
		
		PhysXVR.SetCollision(sfera1.getActor(), o_cube[i].getActor());
	}
	
	InitPositions();

	ConsoleFont("Arial", 24);
	ConsoleColor( 0.364, 0.294 , 0.278, 1.0 );
	Map = CVmTexture(sprintf("Sinopia.jpg"));








	
	SetLocalDir();	// Set Local Directory to the actual one

}





function OnDownload()
{
	

	
	
	FileDownload(DEVICE_DATA_PATH + "\\Device_Data.zip");

#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnDownload(TH20_PATH);
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	TH20_Display_OnDownload(TH20_PATH_DISPLAY);
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif


#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnDownload(ALEX10_PATH);
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	ALEX10_Display_OnDownload(ALEX10_PATH_DISPLAY);
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif
	


	
		FileDownLoad("lib.zip");	//	load ("NxCooking.dll","PhysXLoader.dll","physXVR.dll","physXVRDebug.dll")
		FileDownload("suoni.zip");
		FileDownload("Objects.zip");
		FileDownload("stanza.zip");

	#ifndef DEV_TRACKHOLD
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Dev.Download();
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	#endif

	#ifdef LOG_DATA
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		//FileDownload("LogData2.dll");
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	#endif
	

	#ifdef SHADOW
		FileDownload(shader_name);
	#endif	
	
}





function onEvent(){
}



function OnError(){
}






var matred, M_light, O_light;

function OnInit(params)
{

	



	#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20.LibParam.Device.Arm_Config = TH20_CONFIG_RIGHT_ARM;
	
	TH20.LibParam.Filter.SW_Enable = 1;
	TH20.LibParam.Filter.SW_Frequency = 10.0;
	TH20.LibParam.Filter.HW_Enable = 1;
	TH20.LibParam.Filter.HW_Level = 7;
	
	TH20.LibParam.Record.FileName = TH20_DEVICE_LABEL + "_Data.txt";
	TH20.LibParam.Record.Decimate = 1;
		
	TH20.LibParam.WDog.Enable = 1;
	TH20.LibParam.WDog.TimeOut = 1.0;
	TH20.LibParam.WDog.MinFrequency = 5.0;
	
	TH20.Param.DeviceLabel = TH20_DEVICE_LABEL;
	TH20.Param.BaseMatrix = [ 0.0, 0.0, -1.0, 0.0,     -1.0, 0.0, 0.0, 0.0,    0.0, 1.0, 0.0, 0.0,   0.0, 0.525, 0.525+0.161+0.0632, 1.0 ];
	TH20.Param.EE_Link = TH20_NUM_OF_DOF;
	TH20.Param.EE_Matrix = [ 0.0, -1.0, 0.0, 0.0,     0.0, 0.0, 1.0, 0.0,    -1.0, 0.0, 0.0, 0.0,   0.0, 0.0, 0.0, 1.0 ];
	TH20.Param.Scale = 1.0;
	TH20.Param.HandClosed_Threshold = 1.0;
	TH20.Param.HandClosed_Signal = 12;
	
	TH20.Param.EnableTextOutput.Status = false;
	
	TH20.Param.EnableTextOutput.Key = "t";
	TH20.Param.ChangeArmConfig.Key = "c";
	TH20.Param.UpdateConfig.Key = "u";
	TH20.Param.RecordStart.Key = "r";
	TH20.Param.RecordStop.Key = "y";
	TH20.Param.RecordSave.Key = "s";
	TH20.Param.RecordClear.Key = "q";
	
	TH20.Param.UpdateParam_Decimation = 100;
	
	TH20.Status.IsStarted = false;
	TH20.Status.Hand_IsClosed = false;
	TH20.Status.Time = GetTime();
		
	TH20_OnInit();

	TH20_GetConfig();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Wd = World_descr(1);
	
	Wd.Sys[0] = System_descr(TH20_DISPLAY_NUM_OF_DEVICE_TYPE, [ 1 , 1 , 1 ], true);		// VENGONO CREATI DUE DEVICE
	
	for (var C=0; C<TH20_DISPLAY_NUM_OF_DEVICE_TYPE; C++)
	{
		Wd.Sys[0].Dev[C] = TH20_Display_Description(C, TH20.Param.Scale);
		
		Wd.Sys[0].Dev[C].Show_Double.Key = "d";
		Wd.Sys[0].Dev[C].Show_Mesh.Key = "m";
		Wd.Sys[0].Dev[C].Show_Struct.Key = "w";
		Wd.Sys[0].Dev[C].Show_Link_Frame.Key = "l";
		Wd.Sys[0].Dev[C].Show_Main_Frame.Key = "f";
		
		Wd.Sys[0].Dev[C].Show_Double.Status = false;
		Wd.Sys[0].Dev[C].Show_Mesh.Status = false;
		Wd.Sys[0].Dev[C].Show_Struct.Status = false;
		Wd.Sys[0].Dev[C].Show_Link_Frame.Status = false;
		Wd.Sys[0].Dev[C].Show_Main_Frame.Status = false;
		
		Wd.Sys[0].Dev[C].Link[0].Show = true;
		Wd.Sys[0].Dev[C].Link[1].Show = true;
		Wd.Sys[0].Dev[C].Link[2].Show = true;
		Wd.Sys[0].Dev[C].Link[3].Show = true;
		Wd.Sys[0].Dev[C].Link[4].Show = true;
		Wd.Sys[0].Dev[C].Link[5].Show = true;
		Wd.Sys[0].Dev[C].Link[6].Show = true;
		Wd.Sys[0].Dev[C].Link[7].Show = true;
	}
	Wd.Sys[0].Dev[TH20_DISPLAY_6DOF_V1].Link[7].Show = false;
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif





#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// ALEX10 INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.Base.Driver_Param.Record.FileName = ALEX10_DEVICE_LABEL + "_Data.txt";
	ALEX10.Base.Driver_Param.Record.Decimate = 1;

	ALEX10.Base.Driver_Param.Play.FileName = ALEX10_DEVICE_LABEL + "_Data.txt";
	ALEX10.Base.Driver_Param.Play.TimeScale = 1.0;
	ALEX10.Base.Driver_Param.Play.TimeOffset = 0.0;

	ALEX10.Base.Driver_Param.WDog.Enable = 1;
	ALEX10.Base.Driver_Param.WDog.TimeOut = 1.0;
	ALEX10.Base.Driver_Param.WDog.MinFrequency = 5.0;

	ALEX10.Base.xVR_Param.DeviceLabel = ALEX10_DEVICE_LABEL;
	ALEX10.Base.xVR_Param.BaseMatrix = [ 1.0, 0.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,    0.0, 0.0, 1.0, 0.0,   0.0, 0.0, 0.3, 1.0 ];
	ALEX10.Base.xVR_Param.EE_Link = ALEX10_NUM_OF_DOF;
	ALEX10.Base.xVR_Param.EE_Matrix = [ 0.0, -1.0, 0.0, 0.0,     0.0, 0.0, 1.0, 0.0,    -1.0, 0.0, 0.0, 0.0,   0.0, 0.0, 0.0, 1.0 ];
	ALEX10.Base.xVR_Param.Scale = 1.0;

	ALEX10.Base.xVR_Param.Key_EnableTextOutput.Key = "t";
	ALEX10.Base.xVR_Param.Key_DataOut.Key = "o";
	ALEX10.Base.xVR_Param.Key_Record.Key = "r";
	ALEX10.Base.xVR_Param.Key_Play.Key = "p";
	ALEX10.Base.xVR_Param.Key_Config.Key = "c";

	ALEX10.Base.xVR_Param.Key_ComStart.Key = "z";
	ALEX10.Base.xVR_Param.Key_ComStop.Key = "x";
	ALEX10.Base.xVR_Param.Key_ComSave.Key = "s";
	ALEX10.Base.xVR_Param.Key_ComClear.Key = "v";
	ALEX10.Base.xVR_Param.Key_ComPause.Key = "k";
	ALEX10.Base.xVR_Param.Key_ComLoadRecord.Key = "l";
	ALEX10.Base.xVR_Param.Key_ComLoadFile.Key = "m";
	ALEX10.Base.xVR_Param.Key_ComUpDate.Key = "n";
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.Driver_Param.Device.Arm_Config = ALEX10_CONFIG_RIGHT_ARM;
	

	ALEX10.xVR_Param.HandClosed_Threshold = 1.0;
	ALEX10.xVR_Param.HandClosed_Signal = 12;
	ALEX10.xVR_Param.Key_ChangeArmConfig.Key = "c";
	ALEX10.xVR_Param.UpdateParam_Decimation = 100;
	
	ALEX10.xVR_Status.Hand_IsClosed = false;
		
	ALEX10.OnInit();

	ALEX10.GetConfig();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	Wd = World_descr(1);
	
	Wd.Sys[0] = System_descr(ALEX10_DISPLAY_NUM_OF_DEVICE_TYPE, [ 1 , 1 , 1 ], true);		// VENGONO CREATI DUE DEVICE
	
	for (var C=0; C<ALEX10_DISPLAY_NUM_OF_DEVICE_TYPE; C++)
	{
		Wd.Sys[0].Dev[C] = ALEX10_Display_Description(C, ALEX10.Base.xVR_Param.Scale);
		
		Wd.Sys[0].Dev[C].Show_Double.Key = "d";
		Wd.Sys[0].Dev[C].Show_Mesh.Key = "m";
		Wd.Sys[0].Dev[C].Show_Struct.Key = "w";
		Wd.Sys[0].Dev[C].Show_Link_Frame.Key = "l";
		Wd.Sys[0].Dev[C].Show_Main_Frame.Key = "f";
		
		Wd.Sys[0].Dev[C].Show_Double.Status = false;
		Wd.Sys[0].Dev[C].Show_Mesh.Status = true;
		Wd.Sys[0].Dev[C].Show_Struct.Status = false;
		Wd.Sys[0].Dev[C].Show_Link_Frame.Status = false;
		Wd.Sys[0].Dev[C].Show_Main_Frame.Status = false;
		
		Wd.Sys[0].Dev[C].Link[0].Show = true;
		Wd.Sys[0].Dev[C].Link[1].Show = true;
		Wd.Sys[0].Dev[C].Link[2].Show = true;
		Wd.Sys[0].Dev[C].Link[3].Show = true;
		Wd.Sys[0].Dev[C].Link[4].Show = true;
		Wd.Sys[0].Dev[C].Link[5].Show = true;
		Wd.Sys[0].Dev[C].Link[6].Show = true;
	}
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	
#endif











	#ifdef ENABLE_STEREO
	SceneSetParam(VR_HEADTRACKER,1);
	SceneSetParam(VR_EYE_SEPARATION,0.065);	
	SceneSetParam(VR_TRACKER_POSITION, 0, 0.0, 1.0);	
	#endif

	GlEnable(GL_NORMALIZE);
	//ResetScore();
	
	// GET DATE
	var display = HandleDataIn("");
	sscanf(display,"%s",&date);
	trace(date);
	
	date = "1-1-2000";    // OKKIO ... NON PRESENTE IN DEMOLEXOS
	if(session!="Clock")	NUM_CUBES = 9;
	on_session[0] = 1;
	on_session[1] = 0;
	on_session[2] = 0;
	
	//================================
	// Graphic Setup
	//================================ 
	//Camera
	if(pov==2)
	{
		CameraSetPosition(CamPos);
	}
	else
	{
		CameraSetPosition(CamPos);
		CameraSetTarget(CamTarget);
	}
	
	#ifndef SHADOW
	
		Luce = CVmLight();
		Luce.SetDiffuse(1,1,1);
		Luce.SetSpecular(1,1,1);
		Luce.Enable();	
		Luce.SetPosition(PosL);
		
	#else
	// SHADOW ON
		
		light = CVmLight();
		light.SetDiffuse(1,1,1);
		light.Enable();	
		light.SetPosition(PosL);
	
		#ifdef TWO_LIGHT
			light2 = CVmLight();
			light2.SetDiffuse(1,1,1);
			light2.Enable();	
			light2.SetPosition(PosL2);
		#endif
		/*
		 * Here, the Framebuffer Object (CVmFbo) is initialized
		 * 
		 * Parameters are:
		 * - type of FBO (VR_FBO_SHADOW, VR_FBO_DEPTH, VR_FBO_COLOR)
		 *     VR_FBO_COLOR is a color framebuffer
		 *     VR_FBO_DEPTH is a depth buffer
		 *     VR_FBO_SHADOW is a depth buffer with automatic depth comparison
		 *         (see Sampler2DShadow in GLSL)
		 * - width and height in pixels of FBO (if you have trouble with this,
		 *     try using square, power-of-2 dimensions)
		 * - format of framebuffer (use GL constants as GL_RGBA, GL_DEPTH_COMPONENT, etc.)
		 */
//		fbo = CVmFbo(VR_FBO_SHADOW, 800*3, 800*3, GL_DEPTH_COMPONENT32);//2048, 2048, GL_DEPTH_COMPONENT32);
		fbo = CVmFbo(VR_FBO_SHADOW, 2048*2, 2048*2, GL_DEPTH_COMPONENT32);
		
		/*
		 * You can retrieve the CVmTexture object associated to the frame buffer,
		 * but this in general is not necessary since you can pass the framebuffer object
		 * itself to SetActiveTexture()
		 */
		// var tex = fbo.GetTexture();
		
		/*
		 * In case you are using color framebuffer objects, you may want to enable
		 * automatic mipmap generation, which is useful if you use the resulting image
		 * as a texture.
		 * Please beware that automatic mipmap generation could affect the overall performance
		 * of your application.
		 */
		// fbo.EnableMipmaps();
		
		shader = CVmShaderProgram(shader_name);

	 #endif

	var i,j;
	
    forzaSx = [0.0, 0.0, 0.0];
	

	for (j = 0; j < NUM_SOUNDS; j++)
		SoundFX[j] = CVmVRAWav();

	//	loadLib();
	gestore = CVmPhManager();	//used for manage the physic scene


	//SoundFX[SFX_INTRO].Load("bump.wav");
	SoundFX[SFX_BUMP].Load("bump.wav");
	SoundFX[SFX_PICK].Load("tac.wav");
	SoundFX[SFX_CLAP].Load("clap.wav");
	SoundFX[SFX_FINISH].Load("fanfar1.wav");
	SoundFX[SFX_CLACK].Load("Clack.wav");
	SoundFX[SFX_DROP].Load("buttondrop.wav");


	//Graphic material for grab cursor
	matRosso = CVmMaterial();
	matRosso.diffuse = matRosso.ambient = [1,0,0,1];
	matRosso.specular = [0,0,0,1];
	matoff = CVmMaterial();	//GREY
	matoff.ambient   = 10*[0.1, 0.1, 0.1, 1.0];
	matoff.diffuse   = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.specular  = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.shininess = 1;
	maton = CVmMaterial();	//GREEN
	maton.ambient   = 10*[0.0, 0.2, 0.0, 1.0];
	maton.diffuse   = [0.0, 1.0, 0.0, 1.0];
	maton.specular  = 10*[0.1, 0.1, 0.1, 1.0];
	maton.shininess = 10;
	
	//Physic materal for grab cursor
	stickyMaterial =  PhysXVR.NewMaterial(0.5, staticFriction, dynamicFriction);
	rigidMaterial = PhysXVR.NewMaterial(0.5, 1, 0.6);
	/*!
	 *	function CVmPhManager::PhMaterial(bouncyness, staticFriction, dynamicFriction){
	 * Creates a new physic material
	 * \param	bountyness		float	elasticity of the object
	 * \param	staticFriction	float	static friction
	 * \param	dynamicFriction	float	dynamic friction
	 * \return material handler
	 */

	//Init grab variable
	//posizione del primo e del secondo grab
	pos = [0.2, 0.0, 0.0, -0.2, 0.0, 0.0];

	forzaDx = [0.0,0.0,0.0];
	forzaSx = [0.0,0.0,0.0];


	#ifdef DEV_MOUSE
		
		Dev.PosScale = 1.0;
		Dev.PosOffset = [0.0 , 0.0 , 0.0];
		Dev.PosZeroInVR = [0.0, 0.0, 0.0];
		Dev.ForceScale = 1.0;
		//replica l
		pos=Dev.GetPosition();
		
	#endif


	#ifdef DEV_NET
			if(pov==2)
			{
				Scale = 3.0;
				Dev.PosScale = Scale;	//UPDATED FROM GUI
				Hoff = 0.0;
				Voff = 0.0;//0.35;
				Doff = -0.2;
				Dev.PosOffset =  [0.0, 0.0, 0.0]; //[Horizontal,Vertical,Depth]
				Dev.PosZeroInVR = [ Hoff, Voff, Doff ];
				//HomeExos=[-0.14   -0.4    0.4 ] => PosOffset=[-0.1, 0.35, -0.4]
				//HomeExos=[-0.25   -0.25   0.45] => PosOffset=[-0.2, 0.4, -0.2]
				
			}
			if(pov==3)
			{
				Dev.PosScale = 3.0;
//				Dev.PosOffset = [0.0, 0.15, 0.1];
//				Dev.PosZeroInVR = [0.0, 0.0, 0.0];
				Hoff = 0.0;
				Voff = 0.0;//0.35;
				Doff = -0.2;
				Dev.PosOffset =  [0.0, 0.0, 0.0]; //[Horizontal,Vertical,Depth]
				Dev.PosZeroInVR = [ Hoff, Voff, Doff ];
			}
			Dev.ForceScale = 1.0;
			HiForces = [0.0, 0.0, 0.0];
			
			DevNet_SendIpAddress = sprintf("192.168.80.72");// IP CISANELLO = 192.168.80.5
			DevNet_SendPort = 25001;
			DevNet_SendSize = 24;// 20;//18;//12;
/*********************************************
				SEND PROTOCOL
Fx,Fy,Fz,[ Multifunction_Code , Resetta , Runna , Stoppa , Spengi, GravityComp, EmergencyStop, Unpause, AppCode, weight[0], weight[1], weight[2],weight[3], kp[0], kp[1], kp[2], kp[3], BodyMass, damper, handleon, forcecontrol_flag ]

	Multifunction_Code		...
	Resetta					Reset the encoders
	Runna					Run the device
	Stoppa					Stop the device
	Spengi					Turn off the device
	GravityComp				Define the gravity contribution to sustain the arm (only for exos)
	EmergencyStop			Stop the executing task
	Unpause					Esc to the PAUSE state during the task
	AppCode					Code to identify the application
	w[1..4]					Constraint Joints Weights
	k[1..4]					Control Gains
	BodyMass				Mass of Patient's Body
	damper					Viscosity factor (resistance force)
	handle_on				Enable the mass compensation of the sensorized handle
	forcecontrol_flag		flag to select the type of force compensation

*********************************************/

			DevNet_RecPort = 26001;
			DevNet_RecSize = 29;//26;//18;//16;
/*********************************************
				RECEIVE PROTOCOL
X,Y,Z,Vx,Vy,Vz,Q1,Q2,Q3,Q4,Q5,AppCode,Ftx,Fty,Ftz,GraspLx,GraspRx,Pause,Tau1,Tau2,Tau3,Tau4,FtM,FnM,Kp,Qd1,Qd2,Qd3,Qd4
X,Y,Z,Vx,Vy,Vz,Q1,Q2,Q3,Q4,Q5,AppCode,Fx,Fy,Fz,GraspLx,GraspRx,Pause,Tau1,Tau2,Tau3,Tau4,0,0,0,0,0,0,0
*********************************************/
	#endif


	#ifndef DEV_TRACKHOLD
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Dev.Init();
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	#endif
	setTimeStep(deltaSim);
	//setFrameRate(30);

	//Load and resize the meshs for the room
	m_stanza = CVmNewMesh("stanza.aam");
	m_stanza.Normalize(ROOM_SIZE);	
	o_stanza = CVmObj(m_stanza);
	o_stanza.Translate(0.0, CUBE_SIZE/2, 0.0);
	
	//Create a plane for the floor
	gestore.AddPhObj(CUBE_SIZE/2, [0.0,1.0,0.0], PHX_FIXED, rigidMaterial, PHX_PLANE,floor_colgr);	// Collision group=20
	//Create a plane for the roof
	//gestore.AddPhObj( -3*CUBE_SIZE, [0.0,1.0,0.0], PHX_FIXED, rigidMaterial, PHX_PLANE,underfloor_colgr);	// Collision group=25
	//Create planes for the walls
	/*
	gestore.AddPhObj(30*CUBE_SIZE, [-1.0,0.0,0.0], PHX_FIXED, rigidMaterial, PHX_PLANE,51);
	gestore.AddPhObj(30*CUBE_SIZE, [1.0,0.0,0.0], PHX_FIXED, rigidMaterial, PHX_PLANE,52);
	gestore.AddPhObj(30*CUBE_SIZE, [0.0,0.0,-1.0], PHX_FIXED, rigidMaterial, PHX_PLANE,53);
	gestore.AddPhObj(30*CUBE_SIZE, [0.0,0.0,1.0], PHX_FIXED, rigidMaterial, PHX_PLANE,54);
	*/
	//Create a plane for the roof
	//gestore.AddPhObj( - 2.28 - CUBE_SIZE/2, [0.0,-1.0,0.0], PHX_FIXED, rigidMaterial, PHX_PLANE,roof_colgr);	// Collision group=25
	
		
	//Exos cursor
	#ifdef DEV_NET
	var sphere1_radius = 0.015;
	var sphere1_dens = 2000;
	#else
	var sphere1_radius = 0.015;
	var sphere1_dens = 100;
	#endif
	sfera1 = gestore.AddPhObj([pos[0]+camTarget[0], pos[1]+camTarget[1], pos[2]+camTarget[2]], [0.0,0.0,0.0], PHX_DYNAMIC, matRosso);
	sfera1.NewPMesh(PHX_SPHERE, [0.0,0.0,0.0], [0.0,0.0,0.0], 0,sphere1_dens , true, stickyMaterial, 12, sphere1_radius);
	sfera1.SetGravity(false);	//Set the gravity of the cursor to zero 



/*
	o_cesto[0] = gestore.AddPhObj(centerpuzzle, [0.0,0.0,0.0], PHX_DYNAMIC, matoff);
	//o_cesto[0].NewPMesh(PHX_BOX, [0.0,0.0,0.0], [0.0,0.0,0.0], 60, 2000, true, stickyMaterial, 20, 1, 5);
	var mesh = CVmNewMesh(VRP_BOX, 0, [0,0,0], 0.5 ,0,CUBE_SIZE); //a=dim
	mesh.CenterBoundingBox();
	o_cesto[0].LinkToMesh(mesh);
	o_cesto[0].AddBoxShape([CUBE_SIZE,CUBE_SIZE,CUBE_SIZE],centerpuzzle, [0.0,0.0,0.0], 2000, stickyMaterial);
*/


/*!
function CVmPhObj::AddBoxShape(dim, pos, rot, density, phMat, collisionGroup){

Adds a physical box to the object, this object will not be drawn
\param	dim	vector[3]	dimention
\param	pos	vector[3]	position relative to the center of the object
\param	rot	vector[3]	rotation relative to the object frame
\param	density	float	shape density
\param	phMat	int	physics material handler
\param	collisionGroup	int mesh collision group
*/
/*!
		function CVmPhManager::AddPhObj(pos, rot, type, mat, shape, cg, density, phMat, a, b, c, d)

		function CVmPhObj::NewPMesh(shape, pos, rot, collisionGroup, density, draw, phMat, a, b, c, d){
		Adds a physical shape to the object
		\param	-shape	int	specifies the shape
					-	PHX_BOX
					-	PHX_SPHERE
					-	PHX_CYLINDER
					-	PHX_CONE
					-	PHX_CONEFRUSTUM
					-	PHX_PYRAMID
		\param	pos	vector[3]	position of the shape relative to the center of the object
		\param	rot	vector[3]	rotation relative to the object frame
		\param	collisionGroup	int	shape collision group
		\param	density	float	shape density
		\param	draw	bool	if true the current graphical mesh is replaced with the new shape, do nothing if false
		\param	mat	int	physics material handler
		\param	a, b, c, d	shape parameters, see the reference
				SPHERE	a=num_segm b=radius
*/

	matred = CVmMaterial();
	matred.ambient   = [0.7, 0.0, 0.0, 1.0];
	matred.diffuse   = [0.4, 0.0, 0.0, 1.0];
	matred.specular  = [0.2, 0.0, 0.0, 1.0];
	matred.shininess = 0.8;
	matred.transparency = 0.5;
	// LIGHT SOURCE
	M_light = CVmNewMesh("sphere.aam");
	M_light.Normalize(0.5);
	O_light = CVmObj(M_light);
	O_light.ForceMaterial(matred);
	O_light.SetPosition(PosL);
#ifdef DEV_XVR
	//With an high inertia tensor the cursor can't rotate
	PhysXVR.setInertiaTensor(sfera1.getActor(), [10000, 10000, 10000]);
#endif



/*!
 *	Adds a PhObj to the scene.
 *	\param	pos		vector[3]	initial position
 *	\param   rot		vector[3]	initial orientation in degree
 *	\param	type	int 
 *	- DYNAMIC (default): the object is affected by gravity and collision
 *	- KINEMATIC: the object is not affected by forces but can be moved with the setPosition
 *	- FIXED: the object is static and can't be moved. Other objects collide with it.
 *	\param	mat		int		graphical material 
 *	\param	shape	int		specifies the shape
 *  - NONE
 *  - BOX
 *	- SPHERE	
 *	- CYLINDER
 *	- CONE
 *	- CONEFRUSTUM
 *	- PYRAMID
 *	- PLANE
 *	\param	cg		int		collision group
 *	\param	density	float	object density (ignored if the object is FIXED)
 *	\param	phmat	int		index of a physical material (default=0)
 *  \param	a, b, c, d	shape parameters. See the reference.	 
 */
	//MS opening UDP connection to receive commands from external GUI
	UDP_Channel = NetCreateChannel(XVR_Port, Void, VR_NO_BLOCKING);
	//MS check for new commands from external GUI

	
	LoadPuzzle();
	
	LoadBasket();
	
	gestore.Simulate(0.001);

		
	 #ifdef SHADOW
	/*
	 * Put camera "1" where the light is and orient it towards the center of the scene.
	 * If you want to move the light, please move this camera accordingly
	 */	
	CameraActivate(LIGHT_CAMERA);
	CameraSetPosition(PosL);
		#ifdef TWO_LIGHT
		CameraActivate(LIGHT_CAMERA2);
		CameraSetPosition(PosL2);
		#endif
	CameraSetTarget([0, 0, 0]);
	CameraActivate(SCENE_CAMERA);
	#endif
	
	#ifdef LOG_DATA
		DLL_LogData = CVmExternDLLAuto( "LogData2.dll" );
		if(LOG_STYLE=="MATLAB")
		{
			file_ext="m";
			BufferSize = (10*10^6)/(BufferNum*8);	// FILESIZE/BUFFERNUM*DOUBLE	//30000;
		}
		if(LOG_STYLE=="ASCII")
		{
			file_ext="txt";
			BufferSize = (50*10^6)/(BufferNum*8);	// FILESIZE/BUFFERNUM*DOUBLE	//30000;
		}
	#endif

	#ifdef DEV_TRACKHOLD
	
		Hoff = 0.0;  // HORIZONTAL POS
		Voff = 0.0;  // VERTICAL POS
		Doff = 0.3;//-0.5; // DEPTH
		Pos_Offset_VR = [ Hoff,Doff,Voff ];
		Pos_Offset_Dev = [ 0,0,0 ];	
		Scale = 3.0;
		//replica l
		pos = [0.0, 0.0, 0.0];
	
	



//	ProcessData({"Clock"});   // OKKIO ... NON PRESENTE IN 
	#endif

	#ifndef DEV_TRACKHOLD
		senddata(sprintf("CUB,%f",CUBE_SIZE));
		var stri_puz="PUZ";
		for(i=0;i<len(immagini);i++)
			stri_puz = stri_puz + sprintf(",%s",immagini[i]);
		senddata(sprintf("%s",stri_puz));
		senddata("INT");
		//MS check for new commands from external GUI
		ReceiveData(UDP_Channel);
	#endif
} // ONINIT







#ifdef SHADOW

	// light projection and modelview matrices
	var light_mat_proj=array(2);
	var light_mat_modelview=array(2);
	
	function RenderOnTexture(luce)
	{
//		CameraActivate(LIGHT_CAMERA);
		CameraActivate(luce);
		
		shader.active(true);
		/*
		 * First of all, you have to notify your intention
		 * to draw on the offscreen framebuffer you have created
		 * (that is, render to texture)
		 */
		fbo.Start();
		
		/*
		 * Then, you start drawing as usual in XVR
		 */	
		SceneBegin();
			
			/*
			 * Retrieve the modelview and projection matrix of the light
			 * and save them; of course if the light is fixed, this is
			 * needed only once
			 */
			light_mat_proj[luce-1]      = glGet(GL_PROJECTION_MATRIX);
			light_mat_modelview[luce-1] = glGet(GL_MODELVIEW_MATRIX);
			
			/*
			 * Polygon offset is needed in order to avoid artifacts in the
			 * final image due to low precision of depth buffer values
			 */
			glEnable(GL_POLYGON_OFFSET_FILL);
			glPolygonOffset(2, 2);
			
				/*
				 * Here, draw all the objects that should CAST shadows
				 */
					var view_scale=-0.025;		
					var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
				
					DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
					//o_stanza.Draw();
					gestore.Draw();
	
			glDisable(GL_POLYGON_OFFSET_FILL);
			
		SceneEnd();
		
		/*
		 * Tell XVR that you are done with the offscreen framebuffer
		 * and that subsequent draw operations should occur on the screen
		 */
		fbo.Stop();
	}
	
	
	
	
	function FillTextureMatrix(luce)
	{
		glMatrixMode (GL_TEXTURE);
		
		/*
		 * First of all, we have to clamp the values in the [0.0,1.0] range
		 * instead of the [-1.0,1.0] we obtain from the view matrices
		 */
		glLoadIdentity();
		glTranslate(0.5, 0.5, 0.5);
		glScale(0.5, 0.5, 0.5);
		
		/*
		 * Next, multiply by the previously retrieved light matrices
		 */
		glMultMatrix(light_mat_proj[luce-1]);
		glMultMatrix(light_mat_modelview[luce-1]);
		
		/*
		 * Finally, we multiply by the inverse of the *current* modelview matrix
		 * This is needed because it is already included in each vertex own modelview
		 */
		var s_mat_m = glGet(GL_MODELVIEW_MATRIX);
		
		/*
		 * This matrix should always be invertible, but still...
		 */
		if (! InvertMatrix(&s_mat_m))
			Quit("Singular view matrix!");
		
		glMultMatrix(s_mat_m);
	}


#endif	//SHADOW






function DrawScene()
{

	
			#ifdef SHADOW	// 3D VIEW
				FillTextureMatrix(LIGHT_CAMERA);
				#ifdef TWO_LIGHT
					FillTextureMatrix(LIGHT_CAMERA2);
				#endif
				
				glMatrixMode(GL_MODELVIEW);
				
				shader.Start();
				
					SetActiveTexture(fbo,0,4);
		    		shader.SetParameter("shadowMap", 4);
		    		shader.SetParameter("tex", 0);
		
						
						var view_scale=-0.025;		
						var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
					    //stri = sprintf("ArrowEnd: %2.1f %2.1f %2.1f",arrowEnd[0],arrowEnd[1],arrowEnd[2]);
						//stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
					
						DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
						
						o_stanza.Draw();
						gestore.Draw();
						
						if ( session == "Puzzle" )	// DISPLAY THE PICTURE
						{	
							glColor(1.0,1.0,1.0,0.5);
							glEnable(GL_BLEND);
							
							#ifdef NINE_CUBES
							if(pov==3)	DrawPolygon(Map,-CUBE_SIZE*3/2,CUBE_SIZE*3/2, CUBE_SIZE*3/2, -CUBE_SIZE*3/2, 0.1);
							if(pov==2)	DrawPolygonXZ(Map,-CUBE_SIZE*3/2,CUBE_SIZE*3/2, CUBE_SIZE*3/2, -CUBE_SIZE*3/2, CUBE_SIZE);//0.1);
							#endif
							
							#ifdef FOUR_CUBES
							if(pov==3)	DrawPolygon(Map,-CUBE_SIZE,CUBE_SIZE, 0.075, CUBE_SIZE*2+0.075, -0.15);
							if(pov==2)	DrawPolygonXZ(Map,-CUBE_SIZE,CUBE_SIZE, 0.075, CUBE_SIZE*2+0.075, -0.15);
							#endif
							
							glDIsable(GL_BLEND);
							glColor(1.0,1.0,1.0,1.0);
						}
						
						if ( session == "Basket" )
						{
							o_basket.draw();
							//o_cesto[0].draw();
						}
						
						if (session == "Clock" )
						{
							for (var i=0;i<NUM_CUBES;i++)	v_cube[i].Draw();
		
						}
						
		
		    	shader.Stop();
		    	
				
			#else
				var view_scale=-0.025;		
				var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
			    //stri = sprintf("ArrowEnd: %2.1f %2.1f %2.1f",arrowEnd[0],arrowEnd[1],arrowEnd[2]);
				//stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			
				DrawLine(temp_pos_sfera,arrowEnd,1,0,0);

				o_stanza.Draw();
				
				gestore.Draw();
				
				if ( session == "Puzzle" )	// DISPLAY THE PICTURE
				{	
					glColor(1.0,1.0,1.0,0.5);
					glEnable(GL_BLEND);
					
					#ifdef NINE_CUBES
					DrawPolygonXZ(Map,-CUBE_SIZE*3/2,CUBE_SIZE*3/2, CUBE_SIZE*3/2, -CUBE_SIZE*3/2, CUBE_SIZE);
					#endif
					
					#ifdef FOUR_CUBES
					DrawPolygonXZ(Map,-CUBE_SIZE,CUBE_SIZE, 0.075, CUBE_SIZE*2+0.075, -0.15);
					#endif
					
					glDIsable(GL_BLEND);
					glColor(1.0,1.0,1.0,1.0);
				}
				
				if ( session == "Basket" )
				{
					o_basket.draw();
					//o_cesto[0].draw();
				}
				
				if (session == "Clock" )
				{
					for (var i=0;i<NUM_CUBES;i++)	v_cube[i].Draw();

				}
				
	
			#endif
   
		    // ENABLE FORCE
		    /*
		    if ((KeyPressed(VK_F7))&&(!ControlFlagOnF))
		    {
			    isForceEnabled=!isForceEnabled;
			    ControlFlagOnF=true;
			    ForceStatus=1;
		    }
		    if (!KeyPressed(VK_F7))
		    {
		       ControlFlagOnF=false;
			   ForceStatus=0;
		    }
			*/
			TaskBar();		
			// SHOW GRASP BARS
			//bar(0.01,0.05,Fgrab,GRASP_THRESHOLD,10.0,"","Grab",1,1);


}








var isgrabbed=0;	// EVENT FOR DATALOG
var grasp_on=0;
var startedtask=false;	// START OF PUZZLE FLAG
var keyon=false;
var oldpatient ="";
var plotdataon = false;
var stri_obj2="";
var t_start,t_msg;
var calibkey_on = false;
var scalekey_on = {false,false};

function OnFrame()
{

	#ifdef DEV_TRACKHOLD
	
		if(keypressed("c")&&!calibkey_on)
		{
				Pos_Offset_Dev = dev_pos;//Pos_Offset = pos;
				calibkey_on=true;
				output("Offset=",Pos_Offset_Dev);
		}
		
		if(!keypressed("c")) calibkey_on=false;


		if(keypressed(VK_UP)&&!scalekey_on[0])
		{
				Scale=Scale+0.25;
				if(Scale >= 8.0)		Scale = 8.0;
				//ProcessData({"ChangeScale",Scale});
				scalekey_on[0]=true;
//				outputln(TH20.Param.Scale);
		}
		
		if(!keypressed(VK_UP)) scalekey_on[0]=false;
		
		if(keypressed(VK_DOWN)&&!scalekey_on[1])
		{
				Scale=Scale-0.25;
				if(Scale <= 1.5)		Scale = 1.5;
				//ProcessData({"ChangeScale",Scale});
				scalekey_on[1]=true;
//				outputln(TH20.Param.Scale);
		}
		
		if(!keypressed(VK_DOWN)) scalekey_on[1]=false;

		//if(keypressed("d"))		ProcessData({"ChangeDepth",Doff});
		/*
			if(data[0] == "ChangeScale")
			{
					Scale = data[1];
					if(Scale < 2.0)		Scale = 2.0;
					//if(Scale > 5.0)		Scale = 5.0;
			}
			if(data[0] == "ChangeHoriz")
			{
					Hoff = data[1];
			}
			if(data[0] == "ChangeVert")
			{
					Voff = data[1];
			}
			if(data[0] == "ChangeDepth")
			{
					Doff = data[1];
			}
		*/
		
#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_UpDate_DataIn();
	TH20_UpDate_Status();
	TH20_GetConfig();
	
	TH20_Apply_Command();
	TH20_Apply_Param();
	TH20_Apply_UserData();
	
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Display_Current_Device = TH20_Display_SelectDevice(TH20.LibConfig.Device_ID);
	TH20_Display_Refreh_Data_SM(&(Wd.Sys[0].Dev[Display_Current_Device]));
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif







#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnFrame();

	ALEX10.UpDate_DataIn();
	ALEX10.GetConfig();
	
	ALEX10.Apply_Param();
//	ALEX10.Apply_UserData();
	
//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	Display_Current_Device = ALEX10_Display_SelectDevice(ALEX10.Driver_Config.Device_ID);
	ALEX10_Display_Refreh_Data_SM(&(Wd.Sys[0].Dev[Display_Current_Device]));
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif







	#endif
	
	//MS check for new commands from external GUI
	ReceiveData(UDP_Channel);


	if(plotdataon)	view_plot();
	
	if (checkApp){
			
			#ifdef LOG_DATA
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

			if(paziente!="<Paziente>")	pazienteSelected = true;
			//outputln("LOGON: !LOGINIT",!LogInitialized," && PAZIENTESEL=",pazienteSelected," && START=",startedtask," && !STOP=",!StopLog);

			// LOGGING DATA STARTED AUTOMATICALLY WHEN TASK START
			if (!LogInitialized && pazienteSelected && startedtask && !StopLog)
			{
				outputln("LOG ON");
				LogDataInit();
				LogInitialized = true;
				senddata("LOG,1");
				LogStarted = true;
			}
			
			//outputln("LOGOFF: !STARTED=",!startedtask," || STOP=",StopLog," && LOGSTARTED=",LogStarted);
			// LOGGING DATA STOPPED FROM GUI OR AUTOMATICALLY WHEN TASK FINISHED
			if ( ((!startedtask)||(StopLog)) && LogStarted )
			{
				outputln("LOG OFF");
				DLL_LogData.XVR_LOG_Stop();
				senddata("LOG,0");
				StopLog = false;
				LogStarted = false;
				LogInitialized = false;
			}
			
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			#endif


			if (keypressed(VK_ESCAPE))
			{
				for(var i=0;i<4;i++)
					kp[i]=0.0;
				outputln("QUIT");
				application.quit();
			}
			
			/*
				var stri_x=0.55,stri_y=0.9,stri_dx,stri_dy=-0.03;
				ConsoleFont("Arial", 24);
				ConsoleColor( 0.0, 0.0 , 0.0, 1.0 );
				var stri = sprintf("CubVel: %5.5f",sqrt(HB_speed[0]^2+HB_speed[1]^2+HB_speed[2]^2));
				Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Vel: %5.5f",sqrt(HiVel[0]^2+HiVel[1]^2+HiVel[2]^2));
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			*/	
				
			#ifdef __DEBUG
				ConsoleColor(0.8,0.8,0.8,0.5);
				ConsoleFilledRect(0.52,0.99,0.35,0.32);
				var stri_x=0.55,stri_y=0.9,stri_dx,stri_dy=-0.03;
				ConsoleFont("Arial", 18);
				ConsoleColor( 0.0, 0.0 , 0.0, 1.0 );
				var stri = sprintf("Posizione: %f %f %f",pos[0],pos[1],pos[2]);
				Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Vel: %2.1f %2.1f %2.1f",HiVel[0],HiVel[1],HiVel[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Pos Sfera: %f %f %f",temp_pos_sfera[0],temp_pos_sfera[1],temp_pos_sfera[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Compensazione Gravita': %f", GravityComp);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Cubo selezionato: %d, Cubo Inserito: %d", sel_obj,mat_obj);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Distanza Minima %f", temp_dist);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Forza: %2.1f %2.1f %2.1f",Force[0],Force[1],Force[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
			    stri = sprintf("Forza sx: %2.1f %2.1f %2.1f",forzaSx[0],forzaSx[1],forzaSx[2]);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Forza Abilitata: %1.0f", ForceStatus);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				stri = sprintf("Grab Forza: %2.1f", Fgrab);
				stri_y=stri_y+stri_dy;Consoletext(stri_x,stri_y,stri);
				//stri = sprintf("Nome del file: %s",nomefile);	Consoletext(0.1,0.74,stri);
			#endif
		

			static var camera_angle = 0;
			#ifdef ENABLE_STEREO
			var camera_radius = 0.1;//1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#else
			var camera_radius = 1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#endif
			var cam_end,tar_end;
			var glob_end=0;
			static var sel_now = true;
			var CameraPosT;
			
			trace(stato);
			switch(stato)
			{
			
			case INTRO_:

				// ROTATION SPEED OF CAMERA AROUND THE PUZZLE
				camera_angle += 0.005;
				// CameraSetPosition -> RenderTextures -> Activate Camera
				if(pov==2)
				{
					CameraPosT = [camera_radius*cos(camera_angle), camera_elevation + camera_osc*sin(camera_angle), camera_radius*sin(camera_angle)];
					CameraSetPosition(CameraPosT);
					CameraSetTarget(CamTarget2D);
				}
				else
				{
					CameraSetPosition(camera_radius*cos(camera_angle), 1, camera_radius*sin(camera_angle) );
					CameraSetTarget(CamTarget2D);
				}
			
				// DISABLE COLLISION AMONG CUBES AND PROXY
				// IF THE DEVICE NOT INITIALIZED
				if((EndInit==0)&&(!plotdataon))
				{		
					disp(0.5,0.55,"EXOS NOT INITED",0,"R",40,1);
					for(var j=0; j<NUM_CUBES; j++)
						PhysXVR.disableCollision(0,j+1);
				}
				else
				{
					disp(0.5,0.55,"WAIT, PLEASE",0,"R",40,1);
					for(var j=0; j<NUM_CUBES; j++)
						PhysXVR.disableCollision(0,j+1);
				}
				// GO TO THE NEXT STATE ONLY IF ENCODERS ARE SET
				if((mouse.ButtonL)&&(EndInit==1)&&(!plotdataon))
				{
					stato = INTRO2_;
				}
				
			break;
				
			case INTRO2_:
			
				disp(0.5,0.55,"READY...",0,"R",40,1);

				// CameraSetPosition -> RenderTextures -> Activate Camera
				if(POV==3)
				{
					Cam_end = MoveCameraTo(CamPos[0],CamPos[1],CamPos[2]);
					Tar_end = MoveCameraTarget(CamTarget[0],CamTarget[1],CamTarget[2]);
				}
				if(POV==2)
				{
					CameraSetTarget(CamTarget2D);
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],CamPos2D[2],90-(camera_angle*180/PI)%360);
					Tar_end = 1;
				}
				
				glob_end = Cam_end + Tar_end;

				if (glob_end == 2)
				{
					for(var j=0; j<NUM_CUBES; j++)
						PhysXVR.enableCollision(0,j+1);
						
					switch(session)
					{
						case "Puzzle":
							ManageCollision();
							stato = PUZZLE_;
							task="P";
							break;
						case "Basket":
							//ManageCollision();
							stato = BASKET_;
							task="B";
							break;
						case "Clock":
							//ManageCollision();
							stato = CLOCK_;
							task="C";
							break;
					}
					glob_end=0;
					t_start=getperformancetimer()/1000000.0;
					outputln(session);
				}

			break;
				
			case PUZZLE_:

				t_msg=getperformancetimer()/1000000.0 - t_start;
				if(t_msg<1.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
				else if(t_msg>=1.0 && t_msg<2.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
				
				#ifdef __DEBUG2
				disp(0.5,0.1,"PUZZ",0,"R",40,1);
				#endif
				#ifdef __DEBUG
				for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
				for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
				for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
				#endif

				#ifndef DEV_MOUSE
					CameraMoveMouse();
				#endif

				if(grabbed())
				{
					#ifdef __DEBUG2
					var stri_obj=sprintf("N.%d PRESO",sel_obj);
					disp(0.2,0.8,stri_obj,0,"R",50,1);
					#endif
					attachCube(pov); //ENABLE THE GRID
					if (sel_now)
					{
						#ifdef __DEBUG2
						var stri_obj=sprintf("N.%d PRESO",sel_obj);
						disp(0.2,0.8,stri_obj,0,"R",50,1);
						#endif
						SoundFX[SFX_PICK].Play();
						sel_now = false;
					}
				}
				else
				{
					// ALL CUBES MATCHED
					if((len(free_cubes)==0)&&(startedtask))
					{
						#ifndef DEV_TRACKHOLD
						senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
						#endif
						stato = END_;
						startedtask = false;
					}
					sel_now = true;
				}

				if(startedtask)	// START TIMECOUNTER
				{
					total_time=(gettime()-timer)/1000.0;
					// DISPLAY THE TOTAL TIME AT RUNTIME
					//disp(0.8,0.85,sprintf("%2.1f s",total_time),0,"R",60,1);
				}

				break;
				
			case BASKET_:
			
				t_msg=getperformancetimer()/1000000.0 - t_start;
				if(t_msg<1.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
				else if(t_msg>=1.0 && t_msg<2.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));

				#ifdef __DEBUG2
				disp(0.5,0.1,"BASK",0,"R",40,1);
				#endif
				#ifdef __DEBUG
				for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
				for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
				for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
				#endif
				
				#ifndef DEV_MOUSE
					CameraMoveMouse();
				#endif

				// IF CUBE GRABBED
				if(sel_obj!=0)
				{
					#ifdef __DEBUG
					var stri_obj=sprintf("N.%d PRESO",sel_obj);
					disp(0.2,0.8,stri_obj,0,"R",50,1);
					#endif
					ThrowBasket();
					if (sel_now)
					{
						#ifdef __DEBUG
						var stri_obj=sprintf("N.%d PRESO",sel_obj);
						disp(0.2,0.8,stri_obj,0,"R",50,1);
						#endif
						SoundFX[SFX_PICK].Play();
						sel_now = false;
					}
				}
				else
				{
					if((len(free_cubes)==0)&&(startedtask))	// WHEN FREE CUBES NO MORE
					{
						#ifndef DEV_TRACKHOLD
						senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
#endif
						stato = END_;
						startedtask = false;
					}
				}
				
				if(startedtask)	// START TIMECOUNTER
				{
					total_time=(gettime()-timer)/1000.0;
					// DISPLAY THE TOTAL TIME AT RUNTIME
					//disp(0.8,0.85,sprintf("%2.1f s",total_time),0,"R",60,1);
				}
				
			
			break;

			case CLOCK_:
				
				t_msg=getperformancetimer()/1000000.0 - t_start;
				if(t_msg<1.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
				else if(t_msg>=1.0 && t_msg<2.0)
					disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));

				#ifdef __DEBUG2
				disp(0.5,0.1,"CLK",0,"R",40,1);
				#endif
				#ifdef __DEBUG
				for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
				for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
				for(var m=0; m<NUM_CUBES; m++)	outputln("Vis(",m,")=",o_cube[m].isvisible());
				#endif
				
				#ifndef DEV_MOUSE
					CameraMoveMouse();
				#endif

				#ifdef __DEBUG2
				stri_obj2 = sprintf("N.%d PRESO",sel_obj);
				disp(0.2,0.8,stri_obj2,0,"R",50,1);
				#endif
				
				if(sel_obj!=0)	// IF A CUBE IS GRABBED
				{
					attachClock(pov);
					if (sel_now)
					{
						#ifdef __DEBUG2
						var stri_obj=sprintf("N.%d PRESO",sel_obj);
						disp(0.2,0.8,stri_obj,0,"R",50,1);
						#endif
						SoundFX[SFX_PICK].Play();
						sel_now = false;
					}
				}
				else
				{
					if((len(free_cubes)==0)&&(startedtask))	// AT THE END OF TASK, WHEN THERE ARE NO FREE CUBES
					{
						#ifndef DEV_TRACKHOLD
						senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
#endif
						stato = END_;
						startedtask = false;
					}
					sel_now = true;
				} 

				if(startedtask)	// START TIMECOUNTER
				{
					total_time=(gettime()-timer)/1000.0;
					// DISPLAY THE TOTAL TIME AT RUNTIME
					//disp(0.8,0.85,sprintf("%2.1f s",total_time),0,"R",60,1);
				}
				
			break;

			case END_:
			
				
				//outputln("END");
				// CameraSetPosition -> RenderTextures -> Activate Camera
				if(POV==3)
				{
					Cam_end = MoveCameraTo(CamPos[0],CamPos[1],CamPos[2]);
					Tar_end = MoveCameraTarget(CamTarget[0],CamTarget[1],CamTarget[2]);
				}
				if(POV==2)
				{
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],0.0,0.0);
					Tar_end = 1;
				}
				glob_end = Cam_end+Tar_end;			

				SoundFX[SFX_FINISH].Play();
				SoundFX[SFX_CLAP].Play();

				//outputln("REQ",reqscore,"LOAD",scoreloaded);
				
				if(!reqscore) //IF NOT ALREADY REQUESTED...
				{
						#ifndef DEV_TRACKHOLD
					senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
#endif
					reqscore = true;
				}

				session="";
				if((glob_end == 2)&&(!scoreloaded))
				{
					stato = END2_;
				}
				
			break;
				
			case END2_:	
			
				// PLOT TO CHECK
				//outputln("END2");
				//outputln("DATA SCORED = ",scores, " TYPE = ",valtype(scores));
				if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
				{
					if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
					{
						//outputln("PLOT");
						plot(scores,"CONGRATULATION!");
					}
					else
					{
						//outputln("TEXT");
						disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
						disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
					}
				}
				else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
				{
					//outputln("TEXT");
					disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
					disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
				}
				reqscore=false;
				scoreloaded=false;
				timer = 0.0;
				
				#ifdef _DEBUG
					outputln(session,"========",prev_session);
					for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
					for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
				#endif
				if(session!="")		//quit();//stato = INTRO_;
				{
					switch(session)
					{
						case "Puzzle":
							stato = PUZZLE_;
							break;
						case "Basket":
							stato = BASKET_;
							break;
						case "Clock":
							stato = CLOCK_;
							break;
					}
					glob_end=0;
				}
			break;

			}//switch(stato)



			//disp(0.47,0.05,sprintf("STATUS: %f",HiControlStatus),0,"R",40,1);
			//disp(0.35,0.12,sprintf("POS: %5.2f, %5.2f, %5.2f",pos[0],pos[1],pos[2]),0,"R",40,1);
		
		
		
			#ifdef _DEBUG
			outputln("NUMBER OBJECTS = ",NUM_CUBES);
			outputln("SESSION = ",session);
			outputln("PREV SESSION = ",prev_session);
			outputln(" ***************************************************");
			#endif
			if((temp_isSelected)&&(sel_obj>0))
			{
				//m_cube[sel_obj-1].ForceSubsetMaterial(0,maton);
				m_cube[sel_obj-1].ModulateSubsetMaterial(1,[0.5,1.0,0.5]);
				//m_cube[sel_obj-1].SubsetModulateMaterial(1,[0.5,1.0,0.5]);
				o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
			}
			else
			{
				for (var i=0;i<NUM_CUBES;i++)
				{
					//m_cube[i].ForceSubsetMaterial(0,matoff);
					m_cube[i].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
//					m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
					o_cube[i].LinkToMesh(m_cube[i]);
				}
			}
			
			#ifdef SHADOW
				RenderOnTexture(LIGHT_CAMERA);
				#ifdef TWO_LIGHT
					RenderOnTexture(LIGHT_CAMERA2);
				#endif
				CameraActivate(SCENE_CAMERA);
			#endif
			
		#ifndef ENABLE_STEREO		
				SceneBegin();
				DrawScene();
				#ifdef DEV_TRACKHOLD



#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif




				#endif
				SceneEnd();
		#else //enable stereo
				glDrawBuffer(GL_BACK_LEFT);
				//glColorMask(1,0,0);
				SceneBegin(VR_STEREO_LEFT);	
				DrawScene();
				#ifdef DEV_TRACKHOLD


#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif


#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif




				#endif
				SceneEnd();
				//glColorMask(0,1,1);
				glDrawBuffer(GL_BACK_RIGHT);
				SceneBegin(VR_STEREO_RIGHT);	
				#ifdef DEV_TRACKHOLD



#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif


#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif


				#endif
				DrawScene();
				
				#ifdef DEV_TRACKHOLD



#ifdef TRACKHOLD20
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef TH20_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif

#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnScene();

//===================================================
// DISPLAY DEVICE
//===================================================
#ifdef ALEX10_DISPLAY
	Device_Draw(Wd.Sys[0].Dev[Display_Current_Device]);
	Device_KeyManager(&(Wd.Sys[0].Dev[Display_Current_Device])); 
#endif
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
#endif

				#endif
				
				SceneEnd();
		#endif

		
	}//CHECK APP
	else
	{
		if (keypressed(VK_ESCAPE))	application.quit();

		consolecolor(0.5,0.5,0.5,1.0);
		consolefont("ARIAL",30);
		consoletext(0.4,0.5,"TARGET NOT ACTIVE");
		consolefont("ARIAL",20);
		consoletext(0.44,0.45,"PRESS ESC TO EXIT,");
		consoletext(0.37,0.4,"CHECK THE ETHERNET CABLE AND THEN");
		consoletext(0.35,0.35,"RESTART THE TARGET AND THE APPLICATION");

	}
}








// Computes the force feedback
function FF(pLeft, pRight){

#ifdef controlloGrab
	var F = vector(6);
	var stiff = 500;
	var h = 1.2;
	var vel = [0.0,0.0,0.0];

	var posSfera1 = sfera1.GetPosition();
	var posSfera2 = sfera2.GetPosition();
	static var posSfera1Old = posSfera1;
	static var posSfera2Old = posSfera2;

	static var OldgrabOffset = grabOffset;

	var dDx = vector(3);
	var dSx = vector(3);
	var ddDx = vector(3);
	var ddSx = vector(3);
	

	pLeft  = pLeft + camTarget + grabOffSet;
	pRight = pRight + camTarget + grabOffSet;
	dSx =  posSfera1 - pLeft;
	dDx =  posSfera2 - pRight;
	ddDx = (posSfera2 - posSfera2Old) *1000;
	ddSx = (posSfera1 - posSfera1Old) *1000;
	vel = (grabOffset-OldgrabOffset) *1000;

	forzaSx = [0.0, 0.0, 0.0];
	forzaDx = [0.0, 0.0, 0.0];

	forzaSx = dSx  * -stiff + ddSx * -h;
	forzaDx = dDx  * -stiff + ddDx * -h;
	
	sfera1.AddForceABS(forzaSx[0], forzaSx[1], forzaSx[2]);
	sfera2.AddForceABS(forzaDx[0], forzaDx[1], forzaDx[2]);

	F[0] = -forzaSx[0];
	F[1] = -forzaSx[1];
	F[2] = -forzaSx[2];
	F[3] = -forzaDx[0];
	F[4] = -forzaDx[1];
	F[5] = -forzaDx[2];
	
	F /= 1+modulus(vel);
	posSfera1Old = posSfera1;
	posSfera2Old = posSfera2;
    
    OldgrabOffset = grabOffset;
    return F;
#endif
}







function Select(currPos)
{

		if (IsPressed == false) //controlla se il pulsante del device  stato premuto per la prima volta
		{
			var min_dist=10;

			for(var i=0; i<len(free_cubes); i++)
			{
				// IDENTIFY THE CLOSEST OBJECT TO THE PROXY
				var dist = pos - o_cube[free_cubes[i]-1].GetPosition();
				var dist_mod = dist[0]^2+dist[1]^2+dist[2]^2;
				if (dist_mod<min_dist)
				{
					min_dist=dist_mod;
					switch(session)
					{
						case "Basket":
							// SELECTION SHOULD BE LED BY MINIMUM DISTANCE
							// AND SMALLEST NUMBER OF CUBE (IN ANTI-CLOCKWISE SENSE)
							if((min_dist<SELECT_DISTANCE)&&(i==0))
								sel_obj=free_cubes[i];
							#ifdef __DEBUG
							outputln("SELECTED(EVA)");
							#endif

							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();	
								startedtask=true;
							}
						break;
						
						case "Clock":
							// SELECTION SHOULD BE LED BY MINIMUM DISTANCE
							// AND SMALLEST NUMBER OF CUBE (IN CLOCKWISE SENSE)
							if((min_dist<SELECT_DISTANCE)&&(i==0))
							{
								sel_obj=free_cubes[i];
								for(var j=0; j<NUM_CUBES; j++)
									PhysXVR.disableCollision(sel_obj,j+1);
							}
							#ifdef __DEBUG
							outputln("SELECTED(CLK)");
							#endif

							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							//if(len(matched_cubes)==0)
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
						
						case "Puzzle":
							if(min_dist<SELECT_DISTANCE)	sel_obj=free_cubes[i];
							#ifdef __DEBUG
							outputln("SELECTED(PUZ)");
							#endif

							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
					}
				} // endif dist_mod
				
			} //endfor i
			
			
			temp_dist=min_dist;
			
			// Minimum Distance to activate selection
			if ((min_dist<SELECT_DISTANCE)&&(sel_obj>0))
			{
				currPos = o_cube[sel_obj-1].GetPosition();
				HB_ini = currPos-pos;
				HB_old = currPos;
				IsPressed = true;
				isSelected = true;
			}
			else
			{
				IsPressed = false;
				isSelected = false;
				grasp_on = 0;	// RELEASE CUBE
			}
			//return;
		}
		

	  	if ((isSelected)&&(sel_obj>0))
	  	{
	        currPos = o_cube[sel_obj-1].GetPosition();
	        HB_curr = currPos - pos;
			HB_speed = ( currPos - HB_old )*1000;
			// Force Feedback To Device
			HFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;
			// Reaction Force To The Objetc
			NFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;// - Bi*N_speed;
			HB_old = currPos;
			
			ScalaStiffObjSel=0.5;
			
		}  //end if isSelected
		else  //this else goes with isSelected
		{
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
		}

}









function bar(xmn,ymn,value,ref,max,unit,title,dim,mode)
//	xmn,ymn = Position of Bar Left Bottom Corner
//  meas   = 1dim data measured
//	ref	= 1dim reference
//  max = 1dim max value
//  unit = dimensional unit
//  title = bar title
//  dim = bar dimension (if dim<0 ==> pos/neg scale )
//  mode = display modality (0:green band, 1:switch green/red)
{
	var delta = abs(ref - value);	// Interval around Reference on the Bar
	var eps = 0.05*max;				// Width Green Band (mode=0)
	var dx, dy;
	var maxF = max;
	var ky;				// FACTOR SCALE (SCREEN UNIT/NEWTON)
	var y;
	//var maxBar = yMx;//0.02;		// corresponds to maxF
	var text;
	var wt = 0.01;					// width of tick
	var abx = 0.004;				// Transparent Bar Border
	var aby = 0.005;				// Transparent Bar Border
	var width;
	var fontscale;
	// COLOR
	var red=0.0, green=0.0;
	
	switch(abs(dim)){
	case 0:		//BIG
		dx = 0.08;
		dy = 0.3;
		width = 3;
		fontscale = 1;
		break;
	case 1:		//MEDIUM
		dx = 0.05;
		dy = 0.15;
		width = 2;
		fontscale = 0.7;
		break;
	default:
		dx = 0.1;
		dy = 0.3;
		width = 3;
		fontscale = 1;
		break;
	}
	
	if(dim<0)
	{
		ky = dy/(2*maxF);
		y = ky*value;
	}
	else
	{
		ky = dy/maxF;
		y = ky*value;
	}

	// BAR LABEL
	ConsoleFont("Arial",fontscale*30);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%s",title);
	Consoletext( xmn + 1/len(text)*0.01, ymn + dy + 0.01, text);
	
	// GREEN BAND
	if (mode==0){
		if ((delta>=eps)&&(ref>1))
		{
			red=1.0;
			green=0.0;
		}
		else if ((delta<eps)&&(ref>1))
		{
		// BAR BECOME GREEN ONLY INSIDE THE INTERVAL ref+/-eps
			red = (delta / eps)^4;
			green = 1 - (delta/eps)^4;
		}
		else if (ref<1)
		{
			red=0.0;
			green=1.0;
		}
	}
	
	// SWTICH GREEN-RED
	if (mode==1){
		if (ref>1)
		{
			if (value<ref)
			{
				red=1.0;
				green=0.0;
			}
			else
			{
				red=0.0;
				green=1.0;
			}
		}
		else
		{
			red=1.0;
			green=0.0;
		}
	}

	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	if (dim<0)	ConsoleFilledRect(xmn+abx, ymn+dy/2+aby, dx-2*abx, -y);
	else		ConsoleFilledRect(xmn+abx, ymn+aby, dx-2*abx, -y);
	
	if ((abs(ref)>0.5)&&(abs(ref)<max)){
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(3);
//		ConsoleLines([xmn+abx, ymn+ky*ref-(ref/abs(ref))*aby, xmn+dx-abx, ymn+ky*ref-(ref/abs(ref))*aby]);
		ConsoleLines([xmn+abx, ymn + ky*ref, xmn+dx-abx, ymn + ky*ref ]);
	}
	
	// BORDER BAR
	ConsoleColor(0.0,0.0,0.0,1.0);
	ConsoleWidth(width);
	ConsoleRect(xmn,ymn,dx,-dy);

	// ACTUAL VALUE LABEL
	ConsoleFont("Arial",fontscale*35);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%2.1f%s",value,unit);
	if (len(text)<=4)	Consoletext( xmn + 0.01, ymn - (0.04-dim*0.01), text);
	if (len(text)>4)	Consoletext( xmn, ymn - (0.04-dim*0.01), text);
	
	if (dim==0){
		// TICKS & LABEL
		ConsoleFont("Arial",fontscale*20);
		ConsoleWidth(width);
		ConsoleColor(0.0,0.0,0.0,1.0);
		for(var i=0; i<=maxF/10; i++){	//0.56
			text = sprintf("%2.0f",(i*10));
			ConsoleLines([xmn,ymn + ky*(i*10),xmn - wt,ymn + ky*(i*10)]);
			Consoletext( xmn - 3*wt, ymn + ky*(i*10) - 0.008, text);
		}
	}
}





function SelezionaOggetto()
{

	var currPos=[0.0,0.0,0.0];
	
	#ifdef DEV_XVR
	
		#ifdef DEV_GIMBLE
			if ( (Joy.Grasp==1.0)&&(Joy_status==0) )//Dev(0))
			{
				Select(currPos);
			} //end if Pressed
			else if (KeyPressed(VK_SPACE)) //this else if Gimble is inactive or disconnected
			{
				Select(currPos);
			}
			else
			{
				HFor = [0.0,0.0,0.0];
				NFor = [0.0,0.0,0.0];
				IsPressed = false;
				isSelected=false;
			}
		#endif
		
		// GRAB CUBE THROUGH THE GRASPING FORCE
		#ifdef HANDLE_FORCESENS
			
			// SUM OF BOTH PRESSION SENSORS OF THE HANDLE
			Fgrab = (HiGrasp[0] + HiGrasp[1])/2;
			
			#ifdef HOLD_MOVE	// GRASP ONLY TO CATCH THE CUBE AND AUTOMATICALLY HOLD IT TIL YOU PUT IN THE RIGHT POS
				if ((Fgrab>=GRASP_THRESHOLD)&&(grasp_on==0))
				{
					grasp_on = 1;
				}
		
				// EMERGENCY MANUAL DISABLE OF GRASPING
				if(KeyPressed(VK_RETURN))
				{
					sel_obj=0;
					grasp_on=0;
				}
				
				if (grasp_on==1)
				{
					Select(currPos);
					isgrabbed=1;
				}
				else
				{
					HFor = [0.0,0.0,0.0];
					NFor = [0.0,0.0,0.0];
					IsPressed = false;
					isSelected = false;
					isgrabbed=0;
				}
			#else	// GRASP AND RELEASE
				if (Fgrab>=GRASP_THRESHOLD)
				{
					grasp_on = 1;
				}
				else
				{
					grasp_on = 0;
				}
	
				if((grasp_on==0)&&(sel_obj>0))
				{
					m_cube[sel_obj-1].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
					//m_cube[sel_obj-1].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
					o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
					sel_obj=0;
				}
				
				if (grasp_on==1)
				{
					Select(currPos);
					isgrabbed=1;
				}
				else
				{
					HFor = [0.0,0.0,0.0];
					NFor = [0.0,0.0,0.0];
					IsPressed = false;
					isSelected = false;
					isgrabbed=0;
				}
			#endif
		#else
	
			#ifdef DEV_MOUSE
				// GRAB CUBE THROUGH KEYBOARD
				
				if (KeyPressed(VK_SPACE))
				{
					Select(currPos);
					isgrabbed=1;
				} //end if Dev.isButtonPressed(0)
				else  //this else goes with Dev.isButtonPressed(0)
				{
					HFor = [0.0,0.0,0.0];
					NFor = [0.0,0.0,0.0];
					IsPressed = false;
					isSelected = false;
					isgrabbed=0;
				}
			#endif
			
			#ifdef DEV_TRACKHOLD

#ifdef TRACKHOLD20
				if (TH20.Status.Hand_IsClosed)
#endif
				
#ifdef ALEX10_INTERFACE
				if (ALEX10.xVR_Status.Hand_IsClosed)
// if ((ALEX10.Dev_DataIn.ADC[8]<-3.0))    OKKIO
#endif
				{
					Fgrab = GRASP_THRESHOLD + 0.1*GRASP_THRESHOLD;
				}
				else
				{
					Fgrab = 0;
				}
				#ifdef HOLD_MOVE	// GRASP ONLY TO CATCH THE CUBE AND AUTOMATICALLY HOLD IT TIL YOU PUT IN THE RIGHT POS
#ifdef TRACKHOLD20					
					if ((TH20.Status.Hand_IsClosed)
#endif
#ifdef ALEX10_INTERFACE					
					if ((ALEX10.xVR_Status.Hand_IsClosed)
//if ((ALEX10.Dev_DataIn.ADC[8]<-3.0)    OKKIO
#endif
					
					&&(grasp_on==0))
					{
						grasp_on = 1;
					}
			
					// EMERGENCY MANUAL DISABLE OF GRASPING
					if(KeyPressed(VK_RETURN))
					{
						sel_obj=0;
						grasp_on=0;
					}
					
					if (grasp_on==1)
					{
						Select(currPos);
						isgrabbed=1;
					}
					else
					{
						HFor = [0.0,0.0,0.0];
						NFor = [0.0,0.0,0.0];
						IsPressed = false;
						isSelected = false;
						isgrabbed=0;
					}
				#else	// GRASP AND RELEASE
				
					if (TH20_HandClosed)
// if (ALEX10.Dev_DataIn.ADC[8]<-3.0) OKKIO
					{
						grasp_on = 1;
					}
					else
					{
						grasp_on = 0;
					}
		
					if((grasp_on==0)&&(sel_obj>0))
					{
						//m_cube[sel_obj-1].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
						m_cube[sel_obj-1].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
						o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
						sel_obj=0;
					}
					
					if (grasp_on==1)
					{
						Select(currPos);
						isgrabbed=1;
					}
					else
					{
						HFor = [0.0,0.0,0.0];
						NFor = [0.0,0.0,0.0];
						IsPressed = false;
						isSelected = false;
						isgrabbed=0;
					}
				#endif			
		
			

			#endif
	
		#endif
	#endif
	
		if (isSelected)
		{
		   o_cube[sel_obj-1].AddForceABS(NFor[0], NFor[1], NFor[2]);
		}
		 
		 temp_pos=currPos;
		 temp_isSelected=isSelected;
	  

}




var ind=0;

//Called 1000 time/sec get the position of the grabbers and performs physic simulation
function OnTimer()
{
	// IF APP HAS NOT BEEN IDENTIFIED...
	if (!checkApp)
	{
		#ifdef DEV_NET
//
// AppCode		CONTROL MODALITY
//---------------------------------
// +------------ APPLICATION
// |+----------- ENDINITENCODER
// ||+---------- CONTROL MODALITY
// |||+--------- NOT USED
// ||||
// 1000			OPEN LOOP
// 2000			REACHING - NOMODE
// 2010			POSITION MODE
// 2020			TRIGGER POSITION MODE
// 2030			COMPOSED FORCE/POSITION MODE
// 2040			BASKET MODE
//
			
			#ifdef NOTARGET
			HiControlStatus = 1000;
			#endif
			// HANDSHAKE CONTROL
			if((floor(HiControlStatus/1000) <> floor(AppCode/1000)))
			{
				Dev.ApplyCommand([ 0 , 0 , 0 , 0 , 0, 0, 0, 0, 0, AppCode, 0, 0, 0, 0, 0, 0, 0, 0 ]);
				Dev.SendDataToDevice();
				Dev.GetDataFromDevice();
				HiStatus = Dev.GetStatus();
				HiControlStatus = HiStatus[8];
				outputln("ERROR: NO MATCHING APP");
				outputln("       APPCODE:  ",AppCode);
				outputln("       HISTATUS: ",HiControlStatus);
				checkApp = false;
			}
			else
				checkApp = true;
				
			senddata(sprintf("APP,%f",AppCode));
		#endif
		
		#ifdef DEV_MOUSE
			checkApp = true;
		#endif
		#ifdef DEV_TRACKHOLD
			checkApp = true;
		#endif
	}

	//DataOut(checkapp);	// DOESN'T WORK
	
	#ifdef DEV_XVR
		
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		#ifdef DEV_NET
			Dev.PosScale = Scale;//3.0;	// SCALE UPDATED FROM GUI

			Dev.PosZeroInVR = [ Hoff, Voff, Doff ];// OFFSET UPDATED FROM GUI
			Dev.GetDataFromDevice();
			var HiPos = Dev.GetPosition();
			pos = Dev.ConvPosition(HiPos);	//( HiPos - PosOffset)*PosScale + PosZeroInVR;
			
			// DEPTH MUST BE INDEPENDENT FROM CHANGE IN SCALE...
			pos[2] = ( HiPos[2] - Dev.PosOffset[2])*3.0 + Dev.PosZeroInVR[2];
			
			HiStatus = Dev.GetStatus();
			HiVel = [ HiStatus[0] , HiStatus[1] , HiStatus[2] ];
			HiJointPos = [ HiStatus[3] , HiStatus[4] , HiStatus[5] , HiStatus[6], HiStatus[7]];
			HiControlStatus = HiStatus[8];
			#ifdef NOTARGET
				EndInit = 1;
			#else
				EndInit = floor((HiControlStatus - floor(HiControlStatus/1000)*1000 )/100);
			#endif
			HiForces = [HiStatus[9],HiStatus[10],HiStatus[11]];	// THIS VECTOR NOT REPRESENTS FEEDBACK FORCE
			HiGrasp = [ HiStatus[12], HiStatus[13] ];
			HiPause = HiStatus[14];
			// JOINT TORQUES
			HiTau[0] = HiStatus[15];
			HiTau[1] = HiStatus[16];
			HiTau[2] = HiStatus[17];
			HiTau[3] = HiStatus[18];
			// NOT USED
			HiND[0] = HiStatus[19];
			HiND[1] = HiStatus[20];
			HiND[2] = HiStatus[21];
			HiND[3] = HiStatus[22];
			HiND[4] = HiStatus[23];
			HiND[5] = HiStatus[24];
			HiND[6] = HiStatus[25];

			HiVel = Dev.ConvSpeed(HiVel);
			HPos = 1.0*HiPos;
			HVel = 1.0*HiVel;
			
			var Htemp=[0,0,0];		// Temporary Vector
			
			// Rotation about X of PI/2
			// For aligning the Exos Reference to the floor
			if(pov==2)
			{
				for(var i=0;i<3;i++)
					for(var j=0;j<3;j++)
						Htemp[i] += Rrot[j+(i*3)]*pos[j];
				for(var i=0;i<3;i++)	pos[i]=Htemp[i];
				
				Htemp=[0,0,0];
				for(var i=0;i<3;i++)
					for(var j=0;j<3;j++)
						Htemp[i] += Rrot[j+(i*3)]*HiVel[j];
				for(var i=0;i<3;i++)	HiVel[i]=Htemp[i];
				Htemp=[0,0,0];
				for(var i=0;i<3;i++)
					for(var j=0;j<3;j++)
						Htemp[i] += Rrot[j+(i*3)]*HiForces[j];
				for(var i=0;i<3;i++)	HiForces[i]=Htemp[i];
				Htemp=[0,0,0];
			}
		#endif
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	

		#ifdef DEV_MOUSE
			EndInit = 1;
			pos = Dev.GetPosition();
			pos = [-pos[0],-pos[1],-pos[2]];
			var Htemp=[0,0,0];		// Temporary Vector
		#endif	

		#ifdef DEV_TRACKHOLD
			EndInit = 1;
			var Htemp=[0,0,0];		// Temporary Vector
			//===================================================
			// TRACKHOLD INTERFACE
			//===================================================
	 		//TH20_BasePosition = [ 0.0, 0.0, 0.0 ]; // UPDATE DEVICE OFFSET
	 		
	 		
#ifdef TRACKHOLD20
			dev_pos = Estrai_Pos(TH20.DataIn.EE_Matrix);
#endif
				
#ifdef ALEX10_INTERFACE
			dev_pos = Estrai_Pos(ALEX10.Dev_DataIn.EE_Matrix);
#endif
	 		
			
			
			
			dev_pos = [dev_pos[0]*Scale,dev_pos[1]*Scale,dev_pos[2]];
			//dev_pos = Align_Device([dev_pos[0]*Scale,dev_pos[1]*Scale,dev_pos[2]]);
			dev_pos = [dev_pos[0],dev_pos[2],-dev_pos[1]];
			pos = (dev_pos - Pos_Offset_Dev) + Pos_Offset_VR;
			//===================================================
		#endif
	
		switch(stato)
		{
			case PUZZLE_:
			    // Estimate Interaction Force Between Device And Selected Object
			    SelezionaOggetto();
			break;
			case BASKET_:
			    // Estimate Interaction Force Between Device And Selected Object
			    SelezionaOggetto();
			break;
			case CLOCK_:
			    // Estimate Interaction Force Between Device And Selected Object
			    SelezionaOggetto();
			    #ifdef __DEBUG2
				outputln(sprintf("ONTIMER C:OBJ %d",sel_obj));
				#endif
			break;
			default:
				HFor = [0.0,0.0,0.0];
				NFor = [0.0,0.0,0.0];
				IsPressed = false;
				isSelected=false;
				ScalaStiffObjSel=1.0;
			break;
	
		}//switch
		
		var posSfera1 = sfera1.GetPosition();
		static var posSfera1Old = posSfera1;
		temp_pos_sfera=posSfera1;
		ind=ind+1;
		dSx =  posSfera1 - pos;	// Position Error
		ddSx =  (posSfera1 - posSfera1Old) *1000; // Raw Estimation of Sphere Speed
		//outputln("poserr(",ind,",:) = ",dSx);


	 	// FORCE ON THE EXOS HANDLE
		forzaSx = dSx  * -StiffSferaExos * ScalaStiffObjSel - HiVel * hexos;
		//outputln("fex(",ind,",:) = ",forzaSx);
	
	    var ForzaSfera=[0.0, 0.0, 0.0];
	    var ForceSaturation = 25;
	    
		// FORCE ON THE PROXY SPHERE
	    forzaSfera = - dSx  * StiffSfera * ScalaStiffObjSel - ddSx * h;
	    sfera1.AddForceABS(forzaSfera[0], forzaSfera[1], forzaSfera[2]);
		
		// SOMMO ALLA FORZA DI CONTATTO CON I CUBI LA FORZA SCAMBIATA CON LA SFERA
		HFor[0] +=forzaSx[0];
		HFor[1] +=forzaSx[1];
		HFor[2] +=forzaSx[2];
		posSfera1Old = posSfera1;

	    // Force Saturation
	    if (modulus(HFor)>ForceSaturation )
		{
			HFor[0]=HFor[0]/modulus(HFor)*ForceSaturation;
			HFor[1]=HFor[1]/modulus(HFor)*ForceSaturation;
			HFor[2]=HFor[2]/modulus(HFor)*ForceSaturation;	
		}


	#endif	//DEV_XVR
	
	gestore.updateGraphics();
	gestore.Simulate(0.001);
	
	ModuleForce = modulus(HFor);

	Force = [ HFor[0] , HFor[1] , HFor[2] ];

	if(pov==2)
	{
		for(var i=0;i<3;i++)
			for(var j=0;j<3;j++)
				Htemp[i] += Rrot_t[j+(i*3)]*Force[j];
		for(var i=0;i<3;i++)	Force[i]=Htemp[i];
	}
	
	#ifdef DEV_NET
		if (isForceEnabled)
		{
				Force[0]=Force[0];
				Force[1]=Force[1];
				Force[2]=Force[2];
		}
		else
		{
			Force = [0.0,0.0,0.0];
		}
		
		Dev.ApplyForce(Force);   
		/*
			Multifunction_Code		...
			Resetta					Reset the encoders
			Runna					Run the device
			Stoppa					Stop the device
			Spengi					Turn off the device
			GravityComp				Define the gravity contribution to sustain the arm (only for exos)
			EmergencyStop			Stop the executing task
			Unpause					Esc to the PAUSE state during the task
			AppCode					Code to identify the application
			SaveStop				Code to put exos in pause to wait for saving data (REACHING)
		*/
		Command = [ Multifunction_Code , Resetta , Runna , Stoppa , Spengi, GravityComp, EmergencyStop, Unpause, AppCode, weight[0], weight[1], weight[2],weight[3], kp[0], kp[1], kp[2], kp[3], BodyMass, damper, handle_on,  forcecontrol_flag ];
		Dev.ApplyCommand(Command);
		Dev.SendDataToDevice();
	#endif
	
	
	
	
	
			#ifdef DEV_TRACKHOLD
	 		
#ifdef TRACKHOLD20
#endif
				
#ifdef ALEX10_INTERFACE
			ALEX10.Dev_DataOut.Force[0] = Force[0];
			ALEX10.Dev_DataOut.Force[1] = Force[1];
			ALEX10.Dev_DataOut.Force[2] = Force[2];
			ALEX10.Dev_DataOut.Counter = 0;
			
//			ALEX10.Dev_DataOut.Force[0] = 1.0+11;
//			ALEX10.Dev_DataOut.Force[1] = 2.0+12;
//			ALEX10.Dev_DataOut.Force[2] = 3.0+13;
			
			ALEX10.Base.DLL.DEV_INTERFACE_Set_Command_DataOut(ALEX10.Base.Driver_Command.SharedMemory_ID, COM_START);	
			ALEX10.UpDate_DataOut();
			
//			var BUBU = ALEX10.Dev_DataOut.Force;
//			trace(BUBU);
			
			
#endif
	
	#endif
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	#ifdef LOG_DATA
	if (LogInitialized)
	{
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		LogTime = GetTime();
		LogDataCounter++;
		if ((LogDataCounter == LogDataDecimation))
		{
			
			LogDataCounter = 0;
			DataToBeLogged[0] = LogTime;
			DataToBeLogged[1] = pos[0];
			DataToBeLogged[2] = pos[1];
			DataToBeLogged[3] = pos[2];
			DataToBeLogged[4] = isgrabbed;
			DataToBeLogged[5] = sel_obj;
			DataToBeLogged[6] = HiForces[0];
			DataToBeLogged[7] = HiForces[1];
			DataToBeLogged[8] = HiForces[2];
			DataToBeLogged[9] = mat_obj;
			DataToBeLogged[10] = Force[0];
			DataToBeLogged[11] = Force[1];
			DataToBeLogged[12] = Force[2];
			DataToBeLogged[13] = HiJointPos[0];
			DataToBeLogged[14] = HiJointPos[1];
			DataToBeLogged[15] = HiJointPos[2];
			DataToBeLogged[16] = HiJointPos[3];
			DataToBeLogged[17] = HiGrasp[1];	//Sx
			DataToBeLogged[18] = HiGrasp[0];	//Dx
			DataToBeLogged[19] = total_time;
			DataToBeLogged[20] = scale;
			DataToBeLogged[21] = Hoff;
			DataToBeLogged[22] = Voff;
			DataToBeLogged[23] = Doff;
			DataToBeLogged[24] = BodyMass;
			DataToBeLogged[25] = GravityComp;
			DataToBeLogged[26] = damper;


			DLL_LogData.XVR_LOG_StoreData(DataToBeLogged);
		}
	//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	}
	#endif


}





function OnExit()
{
	#ifdef DEV_TRACKHOLD


#ifdef TRACKHOLD20	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TH20_OnExit();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif

#ifdef ALEX10_INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// TRACKHOLD INTERFACE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ALEX10.OnExit();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif


	#endif
						#ifndef DEV_TRACKHOLD
	senddata(sprintf("APP,%f",-1));	// SEND EXIT COMMAND TO GUI IF ESC PRESSED
#endif
	outputln("EXIT");
	PhysXVR.ShutDown();
}




//Checks if a cursor touch a cube
function grabbed()
{
	var touchedCube1 = vector(32);
	var touchedCube2 = vector(32);
	var n1 = vector(1);
	var n2 = vector(1);
	var force = vector(3);
	
	//	if(PhysXVR.getCollision(sfera1.GetActor(), &n1, &touchedCube1, &force) != 0 
	//	||	   PhysXVR.getCollision(sfera2.GetActor(), &n2, &touchedCube2, &force) != 0){
	if(PhysXVR.getCollision(sfera1.GetActor(), &n1, &touchedCube1, &force) != 0 )		return true;

	return false;
}



// Throw the grabbed cube automatically in the basket
function ThrowBasket()
{

	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();

			if(i==sel_obj-1)
			{
				if(pov==2)
				{
					#ifdef __DEBUG
					outputln("POS CUBO = ",cubePos);
					#endif
					
					// DEFINE THE LIMIT WHERE THROWING THE CUBE
					if( (cubePos[0]<centerpuzzle[0]+BASKET_LIMITX*CUBE_SIZE)&&(cubePos[0]>centerpuzzle[0]-BASKET_LIMITX*CUBE_SIZE) )
					{
					
						if( (cubePos[2]<centerpuzzle[2]+BASKET_LIMITZ*CUBE_SIZE)&&(cubePos[2]>centerpuzzle[2]-BASKET_LIMITZ*CUBE_SIZE) )
						{
									
							if (modul(ddSx)<MAXSPEEDFORTHROW)
							{
									m_cube[i].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
//									m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
									o_cube[i].LinkToMesh(m_cube[i]);
									mat_obj = sel_obj;
									sel_obj = 0;
									#ifdef __DEBUG
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									aadd(matched_cubes,mat_obj);
									for(var j=0; j<len(free_cubes); j++)
										if(free_cubes[j]==mat_obj)
											adel(free_cubes,j);
									PhysXVR.disableCollision(0,mat_obj);
									//PhysXVR.disableCollision(floor_colgr,mat_obj); //PIPPO
									for(var j=1; j<=NUM_CUBES; j++)
										PhysXVR.disableCollision(mat_obj,j);
									o_cube[i].setvisible(false);//false
									#ifdef __DEBUG
									outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									SoundFX[SFX_DROP].Play();
									grasp_on=0;	// RELEASE CUBE
							}	//end ifv
						}	//end ifcubepos2
					}	//end ifcubepos0
				}	//end ifview2
			}	//end ifsel_obj
		}	//end ifo_cube

}






//Moves the cube to the nearest position
//if it's in the right place plays a sound and makes the cube inamovable
function attachCube(view)
{
	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			if(i==sel_obj-1)
			{
				if(view==3)
				{
					var y,x;
					for(y=1;y<=3;y++)
					{
						for(x=-1;x<=1;x++)
						{
							mod = modulus(cubePos-[x,y,0]*CUBE_SIZE);
							if((mod > CUBE_SIZE/10) && (mod < CUBE_SIZE/3)){
								if(x == i%3-1 && y == (8-i)/3+1 ){
									o_cube[i].setPosition([x,y,0]*CUBE_SIZE);
									o_cube[i].setRotation(0, [1.0,0.0,0.0]);
									m_cube[i].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
//									m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
									o_cube[i].LinkToMesh(m_cube[i]);
									cube_grid[i*2] = x;
									cube_grid[i*2+1] = y;
									o_cube[i].makeKinematic();
									mat_obj = sel_obj;
									sel_obj = 0;
									#ifdef __DEBUG
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									aadd(matched_cubes,mat_obj);
									for(var j=0; j<len(free_cubes); j++)
										if(free_cubes[j]==mat_obj)
											adel(free_cubes,j);
									SoundFX[SFX_CLACK].Play();
									PhysXVR.disableCollision(0,mat_obj);
									for(var j=0; j<NUM_CUBES; j++)
										PhysXVR.disableCollision(mat_obj,j+1);
									#ifdef __DEBUG
									outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									grasp_on=0;	// RELEASE CUBE
								}	//end ifxy
							}	//end ifmod
							if(grasp_on==0)	break;
						}	// end forx
						if(grasp_on==0)	break;
					}	//end fory
				}	//end ifview3
					
					
				if(view==2)
				{
					var z,x;
					for(z=-1;z<=1;z++)
					{
						for(x=-1;x<=1;x++)
						{
							// CHECK THE DISTANCE BETWEEN PROXY AND CENTER OF CUBE TO BE GRASPED
							mod = modulus(cubePos-[x,1,z]*CUBE_SIZE);
							if((mod > CUBE_SIZE/10) && (mod < CUBE_SIZE/2))
							{
								if( x == i%3-1 && z == 1-floor((8-i)/3) )
								{
									o_cube[i].setPosition([x,0.95,z]*CUBE_SIZE);// + [0,cubePos[1],0]);
								        m_cube[i].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
//									m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
									o_cube[i].LinkToMesh(m_cube[i]);
									cube_grid[i*2] = x;
									cube_grid[i*2+1] = z;
									o_cube[i].makeKinematic();
									mat_obj = sel_obj;
									sel_obj = 0;
									#ifdef __DEBUG
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									aadd(matched_cubes,mat_obj);
									for(var j=0; j<len(free_cubes); j++)
										if(free_cubes[j]==mat_obj)
											adel(free_cubes,j);
											
									SoundFX[SFX_CLACK].Play();
									PhysXVR.disableCollision(0,mat_obj);
									for(var j=0; j<NUM_CUBES; j++)
										PhysXVR.disableCollision(mat_obj,j+1);
									#ifdef __DEBUG
									outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
									outputln("MATCH=",matched_cubes);
									outputln("FREE=",free_cubes);
									#endif
									grasp_on=0;	// RELEASE CUBE
								} //end ifxy
							} //end ifmod
							if(grasp_on==0)	break;
						}// end forx
						if(grasp_on==0)	break;
					}// end forz
				}//end ifview2
										
			}//end ifmodv
		}//end ifo_cube
		
} //end function attachCube





// Attach the cube to the nearest grid-clock position
// if it's in the right place plays a sound and makes the cube inamovable
function attachClock()
{
	var i=sel_obj-1;	// SELECTED CUBE

	#ifdef __DEBUG2
	outputln(" ***** SEL=",i);
	#endif
	if (( i!=-1 )&&( o_cube[i].type==PHX_DYNAMIC ))
	{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			// MODULUS OF DISTANCE BETWEEN SELECTED CUBE AND ITS RIGHT CLOCK POSITION
			mod = modulus(cubePos - [ clock_position[i][0],CUBE_SIZE,clock_position[i][2] ] );
			#ifdef __DEBUG2
			outputln(" ***** TARGET POS =",clock_position[i]);
			outputln(" ***** CUBE POS =",cubePos);
			outputln(" ***** DIST =",mod);
			#endif
			// IF CUBE IS CLOSE TO THE RIGHT POSITION...
			if((mod > CUBE_SIZE/10) && (mod < CUBE_SIZE/2))
			{
					o_cube[i].setPosition([ clock_position[i][0],CUBE_SIZE,clock_position[i][2] ]);
					m_cube[i].ModulateSubsetMaterial(1,[1.0,1.0,1.0]);
					//m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
					o_cube[i].LinkToMesh(m_cube[i]);
					o_cube[i].makeKinematic();
					o_cube[i].setgravity(false);
					o_cube[i].setvisible(true);
					mat_obj = sel_obj;
					sel_obj = 0;
					#ifdef __DEBUG2
					outputln("MATCH=",matched_cubes);
					outputln("FREE=",free_cubes);
					#endif
					aadd(matched_cubes,mat_obj);
					for(var j=0; j<len(free_cubes); j++)
						if(free_cubes[j]==mat_obj)
							adel(free_cubes,j);
					SoundFX[SFX_CLACK].Play();
					PhysXVR.disableCollision(0,mat_obj);	// DISABLE COLLISION WITH PROXY
					// DISABLE COLLISION WITH THE OTHER CUBES
					for(var j=0; j<NUM_CUBES; j++)
						PhysXVR.disableCollision(mat_obj,j+1);
					#ifdef __DEBUG
					outputln("********************* DISABLED GRASP ON CUBE ",mat_obj);
					outputln("MATCH=",matched_cubes);
					outputln("FREE=",free_cubes);
					#endif
					grasp_on=0;	// RELEASE CUBE
			} //end ifmod
			if(grasp_on==0)
			{
				#ifdef __DEBUG
				outputln("LOADING NEXT CUBE...");
				#endif
				LoadCube();
				break;
			}
	}//end ifo_cube
		
} //end function attachClock







function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false;				
	static var PrecX = 0, PrecY = 0;			

	if (Mouse.ButtonL)
	{
		if (InMouseL)
		{	
			CameraRotate((Mouse.X - PrecX) / 100.0, 0, 1, 0);
			CamPos = CameraGetPosition();
			CamDir = CameraGetDirection(); 
			CamPos = CamPos - CamDir*((Mouse.Y - PrecY) / 100.0);
			CameraSetPosition(CamPos*1);
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseL = true;		
	}
	else
		InMouseL = false;

	if (Mouse.ButtonR)
	{
		if (InMouseR)
		{
			CamPos = CameraGetPosition();
			CamPos[1] = CamPos[1] + (PrecY - Mouse.Y) / 100.0;
			CameraSetPosition( CamPos*1 );
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseR = true;
	}
	else
		InMouseR = false;

}


#define CAMERA_SPEED 0.97//0.97
#define CAMERA_DIST  0.05
#define CAMERA_ROT	0.96//0.94
#define ALPHA_TOL	0.002
#define TARGET_SPEED 0.95//0.95
#define TARGET_DIST  0.0001
#define ALPHAOFF	0.0
/****************************************/
/*		  	    MoveCameraTo			*/
/****************************************/
function MoveCameraTo(x,y,z,startangle)
{
	var temp;
	var dist;
	var camdir;
	var axis;
	var speed=CAMERA_SPEED;
	var alphaspeed=CAMERA_ROT;
	static var alpha=0;

	if(pov==3)	temp=CameraGetPosition();
	if(pov==2)
	{
		temp=CameraGetPosition();
		camdir=Cameragetdirection();
		// UPDATING ORIENTATION (ONLY FOR 2D)...
		if(abs(startangle)>0.0)	alpha = (startangle+ALPHAOFF) - ( (startangle+ALPHAOFF) - alpha )*alphaspeed;
	}
	
	// UPDATING POSITION...
	temp[0] = x - (x-temp[0])*speed;
	temp[1] = y - (y-temp[1])*speed;
	temp[2] = z - (z-temp[2])*speed;

	dist=((temp[0]-x)^2)+((temp[1]-y)^2)+((temp[2]-z)^2);
	if(pov==3)	CameraSetPosition(temp);
	if(pov==2)
	{
		if(dist>=CAMERA_DIST)	CameraSetPosition(temp);
		if(abs(startangle)>0.0)
		{
			CameraFree();
			CameraRotate(alpha,-camdir);
		}
	}
	//outputln("DISTANCE: ",dist," < ",CAMERA_DIST);
	if(dist<CAMERA_DIST) 
	{
		//outputln("ANGLE :",abs(startangle+ALPHAOFF-alpha)," < ",ALPHA_TOL);
		if( ((abs(startangle)>0.0)&&(abs(startangle+ALPHAOFF-alpha)<ALPHA_TOL)) || (abs(startangle)==0.0))
		{
				return 1;
		}
		else return 0;
	}
	else return 0;
}




/****************************************/
/*		      MoveCameraTarget			*/
/****************************************/
function MoveCameraTarget(x,y,z)
{
	var dist;
	var speed=TARGET_SPEED;

	camTarget[0]=camTarget[0]*speed+x*(1.0-speed);
	camTarget[1]=camTarget[1]*speed+y*(1.0-speed);
	camTarget[2]=camTarget[2]*speed+z*(1.0-speed);
	if(pov==2)	CameraSetTarget(camTarget);//Camera.SetTarget(camTarget);
	if(pov==3)	CameraSetTarget(camTarget);
	
	dist=((camTarget[0]-x)^2)+((camTarget[1]-y)^2)+((camTarget[2]-z)^2);
	if(dist<TARGET_DIST) 
	{
		return 1;	
	}
	else return 0;
}





//Check if all cubes are in the right position
function CheckFinale()
{
	if (pov==3)
		if (cube_grid[0]  == -1 && cube_grid[1]  == 3 &&
			cube_grid[2]  ==  0 && cube_grid[3]  == 3 &&
			cube_grid[4]  ==  1 && cube_grid[5]  == 3 &&
			cube_grid[6]  == -1 && cube_grid[7]  == 2 &&
			cube_grid[8]  ==  0 && cube_grid[9]  == 2 &&
			cube_grid[10] ==  1 && cube_grid[11] == 2 &&
			cube_grid[12] == -1 && cube_grid[13] == 1 &&
			cube_grid[14] ==  0 && cube_grid[15] == 1 &&
			cube_grid[16] ==  1 && cube_grid[17] == 1)
			return true;
		else
		return false;
	
	if (pov==2)
		if(len(free_cubes)==0) 	
		{
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;	// RELEASE CUBE
			return true;
		}
		else
		return false;
	
}







function ManageCollision()
{
	var init_radius;
	var init_ang;

	init_radius = CIRCLE_RADIUS*CUBE_SIZE;
	
	if(session=="Clock")
	{
		for (var j=0;j<NUM_CUBES;j++)
		{
			// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				//PhysXVR.enableCollision(floor_colgr,i+1);
				PhysXVR.disableCollision(1,j+1);	// COLLISION AMONG FIRST AND ALL OTHER CUBES
				PhysXVR.disableCollision(0,j+1);	// COLLISION AMONG PROXY AND ALL OTHER CUBES
			}
		}
	}
	else
	{
		for (var j=0;j<NUM_CUBES;j++)
		{
			PhysXVR.enableCollision(floor_colgr,j+1);
			PhysXVR.enableCollision(0,j+1);
			for (var k=j;k<NUM_CUBES;k++)
				PhysXVR.enableCollision(j,k+1);
		}
		
		if(on_session[2]==1)
		{
			init_ang = 0;
			for(var j=NUM_CUBES; j<NUM_CUBES+3; j++)
			{
				cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*CUBE_SIZE, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
				o_cube[j].SetPosition(cube_position[j]);
				o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
				init_ang = init_ang - 2*PI/12;
			}
		}
		
	}

}




function InitPositions()
{
	var i,j;
	
	if(POV==3)
	{
		for (j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
				
				if (j < NUM_CUBES/2)
				{
					cube_grid[i*2]   = -scalaX;
			    	cube_grid[i*2+1] =  j+1;
				}
				else
				{   
					cube_grid[i*2]   =  scalaX;
			    	cube_grid[i*2+1] =  9-j;
				}
		
			cube_position[i] = CUBE_SIZE * [cube_grid[i*2], cube_grid[i*2+1], 0.15];
			o_cube[i].SetPosition(cube_position[i]);
		}
	}

	var init_radius;
	var init_ang;
	//var CenterPuzzle = [0.0, 0.0, (CUBE_SIZE*3+0.15)/2 ];
	// scalaX = 3
	if(POV==2)
	{
		if(session=="Clock")
		{
			init_radius = CIRCLE_RADIUS*CUBE_SIZE;
			init_ang = PI - 2*PI/12;
		
			// DEFINE A GRID FOR THE POSITION OF CUBES AT THE CLOCK NUMBERS
			for (j=0;j<NUM_CUBES;j++)
			{
				// INIT THE CUBEGRID FOR THE FINAL CHECK 
				cube_grid[j*2] = 0.0;
				cube_grid[j*2+1] = 0.0;
				
				clock_position[j] = [ init_radius*sin(init_ang), 0.2*CUBE_SIZE, init_radius*cos(init_ang) ] + CenterPuzzle;
				// INIT THE VIRTUAL CUBES OF CLOCK (FOR DEBUG)
				v_cube[j].SetPosition(clock_position[j]);
				v_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
				
				// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
				if(j==0)
					cube_position[j] = [ 0.0, 0.0, 0.0 ] + CenterPuzzle;
				else
					cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*CUBE_SIZE, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
				
				o_cube[j].SetPosition(cube_position[j]);
				o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
				init_ang = init_ang - 2*PI/12;
			}
			//outputln(cube_grid);
			outputln("++++++++++++++++++++++++++++++");	
			for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
			for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
			for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
			outputln("++++++++++++++++++++++++++++++");	
		
		}
		else
		{
		
			init_radius = CIRCLE_RADIUS*CUBE_SIZE;
			init_ang = 0;
			for (j=0;j<NUM_CUBES;j++)
			{
				i = IniGrid[j];
				// INIT THE CUBEGRID FOR FINAL CHECK 
				cube_grid[i*2] = 0;
				cube_grid[i*2+1] = 0;
				// THE CUBE_GRID REPRESENTS ONLY A INITIAL VIRTUAL DISPLACEMENT OF THE CUBES
				// THE SAME USED IN THE 3D VIEW
				cube_position[i] = [ init_radius*sin(init_ang), 0.0, init_radius*cos(init_ang) ] + CenterPuzzle;
				o_cube[j].setvisible(true);
				/*
				PhysXVR.enableCollision(floor_colgr,i+1);
				PhysXVR.enableCollision(0,j+1);
				for (var k=1;k<NUM_CUBES;k++)
					PhysXVR.enableCollision(1,k+1);
				*/
				o_cube[i].SetPosition(cube_position[i]);
				o_cube[i].SetRotation(-90,[1.0,0.0,0.0]);
				init_ang = init_ang + 2*PI/9;
			}
			
			outputln("++++++++++++++++++++++++++++++");	
			for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
			for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
			for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
			outputln("++++++++++++++++++++++++++++++");	
			
			
		}

	}
}





function DrawPolygon(my_texture,fromx,tox,fromy,toy,z)
{
	SetActiveTexture(my_texture);//,0,3);
	glDisable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glBegin(GL_QUADS);
		
		glTexCoord(1,0);
		glVertex(tox, toy, z);	
				
		glTexCoord(0,0);
		glVertex(fromx, toy, z);	
					
		glTexCoord(0,1);
		glVertex(fromx, fromy, z);	
					
		glTexCoord(1,1);
		glVertex(tox, fromy, z);	
	glEnd();

	glDisable(GL_TEXTURE_2D);
	
	glColor(0.61,0.1,0.12);
	glBegin(GL_QUADS);		
		glVertex(tox  +0.005, toy  +0.005, z-0.0025);					
		glVertex(fromx-0.005, toy  +0.005, z-0.0025);	
		glVertex(fromx-0.005, fromy-0.005, z-0.0025);	
		glVertex(tox  +0.005, fromy-0.005, z-0.0025);	
	glEnd();

	glEnable(GL_LIGHTING);
}



function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y)
{
	SetActiveTexture(my_texture);//,0,3);
	glDisable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glRotate(0.0,0.0,1.0,0.0);
	glBegin(GL_QUADS);
		
		glTexCoord(1,0);
		glVertex(tox, y, toz);	
				
		glTexCoord(0,0);
		glVertex(fromx, y, toz);	
					
		glTexCoord(0,1);
		glVertex(fromx, y, fromz);	
					
		glTexCoord(1,1);
		glVertex(tox, y, fromz);	
	glEnd();

	glDisable(GL_TEXTURE_2D);
	
	glColor(0.61,0.1,0.12);
	glBegin(GL_QUADS);		
		glVertex(tox  +0.005, y-0.0025, toz  +0.005);					
		glVertex(fromx-0.005, y-0.0025, toz  +0.005);	
		glVertex(fromx-0.005, y-0.0025, fromz-0.005);	
		glVertex(tox  +0.005, y-0.0025, fromz-0.005);	
	glEnd();
	glEnable(GL_LIGHTING);
}




function DrawGrid()
{
	var i;
	var size = CUBE_SIZE;
	glLineWidth(1);
	
//	glDisable(GL_LIGHTING);
	glBegin(GL_QUADS);
	for(i = -1; i<= 1; i++){
		glColor(0.7-i*0.3, 0.7-i*0.3, 0.7-i*0.3);
		glVertex(+size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2);
		glVertex(-size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2);
		glVertex(-size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2+size);
		glVertex(+size/2 + i *size, CUBE_SIZE/2 + 0.001, -CUBE_SIZE/2+size);
	}
	glEnd();
}






function DrawLine(pos1,pos2,r,g,b)
{
	glLineWidth(5);
	glColor(r, g, b);
	glEnable(GL_BLEND);
	glDisable(GL_LIGHTING);
	glBegin(GL_LINES);
	
		glVertex(pos1[0], pos1[1], pos1[2]);
		glVertex(pos2[0], pos2[1], pos2[2]);
	
	glEnd();
	glEnable(GL_LIGHTING);
	glDisable(GL_BLEND);
}






#ifdef LOG_DATA
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
function LogDataInit()
{

	// fileExist COMMAND AND XVRGLUT NEED RELATIVE PATH
	var i=1;
	SetLocalDir(".");
	nomefile = sprintf("Log\\%s\\%s_%s_%s_1_1.%s",paziente,paziente,date,puzzle,file_ext);
	outputln(nomefile," EXIST? ",fileExist(nomefile));
	
	while( fileExist(nomefile) ){
		i=i+1;
		nomefile = sprintf("Log\\%s\\%s_%s_%s_%d_1.%s",paziente,paziente,date,puzzle,i,file_ext);
		outputln("Index: ",i,"  File: ",nomefile);
		outputln(nomefile," EXIST? ",fileExist(nomefile));
	}

	// DELETE GetScriptDir() IF OPEN WITH XVRGLUT
	DLL_LogData.XVR_LOG_Init(BufferNum,BufferSize,GetScriptDir()+sprintf("Log\\%s\\%s_%s_%s_%d",paziente,paziente,date,puzzle,i));
	
	for(var i = 1; i <= BufferNum; i++)
		DLL_LogData.XVR_LOG_SetFormat(i,"8.4f");


	DLL_LogData.XVR_LOG_ApplyLabel(1,"Counter");
	DLL_LogData.XVR_LOG_ApplyLabel(2,"PosX");
	DLL_LogData.XVR_LOG_ApplyLabel(3,"PosY");
	DLL_LogData.XVR_LOG_ApplyLabel(4,"PosZ");
	DLL_LogData.XVR_LOG_ApplyLabel(5,"Grabbed");
	DLL_LogData.XVR_LOG_ApplyLabel(6,"Obj");
	DLL_LogData.XVR_LOG_ApplyLabel(7,"FsX");
	DLL_LogData.XVR_LOG_ApplyLabel(8,"FsY");
	DLL_LogData.XVR_LOG_ApplyLabel(9,"FsZ");
	DLL_LogData.XVR_LOG_ApplyLabel(10,"Matched");
	DLL_LogData.XVR_LOG_ApplyLabel(11,"FvX");
	DLL_LogData.XVR_LOG_ApplyLabel(12,"FvY");
	DLL_LogData.XVR_LOG_ApplyLabel(13,"FvZ");
	DLL_LogData.XVR_LOG_ApplyLabel(14,"q1");
	DLL_LogData.XVR_LOG_ApplyLabel(15,"q2");
	DLL_LogData.XVR_LOG_ApplyLabel(16,"q3");
	DLL_LogData.XVR_LOG_ApplyLabel(17,"q4");
	DLL_LogData.XVR_LOG_ApplyLabel(18,"GraspSx");
	DLL_LogData.XVR_LOG_ApplyLabel(19,"GraspDx");
	DLL_LogData.XVR_LOG_ApplyLabel(20,"TotTime");
	DLL_LogData.XVR_LOG_ApplyLabel(21,"Scale");
	DLL_LogData.XVR_LOG_ApplyLabel(22,"H");
	DLL_LogData.XVR_LOG_ApplyLabel(23,"V");
	DLL_LogData.XVR_LOG_ApplyLabel(24,"D");
	DLL_LogData.XVR_LOG_ApplyLabel(25,"GravComp");
	DLL_LogData.XVR_LOG_ApplyLabel(26,"BodyMass");
	DLL_LogData.XVR_LOG_ApplyLabel(27,"Viscosity");
	DLL_LogData.XVR_LOG_SetLogStyle(LOG_STYLE);		//"ASCII" or "MATLAB"
	DLL_LogData.XVR_LOG_ApplyTitle(1,"Demo Cubes");
	DLL_LogData.XVR_LOG_ApplyTimeLabel(0,"=",0.1,100);
	DLL_LogData.XVR_LOG_ApplyTimeData(1);
	//DLL_LogData.XVR_LOG_SetMetadata("device",device);
	DLL_LogData.XVR_LOG_ResetTimer();


}
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#endif





var checktime = 0.0;
var checktime0 = 0.0;

// simple receiver on udp port, eat all data
function ReceiveData(UDP_Channel)
{
//	checktime0 = gettime();
	while(true)
	{
		var address;
		var data = NetVarReceiveFrom(UDP_Channel, &address);
		if(data != Void) {
			#ifdef __DEBUG_GUI
			OutputLN("Received ",data," from ",address);
			#endif
			ProcessData(data);
		}
		else
			break;
	}
//	checktime = gettime()-checktime0;
//	outputln("TIME TAKEN TO REC FROM GUI = ",checktime);
}



// simple sender on udp port, eat all data
function SendData(data)
{
		NetVarSendTo("127.0.0.1", GUI_port, data);
}



// Processes all instructions that are received from the UDP channel
function ProcessData(data)
{
	static var GravityPercentage=0.0;
	
	#ifdef __DEBUG_GUI
	outputln("++++++++++++++ DATA FROM GUI ++++++++++++++++++++");
	#endif

	// COMMAND TO CLOSE APPLICATION
	if(data[0] == "CloseApp") {
		application.quit();
		outputln("QUIT");
	}


	// COMMAND TO START AND STOP LOGGING DATA
	#ifdef LOG_DATA
		if(data[0] == "NewLog")
		{
			oldpatient = paziente;
			paziente = data[1];
			reqscore=false;
			scoreloaded=false;
		}
		
	// IT CAN BE STOPPED AUTOMATICALLY AT THE COMPLETION OF SELECTED TRIALS, OR MANUALLY FROM GUI
		if(data[0] == "StopLog")
		{
			StopLog = true;
			startedtask=false;
			//outputln("Rec Stop");
		}
	#endif




// COMMAND TO LOAD THE PUZZLE
	if((session!="Clock")&&(data[0]=="PUZ"))
	{
		outputln(data[1]);
		if(data[1]=="Random")
		{
	 		puzzle=immagini[rand(len(immagini)-1)];
	 		ReloadPuzzle();
		}
		else
		{
			puzzle=data[1];
			ReloadPuzzle();
		}
		/*
		switch(data[0])
		{
			case "Haring":
			 		puzzle=immagini[0]; ReloadPuzzle();break;
			case "Numbers":
			 		puzzle=immagini[1]; ReloadPuzzle();break;
			case "Foca": 
					puzzle=immagini[2]; ReloadPuzzle();break;
			case "Spade":
			 		puzzle=immagini[3]; ReloadPuzzle();break;
			case "Grape":
			 		puzzle=immagini[4]; ReloadPuzzle();break;
			case "Italy":
			 		puzzle=immagini[5]; ReloadPuzzle();break;
			case "Mini":
			 		puzzle=immagini[6]; ReloadPuzzle();break;
			case "Random":
		}*/
		temp_puzzle = puzzle;
	}	


	prev_session = session;
	switch(data[0])
	{
		case "Basket":		// SWITCH TO BASKET SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			on_session[1]=1;
			temp_puzzle = puzzle;
			puzzle="basket";
			ReloadPuzzle();
			stato=INTRO_;
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			InitPositions();
			StopLog = false;//true;
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Puzzle":			// SWITCH TO PUZZLE SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			SetIniGrid();
			puzzle = temp_puzzle;	// LOAD THE PREVIOUS PUZZLE (BEFORE TO LOAD CLOCK OR BASKET)
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			StopLog = false;//true;
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Clock":			// SWITCH TO CLOCK SESSION
			session = data[0];
			NUM_CUBES=12;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9,10,11,12};
			total_time = 0.0;
			temp_puzzle = puzzle;
			puzzle = "clock";
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			StopLog = false;//true;
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
	}
	
// ============== SELECT THE GRASPING THRESHOLD ==============
	if(data[0] == "ChangeGrasp")
	{
		GRASP_THRESHOLD = data[1];
	}
// ===========================================================


// ============== SELECT THE DAMPING FACTOR ==============
	if(data[0] == "ChangeDamper") 
	{
		damper = data[1];	// DAMPING FACTOR
	}
// ===========================================================



// ============== RECEIVE SCORE DATA ==============
	if((data[0]=="SCORE")&&(!scoreloaded))
	{
		scores = data[1];
		scoreloaded = true;
	}
// ====================================================


// ============== PLOT DATA ==============
	if((data[0]=="PlotData")&&(stato==INTRO_))
	{
		plotdataon = !plotdataon;
	}
// ====================================================


// ============== COMMAND TO ENABLE FORCE ==============
	if(data[0] == "ForceOn")
	{
	    isForceEnabled=!isForceEnabled;
	}
	if(isForceEnabled)	ForceStatus=1;
	else				ForceStatus=0;
// ====================================================



// ============== COMMAND TO ENABLE CLOSE CONTROL FORCE OR FEEDFORWARD FRICTION MODEL ==============
	if(data[0] == "Compensation")
	{
		forcecontrol_flag = data[1];	
	}
// ====================================================


// ============== PATIENTS LIST FEEDBACK ==============
// Protocol: <"Patients",size,nome[0],nome[1],...,nome[size-1]>
//			 < data[0],data[1],data[2],....>
	if(data[0] == "Patients")
	{
		for (var j=0;j<data[1];j++)		aadd(lista_pazienti,data[j+2]);
	}
// ====================================================


// ========== SCALE & REPLACEMENT COMMANDS ============
// CHANGE ONLY IF FORCE IS DISABLED
	if(data[0] == "ChangeScale")
	{
			Scale = data[1];
			//if(Scale < 2.0)		Scale = 2.0;   // OKKIO ... ATTIVO IN DEMOLEXOS
			//if(Scale > 5.0)		Scale = 5.0;
	}
	if(data[0] == "ChangeHoriz")
	{
			Hoff = data[1];
	}
	if(data[0] == "ChangeVert")
	{
			Voff = data[1];
	}
	if(data[0] == "ChangeDepth")
	{
			Doff = data[1];
	}

// ====================================================


// ========== GRAVITY COMPENSATION COMMAND ============
	if(data[0] == "ChangeBodyMass") {
		BodyMass = data[1];
		if(BodyMass < 30.0)	BodyMass = 30.0;
		if(BodyMass > 120.0)	BodyMass = 120.0;
	}

	if(data[0] == "ChangeGravityCompensation") {
		GravityPercentage = 0.01*data[1];
		if(GravityPercentage < 0.0)
			GravityPercentage = 0.0;
	}

	if(data[0] == "GravCompOn") {
		GravityOn = 1.0;
	}
	if(data[0] == "GravCompOff") {
		GravityOn = 0.0;
	}

	GravityComp = GravityOn * GravityPercentage;
// ===============================================


// ================DEVICE COMMAND=================
	Resetta = 0;
	Stoppa = 0;
	Runna = 0;
	Spengi = 0;

	if( (data[0] == "ChangeDeviceOff") || KeyPressed("0") )
	{
		Spengi = 1;outputln("OFF DEVICE");
	}
	if( (data[0] == "ChangeDeviceReset")|| KeyPressed("1") ) 
	{
		Resetta = 1;outputln("RESET DEVICE");
	}
	if( (data[0] == "ChangeDeviceStart") || KeyPressed("2") ) 
	{
		Runna = 1;outputln("START DEVICE");
	}
	if( (data[0] == "ChangeDeviceStop") || KeyPressed("3") ) 
	{
		Stoppa = 1;outputln("STOP DEVICE");
	}
// ===============================================


	#ifdef DEV_NET
	Command = [ Multifunction_Code , Resetta , Runna , Stoppa , Spengi, GravityComp, EmergencyStop, Unpause, AppCode, weight[0], weight[1],weight[2],weight[3], kp[0], kp[1], kp[2], kp[3], BodyMass, damper, handle_on, forcecontrol_flag ];
	Dev.ApplyCommand(Command);
	Dev.SendDataToDevice();
	#endif
	#ifdef __DEBUG_GUI
	outputln("++++++++++++++ END GUI ++++++++++++++++++++");
	#endif


}





function disp(x,y,stri,row,col,fontsize,trasparency)
{
	var len_stri=len(stri)*tofloat(fontsize)/3400.0;//*0.016;(fontsize=40)
	var h = tofloat(fontsize)/600.0;
	var xs = x-len_stri/2;
	var ys = y-row*h;
	ConsoleFont("Impact",fontsize);
	ConsoleColor(1.0,1.0,1.0,0.7*trasparency);
	ConsoleFilledRect(xs-0.01, ys+h*5.0/6.0, len_stri+0.0, h);
	// define color
	switch(upper(col))
	{
		case "K":	ConsoleColor(0.0,0.0,0.0,trasparency);break;
		case "R":	ConsoleColor(1.0,0.0,0.0,trasparency);break;
		case "B":	ConsoleColor(0.0,0.0,1.0,trasparency);break;
		case "G":	ConsoleColor(0.0,1.0,0.0,trasparency);break;
		default:	ConsoleColor(1.0,1.0,1.0,trasparency);break;
	}
	//ConsoleColor(1.0,0.0,0.0,1.0);
	Consoletext(xs,ys,stri);

}






function plot(data,title)
{
	var t, w, h, h_1;
	var text;
	var x_0, y_0, x_1; 	// BAR DATA ORIGIN
	var alpha = 0.7;		// TRANSPARENCY
	var red = [1.0,0.0,0.0,alpha];
	var blue = [0.0,0.0,1.0,alpha];
	var green = [0.0,1.0,0.0,alpha];
	var black = [0.0,0.0,0.0,alpha];
	var gray = [0.5,0.5,0.5,alpha];
	var white = [1.0,1.0,1.0,alpha];
	var delta;	// SPACE AMONG BARS
	var wb;		// WIDTH AND HEIGHT OF EACH BAR
	var s;		// b+delta
	var max_label;
	var max_data=0;
	var xlabel="";
	var y_tick = {0.0};
	
	w = 0.6;
	x_0 = 0.6 - w/2;
	y_0 = 0.2;
	h = 0.6;
	h_1 = 0.8*h;
	t = 3;
	s = w / len(data);
	delta = 0.2*s;
	wb = s - delta;//0.9*s;
//	outputln("VALORI = ",data);
	max_data=max(data);
//	var max100=floor(max_data/100);
//	var max10=floor((max_data-max100*100)/10);
//	var	max1=floor((max_data-(max100*100+ma10*10)));
//	outputln("MAX = ",max_data);
	max_label=sprintf("%3.1f",h*max_data/h_1);

	// FILL PLOT
	ConsoleColor(white.r,white.g,white.b,1);
	ConsoleFilledRect(x_0,y_0,w,-h);
	ConsoleWidth(t);


	// DATA LABEL
	var tick = ceil(max_data / 4);

	if(tick>=100)
		tick=ceil(tick/100)*100;
	else
		if(tick>=10)
			tick=ceil(tick/10)*10;
		else
			tick=ceil(tick);


	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleFont("Arial",30);
	for(var i=0;i<6;i++)
	{
		Consoletext( x_0 - len(sprintf("%d",y_tick[i]))*0.025, y_0 +(h_1/max_data*y_tick[i])-0.015, sprintf("%d",y_tick[i]) );
		ConsoleLines( [x_0, y_0, x_0 - 0.01, y_0] );
		if(i>0)
		{
			ConsoleColor(gray.r,gray.g,gray.b,gray.a);
			ConsoleLines( [x_0, y_0 +(h_1/max_data*y_tick[i]), x_0 + w, y_0 +(h_1/max_data*y_tick[i])] );
			ConsoleColor(black.r,black.g,black.b,black.a);
		}
		aadd(y_tick, i*tick);
	}
	if((max_data - y_tick[5])>=tick)
	{
		Consoletext( x_0 - len(max_label)*0.02, y_0 + h - 0.015, max_label);
		ConsoleLines( [x_0, y_0 + (h-0.002), x_0 - 0.01, y_0 + (h-0.002)] );
	}	
	
	
	// PLOT DATA
	ConsoleColor(green.r,green.g,green.b,green.a);
	x_1 = x_0 + delta/2;
	for(var i=0;i<(len(data)-1);i++)
	{
		ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[i]) );
		if( ((wb<0.05)&&((i==0)||(i==4)||(i==9))) || (wb>=0.05) )
		{
			// X LABEL
			ConsoleFont("Arial",30);
			ConsoleColor(black.r,black.g,black.b,black.a);
			xlabel = sprintf("%d",i+1);
			Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);
		}
		ConsoleColor(green.r,green.g,green.b,green.a);
		x_1 = x_1 + wb + delta;
	}
	ConsoleColor(red.r,red.g,red.b,red.a);
	ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[len(data)-1]) );
	// X LABEL
	ConsoleFont("Arial",30);
	ConsoleColor(black.r,black.g,black.b,black.a);
	xlabel = sprintf("%d",len(data));
	Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);



	// BORDER PLOT
	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleRect(x_0,y_0,w,-h);

	// X LABEL
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0 + w/2 - 0.015*len("SESSIONI")/2, y_0 - 0.1, "SESSIONI");

	// Y LABEL
	var x_0label = 0.045;
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0  - (x_0label+0.008)*len("TEMPO"), y_0 + h/2, "TEMPO");
	Consoletext( x_0  - x_0label*len("TOTALE"), y_0 + h/2 - 0.05, "TOTALE");
	Consoletext( x_0  - (x_0label+0.015)*len("(s)"), y_0 + h/2 - 2*0.05, "(s)");

	// TITLE
	if(len(title)>0)
	{
		var fontsize=50;
		ConsoleFont("Arial",fontsize);
		ConsoleColor(red.r,red.g,red.b,1);
		Consoletext( x_0 + w/2 - 0.04*len(title)/2, y_0 + (h+0.05), title);
	}
}




function TaskBar()
{
	
	var dark = [0.5,0.5,0.5];
	var light = [0.8,0.8,0.8];
	var plane = [0.7,0.7,0.7];
	var stri = "";
	var dim;
	var dot=0.0008;
	var x_s = 0;	// X separator
	var x_t = 0;	// X text
	var fonttype = "Impact";
	var fontsize = 25;//25;
//	var wt = fontsize*0.00065;	// Width of a char in normalized coordinates of consoletext
	var wt = fontsize*0.0005;	// Width of a char in normalized coordinates of consoletext
	var h = 0.05;
	// GRASPING
	var ref=GRASP_THRESHOLD;
	var value=Fgrab;
	var maxF=6.0, max=0.1;
	var red=0.0, green=0.0;
	
	ConsoleColor(plane.r,plane.g,plane.b);
	ConsoleWidth(1);
	ConsoleFilledRect(0.0,1.0, 1.0,h);
	
	// SHADOWED BORDER
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([0.0,1.0, 0.0,0.95, 1.0,0.95]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(2);
	ConsoleLines([0.0,1.0, 1.0,1.0, 1.0,0.95]);


	// PHASE NAME
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	if(paziente=="<Paziente>")
		stri = sprintf("Name:%s",session);//puzzle);
	else
		stri = sprintf("%s:%s",paziente,session);//puzzle);
	dim=len(stri)*wt;
	x_t = x_s + wt;
	x_s = x_t + dim + 0.01*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);


	// FORCE FEEDBACK ENABLE
	ConsoleFont(fonttype,fontsize);
	#ifdef DEV_NET
		stri = sprintf("%2.1fN",ModuleForce);//"FORCE";//(F7)";
		if(isForceEnabled)	ConsoleColor(0.3,1.0,0.3,1.0);
		else				ConsoleColor(dark.r,dark.g,dark.b);
	#else
		#ifdef DEV_TRACKHOLD
			ModuleForce=0;
			stri = sprintf("%2.1fN",ModuleForce);//"FORCE";//(F7)";
			ConsoleColor(0.3,1.0,0.3,1.0);
		#else
			ModuleForce=0;
			stri = sprintf("%2.1fN",ModuleForce);//"FORCE";//(F7)";
			if(TRUE)	ConsoleColor(0.3,1.0,0.3,1.0);
			else				ConsoleColor(dark.r,dark.g,dark.b);
		#endif
	#endif
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
//	x_t = x_s + 0.01;		// START POS OF TEXT + FIRST SPACE (0.01)
//	x_s = x_t + dim + 0.01;	// FINISH POS OF TEXT + LAST SPACE (0.01)
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	
	// GRASPING FORCE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = "GRASP";
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.01*wt;
//	x_t = x_s + 0.01;
//	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleFilledRect(x_s,1-10*dot,max,h-20*dot);
	if (ref>1)
	{
		if (value<ref)
		{
			red=1.0;
			green=0.0;
		}
		else
		{
			red=0.0;
			green=1.0;
		}
	}
	else
	{
		red=1.0;
		green=0.0;
	}
	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	ConsoleFilledRect(x_s, 1-10*dot, max/maxF*value, h-20*dot);

	if ((abs(ref)>=0.0)&&(abs(ref)<=maxF))
	{
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(2);
		ConsoleLines([x_s+max/maxF*ref, 1-h+10*dot, x_s+max/maxF*ref, 1-10*dot ]);
	}
	x_s = x_s + max + 0.01;
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);


	// RADIUS
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	if(pov==2)
	{
		// NEED TO CHECK THIS FORMULA
		stri = sprintf("Radius=%2.1fcm",(CIRCLE_RADIUS*CUBE_SIZE/Scale)*50);
// stri = sprintf("Radius=%2.1fcm",(CIRCLE_RADIUS*CUBE_SIZE/3.0)*100*2);   OKKIO ...
	}
	else
	{
		stri = sprintf(" r: -");
	}
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);

	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);

	// BODY MASS - PERCENTAGE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("%1.0f%%OF%2.0fkg",GravityComp*100,BodyMass);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	

	// DAMPER
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("VISC:%1.0fNs/m",damper);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);


	// MATCHED CUBES
	// SPEED
	
	// SPEED
/*	ConsoleFont("Arial",fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	stri = sprintf("SPE %f",modul(ddSx));
	dim=len(stri)*wt;
	x_t = x_s + 0.01;
	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
*/

/*
	// TASK COUNTER
	ConsoleFont("Arial",fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	stri = sprintf("TRI %d/%d",iteration_counter,task_iterations);
	dim=len(stri)*wt;
	x_t = x_s + 0.01;
	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);


	// BOOKSHELF DEPTH
	ConsoleFont("Arial",fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	stri = sprintf("DEP %1.2fm",profondita);
	dim=len(stri)*wt;
	x_t = x_s + 0.01;
	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	
	// MAX SPEED
	ConsoleFont("Arial",fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	stri = sprintf("SPE %1.2fm/s",max_speed);
	dim=len(stri)*wt;
	x_t = x_s + 0.01;
	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);

	// TASK TIME - TASK DISTANCE

	// POSITION ERROR
	ConsoleFont("Arial",fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	stri = sprintf("ERR %1.2fm",error/100);
	dim=len(stri)*wt;
	x_t = x_s + 0.01;
	x_s = x_t + dim + 0.01;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	*/
}


function modul(v)
{
	return sqrt(v[0]^2+v[1]^2+v[2]^2);
}




function Align_Device(p)
{
	var p_out=p;
	
	for(var i=0;i<3;i++)
		for(var j=0;j<3;j++)
			p_out[i] += Rrot[j+(i*3)]*p[j];
			
	return p_out;
}


function Rot_Y(a)
{
	return [cos(a),0,-sin(a),0,0,1,0,0,sin(a),0,cos(a),0,0,0,0,1];
}


function Rot_Z(a)
{
	return [cos(a),-sin(a),0,0,sin(a),cos(a),0,0,0,0,1,0,0,0,0,1];
}


function max(a)
{
	var max=0.0;

	max = a[0];
	for(var i=1;i<len(a);i++)
	{
		if(a[i]>max)
		{
		max = a[i];
		}
	}
	return max;
}





function view_plot()
{
	if(!reqscore) //IF NOT ALREADY REQUESTED...
	{
		senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
		reqscore = true;
		//scoreloaded = false;
	}

	if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
	{
		if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
		{
			//outputln("PLOT");
			plot(scores,"");
		}
		else
		{
			//outputln("TEXT");
			disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
		}
	}
	else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
	{
		//outputln("TEXT");
		disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
	}
}