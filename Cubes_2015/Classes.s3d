#ifndef CLASSES
#define CLASSES

var vectime;
var spoonsize = 0.05;
var ratio;
var replaceStep = 0.06;

class DualFbo
{
	var fboArray;
	var front;
	var back;
	var width;
	var height;
	
	swap();
	getFront();
	getBack();
	getTexture();
	start();
	stop();
};

function DualFbo::DualFbo()
{
	var v = glGet(GL_VIEWPORT);
	width = v[2];
	height = v[3];
	front = 0;
	back = 1;
	var fbo1 = CVmFbo(VR_FBO_COLOR, width, height, GL_RGB);
	var fbo2 = CVmFbo(VR_FBO_COLOR, width, height, GL_RGB);	
	fboArray = {fbo1, fbo2};		
}

function DualFbo::swap()
{
	front = back;
	back = 1 - front;
}

function DualFbo::getFront()
{
	return fboArray[front];
}

function DualFbo::getBack()
{
	return fboArray[back];
}

function DualFbo::getTexture()
{
	return getFront();
}

function DualFbo::start()
{
	return getBack().start();
}

function DualFbo::stop()
{
	return getBack().stop();
}

var commonScreenShader;

class BaseScreen
{
	var vdualfbo;
	var screenShader;
	var lastPos,lastPosUp;
	var updateShader;
	var displayShader;
	var cursorTexture;
	var bottomTexture; // optional
	var mouseMode;
	var vecpos;
	
	update(a_texture);
	display(showCursor);	
};

function BaseScreen::BaseScreen(bottom)
{
	vecpos = [0,0,0];
	mouseMode = true;
	vdualfbo = DualFbo();	
	if(commonScreenShader == Void)
	{
		commonScreenShader = CVmShaderProgram("ScreenShader.sh");
	}
	screenShader = commonScreenShader;
	screenShader.Start();
	screenShader.SetParameter("tex",2);
	screenShader.Stop();
	bottomTexture = bottom;
}

function window2clip(pos,viewport)
{
	return [(2*pos.x/viewport[2])-1,(2*pos.y/viewport[3])-1];
}

function window2tex(pos,viewport)
{
	return [pos.x/viewport[2],pos.y/viewport[3]];
}

function clip2window(pos,viewport)
{
	return [((pos.x+1)*viewport[2]/2),((pos.y+1)*viewport[3]/2)];
}

function tex2window(pos,viewport)
{
	return [pos.x*viewport[2],pos.y*viewport[3]];
}


function BaseScreen::update(a_texture)
{
	var v = glGet(GL_VIEWPORT);
	glPushAttrib(GL_LIGHTING_BIT | GL_TRANSFORM_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);
	vdualfbo.start();
	SceneBegin();	
	
	if(a_texture != Void)
	{
		glEnable(GL_TEXTURE_2D);
		
		glDisable(GL_LIGHTING);
		glDisable(GL_DITHER);
		glDisable(GL_DEPTH_TEST);	
		
		glPolygonMode(GL_FRONT,GL_FILL);
		
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		SetActiveTexture(a_texture,VR_NO_FILTER,2);
		ScreenShader.Start();
		glBegin(GL_QUADS);
			glTexCoord(0.0, 0.0); glVertex(-1.0, -1.0, 0);
			glTexCoord(1.0, 0.0); glVertex(+1.0, -1.0, 0);
			glTexCoord(1.0, 1.0); glVertex(+1.0, +1.0, 0);
			glTexCoord(0.0, 1.0); glVertex(-1.0, +1.0, 0);
		glEnd();	
		ScreenShader.Stop();	
	}
	else
	{
	
		glEnable(GL_TEXTURE_2D);
		
		glDisable(GL_LIGHTING);
		glDisable(GL_DITHER);
		glDisable(GL_DEPTH_TEST);	
		
		glPolygonMode(GL_FRONT,GL_FILL);
		
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glMatrixMode(GL_MODELVIEW);
		SetActiveTexture(vdualfbo.getFront(),VR_NO_FILTER,2);
		ScreenShader.Start();
		glBegin(GL_QUADS);
			glTexCoord(0.0, 0.0); glVertex(-1.0, -1.0, 0);
			glTexCoord(1.0, 0.0); glVertex(+1.0, -1.0, 0);
			glTexCoord(1.0, 1.0); glVertex(+1.0, +1.0, 0);
			glTexCoord(0.0, 1.0); glVertex(-1.0, +1.0, 0);
		glEnd();	
		ScreenShader.Stop();	
		
		if(true)
		{
		// cursor is 0
		// fbo is 1	
		// bottom is 2
		updateShader.start();
		var spongePos =[0,0]; 
		if (mouseMode==true)
		spongePos= window2clip([vecpos.x,vecpos.y],v);
		else
		spongePos=[ (vecpos[0]*9.5)/v[2], (-(vecpos[1]+0.5)*9.5)/v[3]];
		SetActiveTexture(cursorTexture, VR_BILINEAR_FILTER, 0);
		SetActiveTexture(vdualfbo.getFront(), VR_BILINEAR_FILTER, 1);
		if(bottomTexture != Void)
			SetActiveTexture(bottomTexture,VR_NO_FILTER,2);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glDisable(GL_LIGHTING);
		glDisable(GL_DITHER);
		glDisable(GL_DEPTH_TEST);
		glDisable(GL_BLEND);
		
		var xsize = spoonsize;
		var ysize = spoonsize*ratio;
		glPolygonMode(GL_FRONT,GL_FILL);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();		
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		if(lastPosUp == Void)	
			lastPosUp = spongePos;
		var d = modulus(spongePos-lastPosUp);
		var a = 0;
		var dt = d == 0 ? 1 : replaceStep/d; // always ten
		
		for (var a = 0; a < 1; a += dt)
		{
			var pos = lastPosUp*(1-a)+spongePos*a;
			glPushMatrix();
			glTranslate(pos);			
			glBegin(GL_QUADS);
				glTexCoord(0.0, 0.0); glVertex(-xsize, -ysize, 0);
				glTexCoord(1.0, 0.0); glVertex(+xsize, -ysize, 0);
				glTexCoord(1.0, 1.0); glVertex(+xsize, +ysize, 0);
				glTexCoord(0.0, 1.0); glVertex(-xsize, +ysize, 0);		
			glEnd();
			glPopMatrix();
		}
		
		lastPosUp = spongePos;
		glPushMatrix();
		glTranslate(lastPosUp);		
		glBegin(GL_QUADS);
			glTexCoord(0.0, 0.0); glVertex(-xsize, -ysize, 0);
			glTexCoord(1.0, 0.0); glVertex(+xsize, -ysize, 0);
			glTexCoord(1.0, 1.0); glVertex(+xsize, +ysize, 0);
			glTexCoord(0.0, 1.0); glVertex(-xsize, +ysize, 0);		
		glEnd();
		glPopMatrix();
		updateShader.stop();	
		}
	}
	SceneEnd();
	vdualfbo.stop();
		
	glPopAttrib();	
	
	vdualfbo.swap();
}

// cursor is 0
// fbo is 1
function BaseScreen::display(showCursor)
{
	var v = glGet(GL_VIEWPORT);
	glPushAttrib(GL_LIGHTING_BIT | GL_TRANSFORM_BIT | GL_VIEWPORT_BIT| GL_TEXTURE_BIT);
	
	displayShader.start();		
	SetActiveTexture(vdualfbo.getFront(), VR_BILINEAR_FILTER, 1);	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glDisable(GL_LIGHTING);
	glDisable(GL_DITHER);
	glDisable(GL_DEPTH_TEST);
	
	glPolygonMode(GL_FRONT,GL_FILL);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glBegin(GL_QUADS);
		glTexCoord(0.0, 1.0); glVertex(-1.0, -1.0, 0);
		glTexCoord(1.0, 1.0); glVertex(+1.0, -1.0, 0);
		glTexCoord(1.0, 0.0); glVertex(+1.0, +1.0, 0);
		glTexCoord(0.0, 0.0); glVertex(-1.0, +1.0, 0);
	glEnd();
	displayShader.stop();
	
	if(showCursor)
	{
		var spongePos = (mouseMode==true)? window2clip([vecpos.x,v[3]-vecpos.y],v) :[ (vecpos[0]*9.5)/v[2], ((vecpos[1]+0.5)*9.5)/v[3]];
		displayShader.start();		
		SetActiveTexture(cursorTexture, VR_BILINEAR_FILTER, 1);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glDisable(GL_LIGHTING);
		glDisable(GL_DITHER);
		glDisable(GL_DEPTH_TEST);
		glEnable(GL_BLEND);
		
		glPolygonMode(GL_FRONT,GL_FILL);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();		
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		var xsize = spoonsize;
		var ysize = spoonsize*ratio;
		
		if(lastPos == Void)	
			lastPos = spongePos;
		var d = modulus(spongePos-lastPos);
		var a = 0;
		var dt = d == 0 ? 1 : 0.001/d; // always ten
		
		for (var a = 0; a < 1; a += dt)
		{
			var pos = lastPos*(1-a)+spongePos*a;
			glPushMatrix();
			glTranslate(pos);			
			glBegin(GL_QUADS);
				glTexCoord(0.0, 1.0); glVertex(-xsize, -ysize, 0);
				glTexCoord(1.0, 1.0); glVertex(+xsize, -ysize, 0);
				glTexCoord(1.0, 0.0); glVertex(+xsize, +ysize, 0);
				glTexCoord(0.0, 0.0); glVertex(-xsize, +ysize, 0);		
			glEnd();
			glPopMatrix();
		}
		
		
		lastPos = spongePos;
		glPushMatrix();
		glTranslate(lastPos);		
		glBegin(GL_QUADS);
			glTexCoord(0.0, 1.0); glVertex(-xsize, -ysize, 0);
			glTexCoord(1.0, 1.0); glVertex(+xsize, -ysize, 0);
			glTexCoord(1.0, 0.0); glVertex(+xsize, +ysize, 0);
			glTexCoord(0.0, 0.0); glVertex(-xsize, +ysize, 0);		
		glEnd();
		glPopMatrix();
		
		glDisable(GL_BLEND);
		displayShader.stop();
	}

	glPopAttrib();	
}

class  Sponge:BaseScreen
{
	var topTexture;
	
	refreshSponge(sponge, top, bottom);
};

function Sponge::Sponge(sponge, top, bottom)
{
	updateShader = CVmShaderProgram("Pass 0.sh");
	displayShader = CVmShaderProgram("Pass 1.sh");
	var v = glGet(GL_VIEWPORT);
	ratio = v[2]/v[3];
	refreshSponge(sponge, top, bottom);
	displayShader.Start();
	displayShader.SetParameter("tex",1);
	displayShader.Stop();
}

function Sponge::refreshSponge(sponge, top, bottom)
{
	cursorTexture = sponge;
	bottomTexture = bottom;
	topTexture = top;
	updateShader.Start();
	updateShader.SetParameter("sponge",0);
	updateShader.SetParameter("top",1);
	updateShader.SetParameter("bottom",2);	
	//updateShader.SetParameter("xsize",spoonsize);
	//updateShader.SetParameter("ysize",spoonsize*ratio);
	updateShader.Stop();
	update(topTexture);
}

class ColorMask:BaseScreen
{
	var mycolor;
	var pctCompletion;
	var maskInitialCount;
	var occlusion ;
	var occlusionQuery;
	var maskTex;
	
	count();
	evaluate();
	refreshColorMask(sponge, top);
};

class VectorWrap
{
	var data;
	
	setvalue(index, data);
};

function VectorWrap::VectorWrap(size)
{
	data = Vector(size);
}

function VectorWrap::setvalue(index, indata)
{
	if(valtype(indata) == "V")
		for(var i = 0; i < len(indata); i++)
			data[i+index] = indata[i];
	else
		data[index] = indata;
}



#endif
