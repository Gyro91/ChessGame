/* --- PURSUIT APP ---
 * Version 3.2.2
 * Developed by Tante Persone, Fabio Stroppa, Nicola Mastronicola
 */

SET SCENE_FOV = 60;
SET SCENE_NEAR = 0.05;
SET SCENE_FAR = 1000;

#define _S3D_ALLOW_OBSOLETE_FUNCTIONS
//==============================================================================================================
// Includes
//==============================================================================================================
#include <Script3d.h>
#include "physics.s3d"	// for physx
#include "ReachingHelp.s3d"
#include "Transformation.s3d"
//==============================================================================================================
// Define
//==============================================================================================================
#define ENABLE_STEREO   // OCCHIO ... ATTIVO IN DEMOLEXOS
// NO XPC TARGET PRESENT (DEBUG)
#define NOTARGET 
// SHADOW DEFINITION: ONLY FOR 3-DIM VIEW
#define SHADOW
// GRASPING AND RELEASE MODALITY
//#define HOLD_MOVE	// GRASP AND AUTOMATIC HOLD, OTHERWISE GRASP&HOLD
// KINEMATICS AND DYNAMICS PARAMETERS
#define staticFriction 0.4
#define dynamicFriction 0.3
#define MAXSPEEDFORTHROW	0.006	// BASKET: SET THE PROXY SPEED TO LET THE CUBE THROW IN THE BASKET
#define SELECT_DISTANCE		0.015	//0.015
#define PIGRECO 3.141592
#define ROOM_SIZE	3.0
#define BASKET_LIMITX	0.5
#define BASKET_LIMITZ	1
#define INTRO_ 	0
#define INTRO2_ 1
#define PUZZLE_ 2
#define CLOCK_	3
#define BASKET_	4
#define END_ 	5
#define END2_ 	6
#define NUM_SOUNDS 	8
#define SFX_INTRO 	0
#define SFX_BUMP 	1
#define SFX_PICK 	2
#define SFX_CLAP	3 
#define SFX_FINISH 	4
#define SFX_CLACK	5
#define SFX_DROP	6
#define SFX_ALARM   7

///added by Antonio and Nicola  TO BE REMOVED
var temp_check_force=false;



var file_ext="";
var Mode = 0;					// Identifier for Control Modality: NOMODE
var checkApp = false;			// Flag to check the type of application
var EndInit = 0;				// End of Reset Encoders (=0 NOT FINISHED; =1 FINISHED)
// SCORE VARIABLES
var date="";
var scores = 0;
var scoreloaded = false;
var reqscore = false;
var immagini = {"haring","numbers","foca","spade","grape","italy","mini","roma01","parigi01","parigi02","parigi03","deserto","canyon","papaveri","londra01","londra02"};

var puzzle = "foca";
var temp_puzzle = "";				
var session = "Puzzle";
var on_session = array(3);								
var prev_session = "-";
var v = vector(3);
var cubePos=[0.0, 0.0, 0.0];
var mod=0.0;
var HFor = [0.0,0.0,0.0];
var HiJointPos = [0.0,0.0,0.0,0.0,0.0];
var HiVel= [0.0,0.0,0.0];
var application = CVmWebBrowser();
var Fgrab = 0.0;		// FORCE TO EVALUATE THE GRAB
var pazienteSelected = false; 
var paziente="<Paziente>";
var task="C";		// P:Puzzle - B:Basket - C:Clock
var lista_pazienti = {};
/* end effector offset */
var offset_x;					//Offset su x
var offset_y;					//Offset su y
var offset_z;					//Offset su z

/* End Effector Scale */
var scale_x;					//Scale su x
var scale_y;					//Scale su y
var scale_z;					//Scale su z

var Pos_Offset_Dev = [ 0,0,0 ];
var Pos_Offset_VR = [ 0,0,0 ];
var dev_pos = [0,0,0];
var dev_pos_old = [ 0,0,0 ];

// TEMPORARY SCORES (KT)
var timer = 0.0;
var total_time = 0.0;
var NUM_CUBES=12;
var IsPressed = false;  	//check pressed button
var sel_obj	= 0; 			//Index of selected object
var matched_cubes = {};
var free_cubes = {1,2,3,4,5,6,7,8,9};
var mat_obj = 0;
var floor_colgr = 20;			// Roof Collision group
var CIRCLE_RADIUS = 3;			// Circle Radius Factor
//variabili temporanee da precedente codice
var HB_ini = [0,0,0];
var HB_curr = [0,0,0];
var HB_old = [0,0,0];
var HB_speed = [0,0,0];
//forze verso l'haptic device
var Force = [0.0,0.0,0.0]; //visualized force
var ModuleForce = 0;
var NFor = [0.0,0.0,0.0];
var HiForces = [0.0,0.0,0.0];
var HiGrasp = [0.0,0.0];
var pos = vector(3);			//Position of the grabber
var time = vector(1);			//time since the grab started
var forzaSx = vector(3);		//force applied on the left grabber
var dSx = vector(3);  			//position and speed
var ddSx = vector(3);	
var deltaSim = 1.0;				//delta time (ms)
var sfera1;				//grabber cursors
var Device_EE_sfera;
var Target_EE_sfera;

#define HCP_OFF					0
#define HCP_TOUCH					1
#define HCP_ASSIST					3
#define HCP_FROM_ASSIST_TO_TOUCH	4

var Haptic_Control_Phase = HCP_OFF;

var Delta_Tempo_Medio = 0.001;


var matRosso;					//cursors material
var maton;
var matoff;
var ForceStatus=0;
/* --- NEWS FABIO NICOLA --- */
	var h_class;
	var h_required=false;
	var counter_help=0;
	var possoIniziare=false;
	var assistSet=0;
	var t_class = Transformation([3,3,3],[0,0,0.45],"x",-PIGRECO/2); //(scale, offset, Rotation Matrix x-axis)
    var space_grasp=false;
    var oldHoff,oldDoff,oldVoff;
    var oldScale_x;
    var oldScale_y;
    var oldScale_z;
    var posInit=vector(3); 
    var Init_pos = false;
    var activeInitPos=false;
    var ADC_TSHOLD;
    var ADC_Bool = false;    
    var firstFrame;
    var reduce_stiffness_count = -1;
	var reduce_stiffness_maxIteration = 300.0;	//50 volte 0.01s --> 0.5s
	var cube_to_reach = -1;
	var clock_inc = 0;
	var matrixCamera_DEV_to_XVR = vector(16);
	var matrixCamera_XVR_to_DEV = vector(16);
	
	var	cube_size = 0.15;
	var cube_mass = 0.0;
	var cube_density = 0.0;
	var cube_volume = 0.0;
	
	var CAMERAMOD = false;
	
	var autoGrasp=false;
	
	var playSmokeSound = false;
	var stopSmokeSound = false;
	var smokeSoundIsPlaying = false;
	
/* --- NEWS FABIO NICOLA --- */
var StiffSfera = 250;
var StiffSferaExos = StiffSfera;
var ScalaStiffObjSel=1.0; 
var StiffCubo = 150;
var BiHB = 15.0;
var temp_dist=0.0;
var temp_pos=[0.0,0.0,0.0];
var temp_pos_sfera=[0.0,0.0,0.0];
var temp_isSelected=false;
var isSelected=false;
// IF 2-DIM VIEW
var CenterPuzzle = [0.0,0.0,0.0];//[0.0, 0.0, cube_size*5/2 ];
var CenterBasket = CenterPuzzle;// - [-5*cube_size,1.4*cube_size,7.2*cube_size];
var CamDir      = [0,0,-1];				//camera direction
var CamPos      = [0.0, 0.7, 1.6];  	//camera position
#ifdef ENABLE_STEREO
var CamPos2D    = [0.0, 0.001, CenterPuzzle[2]+0];//[0.0, 2.1, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#else
var CamPos2D    = [0.0, 2.1, CenterPuzzle[2]+0];	// the offset for CenterPuzzle[2] is to avoid the singularity of orientation of camera
#endif
var CamTarget   = [0.0, 0.45, 0.0];
var CamTarget2D = CenterPuzzle;
//Light
var Luce;
var PosL = [3, 5.0, 1.5];		//default light position
//Meshes and graphic objects
var m_stanza, o_stanza;
var m_basket, o_basket;
var m_cesto = array(4), o_cesto=array(4);
var m_cube = array(NUM_CUBES);		// MESH OF CUBES
var o_cube = array(NUM_CUBES);		// PHYSICS CUBES
var mv_cube = array(NUM_CUBES);		// MESH OF VIRTUAL CUBES
var v_cube = array(NUM_CUBES);		// VIRTUAL CUBES (ONLY FOR CLOCK SESSION)
var cube_position = array(NUM_CUBES);
var clock_position = array(NUM_CUBES);
var cube_grid = array(NUM_CUBES*2);
var TargetPos = [0.0,0.0,0.0];
var IniGrid = array(NUM_CUBES);
var stickyMaterial;		//Physic material for the cursors
var rigidMaterial;		//Physic material for the cubes and the floor
var Map;
var isForceEnabled=false;
var stato = INTRO_;	
var SoundFX = array(NUM_SOUNDS);
var UDP_Channel;
var XVR_Port = 12345;
var GUI_Port = 12346;
#ifdef SHADOW
	var fbo;
	var shader;
	// additional OpenGL constants
	#define GL_DEPTH_COMPONENT16	0x81A5
	#define GL_DEPTH_COMPONENT24	0x81A6
	#define GL_DEPTH_COMPONENT32	0x81A7	
	// additional XVR constants
	//#define VR_FBO_COLOR			0x0001
	//#define VR_FBO_DEPTH			0x0002
	//#define VR_FBO_SHADOW			0x0003
	var shader_name = "shadows_tex.sh";
	// a couple of handy application constants
	#define SCENE_CAMERA 0
	#define LIGHT_CAMERA 1
	#define LIGHT_CAMERA2 2
	var light,light2;
#endif
/****************** SEND PROTOCOL VARIABLES *******************/
var GravityComp=0.0;	// Percentage of the patient's arm mass
var GravityOn = 0.0;
var BodyMass = 0.0;		// Patient Body Mass
var weight = [1,1,1,1];	// PESI PER LA CINEMATICA INVERSA DEL REACHING
var kp = [0,0,0,0];
var damper = 30.0;	// VISCOSITY FACTOR (Ns/m) OF RESISTANCE FORCE
var forcecontrol_flag=1;
/**************************************************************/





//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//#define DEVICE_INTERFACE_TH20
#define DEVICE_INTERFACE_ALEX30

#define HI_xVR_PATH		".\\..\\..\\HI_xVR"
#include "..\..\HI_xVR\Device_Interface_Include.s3d"

var Device_xVR;
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX



//==============================================================================================================
//MS functions & variables which are used for communication with external GUI
//==============================================================================================================
function ReceiveData(UDP_Channel);
function SendData(data);
function ProcessData(data); 
function attachCube();
function attachClock();
function Grabbed();
function DrawGrid();
function MoveCameraTo(x,y,z,startangle);
function InitPositions();
function SetIniGrid();
function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y);
function DrawLine(pos1,pos2,r,g,b);
function LoadBasket();
function LoadPuzzle();
function ReloadPuzzle();
function LoadCube();		//ONLY FOR CLOCK SESSION
function max(a);
function disp(x,y,stri,row,col,fontsize,transparency);
function ThrowBasket();
function TaskBar();
function modul(v);
function Load_Score();
function plot(data,title);
function HandleDataIn(separator);
function view_plot();
function ManageCollision();
function CameraMoveMouse();
function GetCameraTransfMatrix();
function GetXVRDev_cameraPos(pos);
function GetDevXVR_cameraPos(pos);

// get commands from the web page.
function HandleDataIn(separator)
{
	var s = DataIn();
	var aa;
//	trace(s);
	if(len(s) != 0)
	{
		if(separator!="")
			aa = split(s,separator);
		else
			aa = s;
		return aa;
	}
}

function Load_Score()
{
	var filescore = LoadFile("TotalScores.dat");
	var score_data = {0.0};
	var j=0;
	var data;

//	trace(filescore);
	if(filescore!=void)
	{
		foreach(var a in filescore)
		{
//			trace(a);
			if(a!="")
			{
				var b=split(a,",");
//				outputln(b[0],"==",paziente," - ",b[2],"==",session);
				data=val(b[3]);
//				trace(data);
				if( (b[0]==paziente)&&(b[2]==session) )
				{
					aadd(score_data,data);
				}
//				trace(score_data);
			}
		}
		adel(score_data,0);
	}
//	trace(score_data);
	return score_data;
}

function SetIniGrid()
{
	var i, ii;
	var Grid = array(NUM_CUBES);
	var seed;
	/* inizializza la griglia */
	for(i=0;i<NUM_CUBES;i++)
		Grid[i] = i;	
	/* diamo le carte */
	for (i=0;i<NUM_CUBES;i++)
	{
		seed = NUM_CUBES - i - 1;
		if (seed == 0)
			ii = 0;
		else
			ii= rand(seed);
	   	IniGrid[i] = Grid[ii];
	   	Grid[ii] = Grid[seed];
	}
}

function LoadBasket()
{
	var meshtoload = "Objects\\cesto.aam";
	m_basket = CVmNewMesh(meshtoload);
	m_basket.Normalize(3*cube_size);
	m_basket.CenterBoundingBox();
	o_basket=CVmObj();
	o_basket.LinkToMesh(m_basket);
	o_basket.setposition(CenterBasket);
}

function ReloadPuzzle()
{
	if(session!="Clock")	NUM_CUBES = 9;
	
	outputln("RELOAD PUZZLE");
	
	var meshtoload="";
	var i;	
	var dir = GetCurrentDir();
//	trace(dir);
//	outputln(puzzle);
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
	dir = GetCurrentDir();
//	trace(dir);  
	
	if(session=="Clock")
	{
//		var dir = GetCurrentDir();
//		trace(dir);  
//		SetLocalDir(sprintf(".\\Cubes\\clock" ));
//		dir = GetCurrentDir();
//		trace(dir);  
		
		clock_inc = 0;
		if(on_session[2]==0)	// IF THE FIRST CALL OF CLOCK
		{
			for (var j=0;j<NUM_CUBES;j++){
				meshtoload = sprintf("a_%d.aam",j+1);
				m_cube[j] = CVmNewMesh(meshtoload);
				m_cube[j].Normalize(cube_size);
				mv_cube[j] = CVmNewMesh(meshtoload);
				mv_cube[j].Normalize(cube_size);
				v_cube[j]=CvmObj();	
				v_cube[j].LinkToMesh(mv_cube[j]);
				v_cube[j].ModulateMaterials(1,1,1,0.5);
			}
			// LOAD THE OBJECT CUBE TIL 12th FOR THE CLOCK SESSION 
			for (var j=9;j<NUM_CUBES;j++)
			{
				o_cube[j] = manager_psx.AddPhConvexShape([0.0,0.0,0.0], [0.0,0.0,0.0], m_cube[j], PHX_DYNAMIC, cube_density, 10, rigidMaterial);
//				outputln("CREATE 1");
//				o_cube[j] = manager_psx.AddPhCube([0.0,0.0,0.0], [0.0,0.0,0.0], [cube_size, cube_size, cube_size], PHX_DYNAMIC, cube_density, 10, rigidMaterial);
//				//o_cube[j].LinkToMesh(m_cube[j]);
				
				o_cube[j].SetMass(cube_mass);
				o_cube[j].AssignCollisionGroup(j+1);
				o_cube[j].SetBarycenterREL([0.0, -cube_size/4, 0.0]);				
				//o_cube[j].SetInertiaTensor([10000, 10000, 10000]);	//increasing inertia to avoid rotation
				o_cube[j].SetInertiaTensor([100000, 100000, 100000]);	//increasing inertia to avoid rotation			
			}

			on_session[2]=1;
		}	
			
		for (var j=0;j<NUM_CUBES;j++)
		{
			meshtoload = sprintf("a_%d.aam",j+1);
			m_cube[j] = CVmNewMesh(meshtoload);
			m_cube[j].Normalize(cube_size);
			mv_cube[j] = CVmNewMesh(meshtoload);
			mv_cube[j].Normalize(cube_size);
			v_cube[j]=CvmObj();	
			v_cube[j].LinkToMesh(mv_cube[j]);
			v_cube[j].ModulateMaterials(1,1,1,0.5);
			o_cube[j].LinkToMesh(m_cube[j]);	// LINK THE FIRST 9 CUBES
			if(o_cube[j].type!=PHX_DYNAMIC){
				o_cube[j].MakeDynamic();
//				outputln("MAKE DYNAMIC");
			}				
			o_cube[j].setvisible(true);
			o_cube[j].setgravity(true);
			// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				o_cube[j].Setvisible(false);
			}
		}
		
		manager_psx.EnableCollision(0,1);	// ENABLE COLLISION BETWEEN FIRST CUBE AND PROXY
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.DisableCollision(0,k+1);
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.EnableCollision(floor_colgr,k);
		
		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.DisableCollision(1,k+1);			
	}
	else	// BASKET OR PUZZLE
	{	
		var dir = GetCurrentDir();
//		trace(dir);
//		SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
//		dir = GetCurrentDir();
//		trace(dir);  
		
		for (var j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
			meshtoload = sprintf("a_%d.aam",i+1);
			m_cube[i] = CVmNewMesh(meshtoload);
			m_cube[i].Normalize(cube_size);	
			if(o_cube[i].Type!=PHX_DYNAMIC){
				o_cube[i].MakeDynamic();
//				outputln("MAKE DYNAMIC");
			}				
			o_cube[i].Setgravity(true);
			o_cube[i].LinkToMesh(m_cube[i]);
			o_cube[i].Setvisible(true);
		}

		for(var k=1; k<=NUM_CUBES; k++)
			manager_psx.EnableCollision(floor_colgr,k);
		// HIDE THE THREE CUBES CREATED IN A PREVIOUS CLOCK TASK
		if(on_session[2]==1)
		{
			for (var j=NUM_CUBES;j<NUM_CUBES+3;j++)
			{
				o_cube[j].Setvisible(false);			
				manager_psx.DisableCollision(0,j+1); // disable proxy collision
				for(var k=1; k<=NUM_CUBES; k++)
					manager_psx.DisableCollision(j+1,k);
			}
		}
		Map = CVmTexture(sprintf("Sinopia.jpg"));
	}
}

function LoadCube()
{
	var j=0;
	if(len(free_cubes)!=0)
	{
		// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
		cube_position[free_cubes[j]-1] = [ 0.0, cube_size/2, 0.0 ] + CenterPuzzle;
		// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
		o_cube[free_cubes[j]-1].Setvisible(true);
		o_cube[free_cubes[j]-1].Setgravity(true);
		manager_psx.EnableCollision(0,free_cubes[j]);
		o_cube[free_cubes[j]-1].SetPosition(cube_position[ free_cubes[j]-1 ]);
		o_cube[free_cubes[j]-1].SetRotation(-90,[1.0,0.0,0.0]);
	}
}

function LoadPuzzle()
{
	outputln("LOAD PUZZLE");
	
	var meshtoload="";
	var i;
	SetIniGrid();
	// Set Local Directory to .\Cubes to avoid problem in loading the *.aam and relative textures
	SetLocalDir(sprintf(".\\Cubes\\%s",puzzle));
	for (var j=0;j<NUM_CUBES;j++)
	{
		i = IniGrid[j];
		meshtoload = sprintf("a_%d.aam",i+1);
		m_cube[i] = CVmNewMesh(meshtoload);
		m_cube[i].Normalize(cube_size);
		
//		o_cube[i] = manager_psx.AddPhConvexShape([0.0,0.0,0.0], [0.0,0.0,0.0], m_cube[i], PHX_DYNAMIC, cube_density, 10, rigidMaterial);
//		o_cube[i].LinkToMesh(m_cube[i]);
		
		o_cube[i] = manager_psx.AddPhCube([0.0,0.0,0.0], [0.0,0.0,0.0], [cube_size, cube_size, cube_size], PHX_DYNAMIC, cube_density, 10, rigidMaterial);
		o_cube[i].LinkToMesh(m_cube[i]);
//		outputln("CREATE 2");
//		trace(cube_mass);
		o_cube[i].SetMass(cube_mass);
		o_cube[i].AssignCollisionGroup(i+1);	// CUBE COLLISION GROUP 1..10		
		o_cube[i].SetBarycenterREL([0.0, -cube_size/4, 0.0]);		
		// INCREASING INERTIA TO AVOID ROTATION
		o_cube[i].SetInertiaTensor([100000, 100000, 100000]);		
//		PhysXVR.SetCollision(sfera1.getActor(), o_cube[i].getActor());
	}	
	InitPositions();
	ConsoleFont("Arial", 24);
	ConsoleColor( 0.364, 0.294 , 0.278, 1.0 );
	Map = CVmTexture(sprintf("Sinopia.jpg"));	
	SetLocalDir();	// Set Local Directory to the actual one
	
	if(session == "Clock"){
		clock_inc = 0;
	}
}

function OnDownload()
{		
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	DEV_Interface_Utility_Download();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	

	FileDownload("suoni.zip");
	FileDownload("Objects.zip");
	FileDownload("stanza.zip");
	#ifdef SHADOW
		FileDownload(shader_name);
	#endif		
}

function onEvent(){}

function OnError(){
	SendData("ERR");
}

var matred, M_light, O_light;




function OnInit(params)
{	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR = ALEX30_xVR(3.0,  [ 1.0, 0.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,    0.0, 0.0, 1.0, 0.0,    0.0, 0.0, 0.0, 1.0 ], "ALEX30");
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX		

	#ifdef ENABLE_STEREO
	SceneSetParam(VR_HEADTRACKER,1);
	SceneSetParam(VR_EYE_SEPARATION,0.065);	
	SceneSetParam(VR_TRACKER_POSITION, 0, 0.0, 1.0);	
	#endif
	GlEnable(GL_NORMALIZE);
//	// GET DATE
//	var display = HandleDataIn("");
//	sscanf(display,"%s",&date);
//	trace(date);
	
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CUBES%DIMENSIONS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	cube_size = 0.15;								//m	
	cube_volume = cube_size*cube_size*cube_size;	//m^3
	cube_mass = 0.8; 									//kg
	cube_density = cube_mass / cube_volume;									
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	date = "1-1-2000";    // OKKIO ... NON PRESENTE IN DEMOLEXOS
	if(session!="Clock")	NUM_CUBES = 9;
	on_session[0] = 1;
	on_session[1] = 0;
	on_session[2] = 0;
	
	//================================
	// Graphic Setup
	//================================ 
	CameraSetPosition(CamPos);
	#ifndef SHADOW
	
		Luce = CVmLight();
		Luce.SetDiffuse(1,1,1);
		Luce.SetSpecular(1,1,1);
		Luce.Enable();	
		Luce.SetPosition(PosL);
		
	#else
	// SHADOW ON		
		light = CVmLight();
		light.SetDiffuse(1,1,1);
		light.Enable();	
		light.SetPosition(PosL);	
		/*
		 * Here, the Framebuffer Object (CVmFbo) is initialized
		 * 
		 * Parameters are:
		 * - type of FBO (VR_FBO_SHADOW, VR_FBO_DEPTH, VR_FBO_COLOR)
		 *     VR_FBO_COLOR is a color framebuffer
		 *     VR_FBO_DEPTH is a depth buffer
		 *     VR_FBO_SHADOW is a depth buffer with automatic depth comparison
		 *         (see Sampler2DShadow in GLSL)
		 * - width and height in pixels of FBO (if you have trouble with this,
		 *     try using square, power-of-2 dimensions)
		 * - format of framebuffer (use GL constants as GL_RGBA, GL_DEPTH_COMPONENT, etc.)
		 */
		fbo = CVmFbo(VR_FBO_SHADOW, 2048*2, 2048*2, GL_DEPTH_COMPONENT32);		
		/*
		 * You can retrieve the CVmTexture object associated to the frame buffer,
		 * but this in general is not necessary since you can pass the framebuffer object
		 * itself to SetActiveTexture()
		 */

		/*
		 * In case you are using color framebuffer objects, you may want to enable
		 * automatic mipmap generation, which is useful if you use the resulting image
		 * as a texture.
		 * Please beware that automatic mipmap generation could affect the overall performance
		 * of your application.
		 */
		shader = CVmShaderProgram(shader_name);
	 #endif
	var j;	
    forzaSx = [0.0, 0.0, 0.0];
	for (j = 0; j < NUM_SOUNDS; j++)
		SoundFX[j] = CVmVRAWav();
	
//	outputln(getcurrentdir());
	var currdir = getcurrentdir();
	InitPhysicsEngine();
//	outputln(getcurrentdir());
	SetCurrentDir(currdir);
//	outputln(getcurrentdir());
		
	SoundFX[SFX_BUMP].Load("bump.wav");
	SoundFX[SFX_PICK].Load("tac.wav");
	SoundFX[SFX_CLAP].Load("clap.wav");
	SoundFX[SFX_FINISH].Load("fanfar1.wav");
	SoundFX[SFX_CLACK].Load("Clack.wav");
	SoundFX[SFX_DROP].Load("buttondrop.wav");
	SoundFX[SFX_ALARM].Load("Smoke Alarm.wav");
	
	//Graphic material for grab cursor
	matRosso = CVmMaterial();
	matRosso.diffuse = matRosso.ambient = [1,0,0,1];
	matRosso.specular = [0,0,0,1];
	matoff = CVmMaterial();	//GREY
	matoff.ambient   = 10*[0.1, 0.1, 0.1, 1.0];
	matoff.diffuse   = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.specular  = 5*[0.1, 0.1, 0.1, 1.0];
	matoff.shininess = 1;
	maton = CVmMaterial();	//GREEN
	maton.ambient   = 10*[0.0, 0.2, 0.0, 1.0];
	maton.diffuse   = [0.0, 1.0, 0.0, 1.0];
	maton.specular  = 10*[0.1, 0.1, 0.1, 1.0];
	maton.shininess = 10;
	
	//Physic materal for grab cursor
	stickyMaterial =  manager_psx.NewMaterial(0.5, staticFriction, dynamicFriction);
	rigidMaterial = manager_psx.NewMaterial(0.5, 1, 0.6);
	
	//Init grab variable
	//posizione del primo e del secondo grab
	pos = [0.2, 0.0, 0.0, -0.2, 0.0, 0.0];	
	forzaSx = [0.0,0.0,0.0];
	setTimeStep(deltaSim);
	
	//Load and resize the meshs for the room
	m_stanza = CVmNewMesh("stanza.aam");
	m_stanza.Normalize(ROOM_SIZE);	
	o_stanza = CVmObj(m_stanza);
	o_stanza.Translate(0.0, 0.0, 0.0);
		
	//Create a plane for the floor
	var plane_handler = manager_psx.AddPhPlane([0.0,1.0,0.0], 0.0, rigidMaterial);	// floor_colgr = Collision group=20		
	plane_handler.AssignCollisionGroup(floor_colgr);
	
	//Exos cursor
	sfera1 = manager_psx.AddPhSphere([pos[0]+camTarget[0], pos[1]+camTarget[1], pos[2]+camTarget[2]], [0.0,0.0,0.0], 0.015, PHX_DYNAMIC, 2.0, 12, stickyMaterial);
	sfera1.AssignCollisionGroup(0);
	sfera1.SetGravity(false);	//Set the gravity of the cursor to zero 
	matred = CVmMaterial();
	matred.ambient   = [0.7, 0.0, 0.0, 1.0];
	matred.diffuse   = [0.4, 0.0, 0.0, 1.0];
	matred.specular  = [0.2, 0.0, 0.0, 1.0];
	matred.shininess = 0.8;
	matred.transparency = 0.5;
	
	// LIGHT SOURCE
	M_light = CVmNewMesh("sphere.aam");
	M_light.Normalize(0.5);
	O_light = CVmObj(M_light);
	O_light.ForceMaterial(matred);
	O_light.SetPosition(PosL);
	
	//With an high inertia tensor the cursor can't rotate
	sfera1.SetInertiaTensor([10.0, 10.0, 10.0]);
	UDP_Channel = NetCreateChannel(XVR_Port, Void, VR_NO_BLOCKING);	
	//MS check for new commands from external GUI	
	LoadPuzzle();	
	LoadBasket();	
	
	
	var Sfera_Mesh = CVmNewMesh(VRP_SPHERE, 30, 0.015, 1.0);
	Device_EE_sfera = CVmObj(Sfera_Mesh);
	Target_EE_sfera = CVmObj(Sfera_Mesh);
	
	
	 #ifdef SHADOW
	/*
	 * Put camera "1" where the light is and orient it towards the center of the scene.
	 * If you want to move the light, please move this camera accordingly
	 */	
	CameraActivate(LIGHT_CAMERA);
	CameraSetPosition(PosL);		
	CameraSetTarget([0, 0, 0]);
	CameraActivate(SCENE_CAMERA);
	#endif
	
	offset_x = 0;
	offset_y = 0;
	offset_z = 0;
	
	scale_x = 3;
	scale_y = 3;
	scale_z = 3;	
	Pos_Offset_VR = [ offset_x,offset_z,offset_y ];
	Pos_Offset_Dev = [ 0,0,0 ];	
	
	pos = [0.0, 0.0, 0.0];
	oldHoff = offset_x; 
	oldVoff = offset_y;  
	oldDoff = offset_z;
	oldScale_x = scale_x;
	oldScale_y = scale_y;
	oldScale_z = scale_z;
	ADC_TSHOLD=0.5;
	firstFrame=false;
	
	SendData("ONINIT_OK");
			
} 	// ONINIT

#ifdef SHADOW
// light projection and modelview matrices
var light_mat_proj=array(2);
var light_mat_modelview=array(2);

function RenderOnTexture(luce)
{
	CameraActivate(luce);	
	shader.activate(true);
	/*
	 * First of all, you have to notify your intention
	 * to draw on the offscreen framebuffer you have created
	 * (that is, render to texture)
	 */
	fbo.Start();	
	/*
	 * Then, you start drawing as usual in XVR
	 */	
	SceneBegin();		
	/*
	 * Retrieve the modelview and projection matrix of the light
	 * and save them; of course if the light is fixed, this is
	 * needed only once
	 */
	light_mat_proj[luce-1]      = glGet(GL_PROJECTION_MATRIX);
	light_mat_modelview[luce-1] = glGet(GL_MODELVIEW_MATRIX);	
	/*
	 * Polygon offset is needed in order to avoid artifacts in the
	 * final image due to low precision of depth buffer values
	 */
	glEnable(GL_POLYGON_OFFSET_FILL);
	glPolygonOffset(2, 2);		
	/*
	 * Here, draw all the objects that should CAST shadows
	 */
	var view_scale=-0.025;		
	var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];

	DrawLine(temp_pos_sfera,arrowEnd,1,0,0);	
	manager_psx.Draw();
	glDisable(GL_POLYGON_OFFSET_FILL);	
	SceneEnd();		
	/*
	 * Tell XVR that you are done with the offscreen framebuffer
	 * and that subsequent draw operations should occur on the screen
	 */
	fbo.Stop();
}
	
function FillTextureMatrix(luce)
{
	glMatrixMode (GL_TEXTURE);
	
	/*
	 * First of all, we have to clamp the values in the [0.0,1.0] range
	 * instead of the [-1.0,1.0] we obtain from the view matrices
	 */
	glLoadIdentity();
	glTranslate(0.5, 0.5, 0.5);
	glScale(0.5, 0.5, 0.5);
	
	/*
	 * Next, multiply by the previously retrieved light matrices
	 */
	glMultMatrix(light_mat_proj[luce-1]);
	glMultMatrix(light_mat_modelview[luce-1]);
	
	/*
	 * Finally, we multiply by the inverse of the *current* modelview matrix
	 * This is needed because it is already included in each vertex own modelview
	 */
	var s_mat_m = glGet(GL_MODELVIEW_MATRIX);
	
	/*
	 * This matrix should always be invertible, but still...
	 */
	if (! InvertMatrix(&s_mat_m))
		Quit("Singular view matrix!");
	
	glMultMatrix(s_mat_m);
}
#endif	//SHADOW

function DrawScene()
{	
	#ifdef SHADOW	// 3D VIEW
		FillTextureMatrix(LIGHT_CAMERA);	
		glMatrixMode(GL_MODELVIEW);		
		shader.Start();		
		SetActiveTexture(fbo,0,4);
		shader.SetParameter("shadowMap", 4);
		shader.SetParameter("tex", 0);			
		var view_scale=-0.025;		
		var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
		DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
		o_stanza.Draw();
		manager_psx.Draw();
		
		if ( session == "Puzzle" )	// DISPLAY THE PICTURE
		{	
			glColor(1.0,1.0,1.0,0.5);
			glEnable(GL_BLEND);													
			DrawPolygonXZ(Map,-cube_size*3/2,cube_size*3/2, cube_size*3/2, -cube_size*3/2, cube_size);							
			glDIsable(GL_BLEND);
			glColor(1.0,1.0,1.0,1.0);
		}
		
		if ( session == "Basket" )
		{
			o_basket.draw();					
		}
		
		if (session == "Clock" )
		{
			for (var i=0;i<NUM_CUBES;i++)
				v_cube[i].Draw();
		}				

    shader.Stop();    	
		
	#else
		var view_scale=-0.025;		
		var arrowEnd = [temp_pos_sfera[0]+HFor[0]*view_scale,temp_pos_sfera[1]+HFor[1]*view_scale,temp_pos_sfera[2]+HFor[2]*view_scale];
	 
		DrawLine(temp_pos_sfera,arrowEnd,1,0,0);
		o_stanza.Draw();				
		manager_psx.Draw();
		
		if ( session == "Puzzle" )	// DISPLAY THE PICTURE
		{	
			glColor(1.0,1.0,1.0,0.5);
			glEnable(GL_BLEND);					
			
			DrawPolygonXZ(Map,-cube_size*3/2,cube_size*3/2, cube_size*3/2, -cube_size*3/2, cube_size);					
			
			glDIsable(GL_BLEND);
			glColor(1.0,1.0,1.0,1.0);
		}
		
		if ( session == "Basket" )
		{
			o_basket.draw();
		}
		
		if (session == "Clock" )
		{
			for (var i=0;i<NUM_CUBES;i++)	
				v_cube[i].Draw();
		}
		

	#endif
	TaskBar();			
	
	var stri_obj=sprintf("CONTROL PHASE %d",Haptic_Control_Phase);
	Consoletext(0.1,0.9,stri_obj);
	
	var stri = sprintf("CF: %d  DTM: %6.5f",Haptic_Control_Phase, Delta_Tempo_Medio*1000.0);
	Consoletext(0.1,0.1,stri);
	
	Device_EE_sfera.ModulateMaterials(0,1,0);
	Device_EE_sfera.Draw();
	Target_EE_sfera.ModulateMaterials(1,0,0);
	Target_EE_sfera.Draw();
		
}

var isgrabbed=0;	// EVENT FOR DATALOG
var grasp_on=0;
var startedtask=false;	// START OF PUZZLE FLAG
var keyon=false;
var oldpatient ="";
var plotdataon = false;
var stri_obj2="";
var t_start,t_msg;
var calibkey_on = false;
var scalekey_on = {false,false};

var	changeStatusIntro_timer = 0;
var bullet=-1;
var setRecordFlag = false;
function OnFrame() {
	
	var Index = 0;
	
	CameraMoveMouse();
	
	if (!firstFrame){
		senddata("INT");
		firstFrame=true;
	}
	
	HiVel = -(pos - dev_pos_old)*1000.0;
	dev_pos_old = pos;
	manager_psx.SetSceneGravity([0.0,-9.8,0.0]);
	
	if(keypressed("c")&&!calibkey_on){		
		Pos_Offset_Dev = dev_pos;
		calibkey_on=true;
		output("Offset=",Pos_Offset_Dev);
	}
	
	if(!keypressed("c"))
		calibkey_on=false;

//	if(keypressed(VK_UP)&&!scalekey_on[0])
//	{
//		Scale=Scale+0.25;
//		if(Scale >= 8.0)	
//			Scale = 8.0;				
//		scalekey_on[0]=true;
//	}
	
	if(!keypressed(VK_UP)) 
		scalekey_on[0]=false;
	
//	if(keypressed(VK_DOWN)&&!scalekey_on[1])
//	{
//		Scale=Scale-0.25;
//		if(Scale <= 1.5)	
//			Scale = 1.5;				
//		scalekey_on[1]=true;
//	}
	
	if(!keypressed(VK_DOWN)) 
		scalekey_on[1]=false;
	
	
	
		
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR.OnFrame();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	var xVR_EE_Pos_In = [ 0.0, 0.0, 0.0 ]; 
	var xVR_EE_Pos_Out = [ 0.0, 0.0, 0.0 ]; 
	
	xVR_EE_Pos_In = Device_xVR.DataIn[Index].EE_Pos;
	xVR_EE_Pos_Out = Device_xVR.DataOut[Index].EE_Pos;
		
	Device_EE_sfera.SetPosition(t_class.GetPos_DevToXvr(xVR_EE_Pos_In));
	Target_EE_sfera.SetPosition(t_class.GetPos_DevToXvr(xVR_EE_Pos_Out));
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	//MS check for new commands from external GUI
	ReceiveData(UDP_Channel);
	if(plotdataon)	
		view_plot();
	
	if(playSmokeSound){
		disp(0.5,0.8,"FORCES OVER LIMITS",0,"R",40,1.0);
		SoundFX[SFX_ALARM].Play(true);
		//outputln("PLAY SMOKE");
		playSmokeSound = false;	
		smokeSoundIsPlaying = true;
	}
	if(stopSmokeSound){
		SoundFX[SFX_ALARM].Stop();
		//outputln("NO PLAY SMOKE");
		smokeSoundIsPlaying = false;
		stopSmokeSound = false;
	}
	
	if (checkApp){	
			
		if (keypressed(VK_ESCAPE)) {
				for(var i=0;i<4;i++)
					kp[i]=0.0;
				application.quit();
			}

			static var camera_angle = 0;
		
			#ifdef ENABLE_STEREO
			var camera_radius = 0.1;//1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#else
			var camera_radius = 1.4;
			var camera_elevation = 1;
			var camera_osc = 0.25;
			#endif
		
			var cam_end,tar_end;
			var glob_end=0;
			static var sel_now = true;
		
			var CameraPosT;		
		
		//------------------------------------------SWITCH------------------------
		switch(stato){
				case INTRO_:
					// ROTATION SPEED OF CAMERA AROUND THE PUZZLE
					camera_angle += 0.005;		
					CameraPosT = [camera_radius*cos(camera_angle), camera_elevation + camera_osc*sin(camera_angle), camera_radius*sin(camera_angle)];
					CameraSetPosition(CameraPosT);
					CameraSetTarget(CamTarget2D);					
					// DISABLE COLLISION AMONG CUBES AND PROXY
					// IF THE DEVICE NOT INITIALIZED
					if((EndInit==0)&&(!plotdataon))
					{		
						disp(0.5,0.55,"EXOS NOT INITED",0,"R",40,1);
						for(var j=0; j<NUM_CUBES; j++)
						manager_psx.DisableCollision(0,j+1);
					manager_psx.DisableCollision(0,floor_colgr);
				} else {
						disp(0.5,0.55,"WAIT, PLEASE",0,"R",40,1);
						for(var j=0; j<NUM_CUBES; j++)
							manager_psx.DisableCollision(0,j+1);
					manager_psx.DisableCollision(0,floor_colgr);
					}
					// GO TO THE NEXT STATE ONLY IF ENCODERS ARE SET
					//if((mouse.ButtonL)&&(EndInit==1)&&(!plotdataon))	/* USE MOUSE LEFT BUTTON INSTEAD OF WAITING */
				if((changeStatusIntro_timer == 350)&&(EndInit==1)&&(!plotdataon)) {
						stato = INTRO2_;
					}				
					changeStatusIntro_timer++;
					break;
				
				case INTRO2_:	
					changeStatusIntro_timer = 0;				
					disp(0.5,0.55,"READY...",0,"R",40,1);					
					CameraSetTarget(CamTarget2D);
								
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],CamPos2D[2],90-(camera_angle*180/PI)%360);
				
				CameraRotateABS(-25, 1, 0, 0);	//#CAMERAMOD			
				CameraRotateABS(0,0,1,0);
				CameraRotateABS(0,0,0,1);
				GetCameraTransfMatrix();		//#CAMERAMOD
				
					Tar_end = 1;	
					glob_end = Cam_end + Tar_end;
	
				if (glob_end == 2) {
						for(var j=0; j<NUM_CUBES; j++)
							manager_psx.EnableCollision(0,j+1);						
					manager_psx.EnableCollision(0,floor_colgr);				
						switch(session)
						{
							case "Puzzle":
								ManageCollision();
								stato = PUZZLE_;
								task="P";
								break;
							case "Basket":							
								stato = BASKET_;
								task="B";
								break;
							case "Clock":							
								stato = CLOCK_;
								task="C";
								break;
						}
						glob_end=0;
						t_start=getperformancetimer()/1000000.0;
						outputln(session);
					}
				break;
				
				case PUZZLE_:
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					
	
					if(grabbed())
					{
						
						attachCube(); //ENABLE THE GRID
						if (sel_now)
						{
							
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						// ALL CUBES MATCHED
						if((len(free_cubes)==0)&&(startedtask))
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
						sel_now = true;
					}	
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;
					}	
					break;
				
				case BASKET_:				
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}	
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					// IF CUBE GRABBED
					if(sel_obj!=0)
					{
						ThrowBasket();
						if (sel_now)
						{
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						if((len(free_cubes)==0)&&(startedtask))	// WHEN FREE CUBES NO MORE
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
					}					
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;					
					}							
				break;

				case CLOCK_:
					t_msg=getperformancetimer()/1000000.0 - t_start;
					if(t_msg<1.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,1.0);
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}						
					else if(t_msg>=1.0 && t_msg<2.0){
						disp(0.5,0.55,"GO!!!",0,"R",40,(2.0-t_msg));
						if(!setRecordFlag){
							SendData("StartRecord");	
							setRecordFlag = true;
						}
					}
						
	
					if(sel_obj!=0)	// IF A CUBE IS GRABBED
					{
						attachClock();
						if (sel_now)
						{
						
							SoundFX[SFX_PICK].Play();
							sel_now = false;
						}
					}
					else
					{
						if((len(free_cubes)==0)&&(startedtask))	// AT THE END OF TASK, WHEN THERE ARE NO FREE CUBES
						{
							senddata(sprintf("SAVE,%s,%f,%s",session,total_time,date));
							stato = END_;
							startedtask = false;
						}
						sel_now = true;
					} 
	
					if(startedtask)	// START TIMECOUNTER
					{
						total_time=(gettime()-timer)/1000.0;
					}				
				break;

				case END_:
		
					Cam_end = MoveCameraTo(CamPos2D[0],CamPos2D[1],0.0,0.0);
					Tar_end = 1;
					glob_end = Cam_end+Tar_end;
					SoundFX[SFX_FINISH].Play();
					SoundFX[SFX_CLAP].Play();
	
					if(!reqscore) //IF NOT ALREADY REQUESTED...
					{
						senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
						reqscore = true;
					}
					session="";
					if((glob_end == 2)&&(!scoreloaded))
						stato = END2_;
				break;
				
				case END2_:	
					// PLOT TO CHECK
					if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
					{
						if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
						{						
							plot(scores,"CONGRATULATION!");
							if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
							}
						}
						else
						{						
							disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
							disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
							if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
							}							
						}
					}
					else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
					{					
						disp(0.47,0.8,"CONGRATULATION!",0,"R",60,1);
						disp(0.5,0.7,sprintf("TOTAL TIME: %2.1f s",total_time),0,"R",60,1);
						if(setRecordFlag){
								SendData("EndGame");	
								setRecordFlag = false;						
						}
						
					}
					reqscore=false;
					scoreloaded=false;
					timer = 0.0;
					
//					#ifdef _DEBUG
//						outputln(session,"========",prev_session);
//						for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
//						for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
//					#endif

					if(session!="")		
					{
						switch(session)
						{
							case "Puzzle":
								stato = PUZZLE_;
								break;
							case "Basket":
								stato = BASKET_;
								break;
							case "Clock":
								stato = CLOCK_;
								break;
						}
						glob_end=0;
					}
				break;
		} //end switch(stato)
		//------------------------------------------SWITCH------------------------

			if((temp_isSelected)&&(sel_obj>0))
			{
//				m_cube[sel_obj-1].SubsetModulateMaterial(1,[0.5,1.0,0.5]);
//				o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
		} else{
				for (var i=0;i<NUM_CUBES;i++)
				{					
					m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
					o_cube[i].LinkToMesh(m_cube[i]);
				}
			}
			
			#ifdef SHADOW
				RenderOnTexture(LIGHT_CAMERA);	
				CameraActivate(SCENE_CAMERA);
			#endif
			
		#ifndef ENABLE_STEREO		
				SceneBegin();
				DrawScene();				
				SceneEnd();
		#else //enable stereo
				glDrawBuffer(GL_BACK_LEFT);				
				SceneBegin(VR_STEREO_LEFT);	
				DrawScene();					
				
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR.OnScene();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	

				
				SceneEnd();				
				glDrawBuffer(GL_BACK_RIGHT);
				SceneBegin(VR_STEREO_RIGHT);			
			
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR.OnScene();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
				DrawScene();				
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR.OnScene();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
			
				SceneEnd();
		#endif		
		
	} else {
		if (keypressed(VK_ESCAPE))	
			application.quit();
		consolecolor(0.5,0.5,0.5,1.0);
		consolefont("ARIAL",30);
		consoletext(0.4,0.5,"TARGET NOT ACTIVE");
		consolefont("ARIAL",20);
		consoletext(0.44,0.45,"PRESS ESC TO EXIT,");
		consoletext(0.37,0.4,"CHECK THE ETHERNET CABLE AND THEN");
		consoletext(0.35,0.35,"RESTART THE TARGET AND THE APPLICATION");

	}
	
}

function Select(currPos)
{
		if (IsPressed == false) //controlla se il pulsante del device è stato premuto per la prima volta
		{
			var min_dist=10;

			for(var i=0; i<len(free_cubes); i++)
			{
				// IDENTIFY THE CLOSEST OBJECT TO THE PROXY
				var dist = pos - o_cube[free_cubes[i]-1].GetPosition();
				var dist_mod = dist[0]^2+dist[1]^2+dist[2]^2;
				if (dist_mod<min_dist)
				{
					min_dist=dist_mod;
					switch(session)
					{
						case "Basket":					
							if(min_dist<SELECT_DISTANCE){
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);	
								}								
								cube_to_reach = -1;
							}									
							
							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
						
						case "Clock":
							// SELECTION SHOULD BE LED BY MINIMUM DISTANCE
							// AND SMALLEST NUMBER OF CUBE (IN CLOCKWISE SENSE)
							if((min_dist<SELECT_DISTANCE)&&(i==0))
							{
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);		
								}
								cube_to_reach = -1;
								for(var j=0; j<NUM_CUBES; j++)
									manager_psx.DisableCollision(sel_obj,j+1);
							}
							
						
							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))							
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
						
						case "Puzzle":
							if(min_dist<SELECT_DISTANCE){
								sel_obj=free_cubes[i];
								if(cube_to_reach != -1){
									o_cube[cube_to_reach].SetVisible(true);		
								}
								cube_to_reach = -1;
							}	

							// START THE COUNTER FOR THE TOTAL TIME (PUZZLE)
							// WHEN THE FIRST CUBE IS SELECTED
							if((sel_obj!=0)&&(len(matched_cubes)==0))
							{	
								timer=gettime();
								startedtask=true;
							}
						break;
					}
				} // endif dist_mod				
			} //endfor i	
			
			temp_dist=min_dist;
			
			// Minimum Distance to activate selection
			if ((min_dist<SELECT_DISTANCE)&&(sel_obj>0))
			{
				
				currPos = o_cube[sel_obj-1].GetPosition();
				HB_ini = currPos-pos;
				HB_old = currPos;
				IsPressed = true;
				isSelected = true;
			}
			else
			{
				IsPressed = false;
				isSelected = false;
				//grasp_on = 0;	// RELEASE CUBE
			}
		}
		
	 	//trace(grasp_on,isSelected,sel_obj);
	 	
	  	if (grasp_on==1 && isSelected && sel_obj>0)
	  	{	  		
	  		temp_check_force=isSelected;
	        currPos = o_cube[sel_obj-1].GetPosition();
	        HB_curr = currPos - pos;
			HB_speed = ( currPos - HB_old )*1000;
			// Force Feedback To Device
			HFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;
			// Reaction Force To The Objetc
			NFor = -StiffCubo*(HB_curr - HB_ini) - BiHB*HB_speed;// - Bi*N_speed;
			HB_old = currPos;
			
			ScalaStiffObjSel=0.5;
			
		}  //end if isSelected
		else  //this else goes with isSelected
		{
			temp_check_force=false;
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
		}
}


function bar(xmn,ymn,value,ref,max,unit,title,dim,mode)
//	xmn,ymn = Position of Bar Left Bottom Corner
//  meas   = 1dim data measured
//	ref	= 1dim reference
//  max = 1dim max value
//  unit = dimensional unit
//  title = bar title
//  dim = bar dimension (if dim<0 ==> pos/neg scale )
//  mode = display modality (0:green band, 1:switch green/red)
{
	var delta = abs(ref - value);	// Interval around Reference on the Bar
	var eps = 0.05*max;				// Width Green Band (mode=0)
	var dx, dy;
	var maxF = max;
	var ky;				// FACTOR SCALE (SCREEN UNIT/NEWTON)
	var y;	
	var text;
	var wt = 0.01;					// width of tick
	var abx = 0.004;				// Transparent Bar Border
	var aby = 0.005;				// Transparent Bar Border
	var width;
	var fontscale;
	// COLOR
	var red=0.0, green=0.0;	
	switch(abs(dim))
	{
		case 0:		//BIG
			dx = 0.08;
			dy = 0.3;
			width = 3;
			fontscale = 1;
			break;
		case 1:		//MEDIUM
			dx = 0.05;
			dy = 0.15;
			width = 2;
			fontscale = 0.7;
			break;
		default:
			dx = 0.1;
			dy = 0.3;
			width = 3;
			fontscale = 1;
			break;
	}
	
	if(dim<0)
	{
		ky = dy/(2*maxF);
		y = ky*value;
	}
	else
	{
		ky = dy/maxF;
		y = ky*value;
	}

	// BAR LABEL
	ConsoleFont("Arial",fontscale*30);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%s",title);
	Consoletext( xmn + 1/len(text)*0.01, ymn + dy + 0.01, text);
	
	// GREEN BAND
	if (mode==0){
		if ((delta>=eps)&&(ref>1))
		{
			red=1.0;
			green=0.0;
		}
		else if ((delta<eps)&&(ref>1))
		{
		// BAR BECOME GREEN ONLY INSIDE THE INTERVAL ref+/-eps
			red = (delta / eps)^4;
			green = 1 - (delta/eps)^4;
		}
		else if (ref<1)
		{
			red=0.0;
			green=1.0;
		}
	}
	
	// SWTICH GREEN-RED
	if (mode==1){
		if (ref>1)
		{
			if (value<ref)
			{
				red=1.0;
				green=0.0;
			}
			else
			{
				red=0.0;
				green=1.0;
			}
		}
		else
		{
			red=1.0;
			green=0.0;
		}
	}

	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	if (dim<0)	ConsoleFilledRect(xmn+abx, ymn+dy/2+aby, dx-2*abx, -y);
	else		ConsoleFilledRect(xmn+abx, ymn+aby, dx-2*abx, -y);
	
	if ((abs(ref)>0.5)&&(abs(ref)<max)){
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(3);
		ConsoleLines([xmn+abx, ymn + ky*ref, xmn+dx-abx, ymn + ky*ref ]);
	}
	
	// BORDER BAR
	ConsoleColor(0.0,0.0,0.0,1.0);
	ConsoleWidth(width);
	ConsoleRect(xmn,ymn,dx,-dy);

	// ACTUAL VALUE LABEL
	ConsoleFont("Arial",fontscale*35);
	ConsoleColor(0.0,0.0,0.0,1.0);
	text = sprintf("%2.1f%s",value,unit);
	if (len(text)<=4)	Consoletext( xmn + 0.01, ymn - (0.04-dim*0.01), text);
	if (len(text)>4)	Consoletext( xmn, ymn - (0.04-dim*0.01), text);
	
	if (dim==0){
		// TICKS & LABEL
		ConsoleFont("Arial",fontscale*20);
		ConsoleWidth(width);
		ConsoleColor(0.0,0.0,0.0,1.0);
		for(var i=0; i<=maxF/10; i++){
			text = sprintf("%2.0f",(i*10));
			ConsoleLines([xmn,ymn + ky*(i*10),xmn - wt,ymn + ky*(i*10)]);
			Consoletext( xmn - 3*wt, ymn + ky*(i*10) - 0.008, text);
		}
	}
}

function SelezionaOggetto(Index)
{
	var currPos=[0.0,0.0,0.0];
	

	ADC_Bool=Device_xVR.DataIn[Index].Handle_Is_Pressed;
		
	if(ADC_Bool||space_grasp)   
	{
		Fgrab = 2.75;
	}
	else
	{
		Fgrab = 0;
	}
	#ifdef HOLD_MOVE	// GRASP ONLY TO CATCH THE CUBE AND AUTOMATICALLY HOLD IT TIL YOU PUT IN THE RIGHT POS		
		
		 
		if ((ADC_Bool && grasp_on==0 &&  !autoGrasp)|| space_grasp || autoGrasp)
		{
			grasp_on = 1;
		}

		// EMERGENCY MANUAL DISABLE OF GRASPING
		if(KeyPressed(VK_RETURN))
		{
			sel_obj=0;
			grasp_on=0;
		}
		
		if (grasp_on==1)
		{
			Select(currPos);
			isgrabbed=1;
		}
		else
		{
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
			isgrabbed=0;
		}
	#else	// GRASP AND RELEASE
		
		if((ADC_Bool &&  !autoGrasp)|| space_grasp || autoGrasp)
		{
			grasp_on = 1;
		}
		else
		{
			grasp_on = 0;
		}

		if((grasp_on==0)&&(sel_obj>0))
		{			
			m_cube[sel_obj-1].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
			o_cube[sel_obj-1].LinkToMesh(m_cube[sel_obj-1]);
			sel_obj=0;
		}
		
		if (grasp_on==1)
		{
			Select(currPos);
			isgrabbed=1;
		}
		else
		{
//			Select(currPos);
//			HFor = [0.0,0.0,0.0];
//			NFor = [0.0,0.0,0.0];
//			IsPressed = false;
//			isSelected = false;
//			isgrabbed=0;
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
			isgrabbed=0;
		}
	#endif	
	
	if (isSelected)
	{
		if(sel_obj>0)
	   		o_cube[sel_obj-1].AddForce(NFor[0], NFor[1], NFor[2]);
	}		 
	 temp_pos=currPos;
	 temp_isSelected=isSelected;
}

var ind=0;
var count_space_grasp = -1;
var meshForStrobo_0;
var meshForStrobo_1;
var stroboSwitch = 1;
var stroboCount = 0;
var stroboCount_max = 100;
//Called 1000 time/sec get the position of the grabbers and performs physic simulation


var PrimoGiro1234 = true;
var Tempo_Old = -1.0;
var Delta_Tempo_Told = 0.0;
var Delta_Tempo_Counter = 0;

var GuadagnoDiForza = 0.0;
var posOff = vector(3);






function OnTimer()
{
	
	var Index = 0;
	
	
	if(keypressed(VK_SPACE)){
		if(count_space_grasp == -1){
			if(!space_grasp)
				space_grasp = true;
			else 
				space_grasp = false;
			count_space_grasp = 0;
		}
	}
	if(count_space_grasp != -1){
		count_space_grasp = count_space_grasp + 1;
	}
	if(count_space_grasp == 1000){
		count_space_grasp = -1;
	}
	
	
	/* SELEZIONA QUALE CUBO RAGGIUNGERE */
	if(((grasp_on == 0) || (grasp_on == 1 && sel_obj == 0)) && cube_to_reach == -1){
		if(session == "Clock"){			
			cube_to_reach = clock_inc;
//			clock_inc+=1;	
		} else {
			cube_to_reach = h_class.FindClosestCube(pos, o_cube, free_cubes);	
		}
	}

	/* STROBO SUL CUBO */
	if(cube_to_reach != -1 && cube_to_reach <= 11){		
		if(stroboCount < stroboCount_max){
			stroboCount++;
		} else {
			stroboCount = 0;
			if(stroboSwitch == 1){
				stroboSwitch = 0;
				/* TEXTURE ON */
				o_cube[cube_to_reach].SetVisible(true);
			} else {
				/* TEXTURE OFF */				
				o_cube[cube_to_reach].SetVisible(false);
				stroboSwitch = 1;			
			}
		}	
	}

	// IF APP HAS NOT BEEN IDENTIFIED...
	if (!checkApp)
	{
		checkApp = true;		
	}
		
	EndInit = 1;
	
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Device_xVR.OnTimer();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	dev_pos = Device_xVR.DataIn[Index].EE_Pos;

	t_class = Transformation([scale_x,scale_y,scale_z],[0,0,0],"x",-PIGRECO/2);     
	
	posOff  = t_class.GetPos_DevToXvr(dev_pos);
	
	if(CAMERAMOD == true)
		posOff = GetDevXVR_cameraPos(pos);	//#CAMERAMOD
	
	pos[0] = posOff[0] - offset_x;
	pos[1] = posOff[1] - offset_y;
	pos[2] = posOff[2] - offset_z;

	
	
	if (oldHoff!=offset_x || oldDoff!=offset_z || oldVoff!=offset_y || oldScale_x!=scale_x || oldScale_y!=scale_y || oldScale_z!=scale_z)
	{
		posInit = pos;
		oldHoff = offset_x; 
		oldVoff = offset_y;  
		oldDoff = offset_z;
		oldScale_x = scale_x;
		oldScale_y = scale_y;
		oldScale_z = scale_z;
	}

	switch(stato)
	{
		case PUZZLE_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto(Index);
		break;
		case BASKET_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto(Index);
		break;
		case CLOCK_:
		    // Estimate Interaction Force Between Device And Selected Object
		    SelezionaOggetto(Index);
		break;
		default:
			HFor = [0.0,0.0,0.0];
			NFor = [0.0,0.0,0.0];
			IsPressed = false;
			isSelected=false;
			ScalaStiffObjSel=1.0;
		break;

	}//switch
	
		
	//============================================================================================
	// ASSIST
	//============================================================================================
	var result = h_class.RunHelp(&h_required, &grasp_on, sel_obj, session, pos, o_cube, free_cubes, &assistSet, cube_to_reach);
	if (assistSet==1)
	{		
		senddata("STOP_ASSIST");
		assistSet=0;
	}
    
    if (PrimoGiro1234)
	{
		Tempo_Old = GetPerformanceTimer()/1000000.0;
		Delta_Tempo_Told = GetPerformanceTimer()/1000000.0;
		
		PrimoGiro1234 = false;
	}
	
	
	var Tempo = GetPerformanceTimer()/1000000.0;
	Tempo_Old = Tempo;
	
	Delta_Tempo_Counter++;
	if ( (Tempo - Delta_Tempo_Told) > 1.0 )
	{
		Delta_Tempo_Medio = (Tempo - Delta_Tempo_Told) / Delta_Tempo_Counter;
		Delta_Tempo_Told = Tempo;
		Delta_Tempo_Counter = 0;
	}

    
	var posSfera1;
	var ForzaSfera;

		Device_xVR.DataOut[Index].EE_Force = [ 0.0, 0.0, 0.0 ];
		Device_xVR.DataOut[Index].EE_Imp_Matrix = MATRIX_EYE3;
		Device_xVR.DataOut_Start();
		
		//===============================================================
		// AGGIORNAMENTO STATO PER FISICS
		//===============================================================
		switch (Haptic_Control_Phase)
		{
			 case HCP_OFF:
				if (isForceEnabled)
					Haptic_Control_Phase = HCP_TOUCH;
			 break;
			 
			 
			 case HCP_TOUCH:
				if (h_required)
					Haptic_Control_Phase = HCP_ASSIST;
				else if(!isForceEnabled)
					Haptic_Control_Phase = HCP_OFF;
			 break;


			 case HCP_ASSIST:
			 	if (!h_required)
			 		Haptic_Control_Phase = HCP_TOUCH;
			 break;
		}
		
		
		
		//===============================================================
		// AGGIORNAMENTO STATO PER FISICS
		//===============================================================
		var xVR_Dev_EE_Force;
		
		switch (Haptic_Control_Phase)
		{
			 case HCP_OFF:
				sfera1.SetPosition(pos);
				sfera1.SetVelocity([ 0.0, 0.0, 0.0 ]);
			 break;
			 
			 
			 case HCP_TOUCH:
			 	if (GuadagnoDiForza < 1.0)
				{
					GuadagnoDiForza = GuadagnoDiForza + 1.0/(600.0*3);
					if (GuadagnoDiForza >= 1.0)
					{
						GuadagnoDiForza = 1.0;
					} 
				}
				
				xVR_Dev_EE_Force = Device_xVR.DataIn[Index].EE_Force;
//				trace(xVR_Dev_EE_Force);
				
				
				ForzaSfera = - ( t_class.GetVect_DevToXvr_WS(xVR_Dev_EE_Force) + NFor ) * GuadagnoDiForza;

    			sfera1.AddForce(forzaSfera[0], forzaSfera[1], forzaSfera[2]);
			 break;


			 case HCP_ASSIST:
				sfera1.SetPosition(pos);
				sfera1.SetVelocity([ 0.0, 0.0, 0.0 ]);
				GuadagnoDiForza = 0.0;
			 break;
		}
	

		//===============================================================
		// AGGIORNAMENTO FISICS
		//===============================================================
		RunPhysicsEngine(Delta_Tempo_Medio*1.8);
		
//		trace(Delta_Tempo_Medio);
		
		posSfera1 = sfera1.GetPosition();
		temp_pos_sfera = posSfera1;
		
//		trace(temp_pos_sfera);
		
		//===============================================================
		// AGGIORNAMENTO COMANDO ALEX
		//===============================================================
		var xVR_Dev_EE_Pos;
		
		switch (Haptic_Control_Phase)
		{
			 case HCP_OFF:
			 	TargetPos[0] = pos[0] + offset_x;
				TargetPos[1] = pos[1] + offset_y;
				TargetPos[2] = pos[2] + offset_z;
				xVR_Dev_EE_Pos = t_class.SetPos_XvrToDev(TargetPos);
				
				Device_xVR.DataOut[Index].EE_Stiffness = [0.0, 0.0, 0.0];
				Device_xVR.DataOut[Index].EE_Stiffness_Speed = 2000.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Viscosity = [0.0, 0.0, 0.0];
				Device_xVR.DataOut[Index].EE_Viscosity_Ass = [0.0, 0.0, 0.0];
				Device_xVR.DataOut[Index].EE_Pos = xVR_Dev_EE_Pos;
				
			 break;


			 case HCP_TOUCH:
			 	TargetPos[0] = posSfera1[0] + offset_x;
				TargetPos[1] = posSfera1[1] + offset_y;
				TargetPos[2] = posSfera1[2] + offset_z;
				xVR_Dev_EE_Pos = t_class.SetPos_XvrToDev(TargetPos);

		 		Device_xVR.DataOut[Index].EE_Stiffness = 1000.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Stiffness_Speed = 250.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Viscosity = 50.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Viscosity_Ass = 5.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Speed = 1000.0;
				Device_xVR.DataOut[Index].EE_Pos = xVR_Dev_EE_Pos;
				
			 break;
			 
			 
			 case HCP_ASSIST:
			 	if(result.reach)
				{
					TargetPos[0] = result.target[0] + offset_x;
					TargetPos[1] = result.target[1] + offset_y;
					TargetPos[2] = result.target[2] + offset_z;
					xVR_Dev_EE_Pos = t_class.SetPos_XvrToDev(TargetPos);
					GuadagnoDiForza = 0.0;
				}
			 	
		 		Device_xVR.DataOut[Index].EE_Stiffness = 1000.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Stiffness_Speed = 250.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Viscosity = 50.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Viscosity_Ass = 5.0 * [1.0, 1.0, 1.0];
				Device_xVR.DataOut[Index].EE_Speed = 0.05;
				
				if(result.reach)
				{
					Device_xVR.DataOut[Index].EE_Pos = xVR_Dev_EE_Pos;
				}
				
			 break;
		}
		
		Device_xVR.DataOut_UpDate();
}















function OnExit()
{
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DEVICE
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
	Device_xVR.OnExit();
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX	
	SendData("EXT");		
	outputln("EXIT");
	manager_psx.FreeMem();
}

//Checks if a cursor touch a cube
function grabbed()
{
//	for (var j=0;j<NUM_CUBES;j++){
//		if(manager_psx.InTouch(sfera1, o_cube[j])){
//			return true;
//		}
//	}
	if(sel_obj != 0)
		return true;
	else
		return false;
}

// Throw the grabbed cube automatically in the basket
function ThrowBasket()
{
	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].Type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();
			if(i==sel_obj-1)
			{				
							
				// DEFINE THE LIMIT WHERE THROWING THE CUBE
				if( (cubePos[0]<centerpuzzle[0]+BASKET_LIMITX*cube_size)&&(cubePos[0]>centerpuzzle[0]-BASKET_LIMITX*cube_size) )
				{				
					if( (cubePos[2]<centerpuzzle[2]+BASKET_LIMITZ*cube_size)&&(cubePos[2]>centerpuzzle[2]-BASKET_LIMITZ*cube_size) )
					{								
						if (modul(ddSx)<MAXSPEEDFORTHROW)
						{
							m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
							o_cube[i].LinkToMesh(m_cube[i]);
							mat_obj = sel_obj;
							sel_obj = 0;
							
							
							aadd(matched_cubes,mat_obj);
							
							for(var j=0; j<len(free_cubes); j++)
								if(free_cubes[j]==mat_obj)
									adel(free_cubes,j);
							
							manager_psx.DisableCollision(0,mat_obj);								
							
							for(var j=1; j<=NUM_CUBES; j++)
								manager_psx.DisableCollision(mat_obj,j);
							
							o_cube[i].Setvisible(false);//false
							
							
							SoundFX[SFX_DROP].Play();
							grasp_on=0;	// RELEASE CUBE
						}	//end ifv
					}	//end ifcubepos2
				}	//end ifcubepos0			
			}	//end ifsel_obj
		}	//end ifo_cube
}

//Moves the cube to the nearest position
//if it's in the right place plays a sound and makes the cube inamovable
function attachCube()
{
	var i=0;
	
	for(i=0; i<NUM_CUBES; i++)
		if( o_cube[i].Type==PHX_DYNAMIC)
		{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			if(i==sel_obj-1)
			{		
				var z,x;
				for(z=-1;z<=1;z++)
				{
					for(x=-1;x<=1;x++)
					{
						// CHECK THE DISTANCE BETWEEN PROXY AND CENTER OF CUBE TO BE GRASPED
						var b = {x*cube_size, cube_size, z*cube_size};
						mod = sqrt((cubePos[0] - b[0])*(cubePos[0] - b[0]) + (cubePos[1] - b[1])*(cubePos[1] - b[1]) + (cubePos[2] - b[2])*(cubePos[2] - b[2]));
						if(mod < cube_size/2)
						{
							if( x == i%3-1 && z == 1-floor((8-i)/3) )
							{
								o_cube[i].SetPosition([x,0.95,z]*cube_size);
								m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
								o_cube[i].LinkToMesh(m_cube[i]);
								cube_grid[i*2] = x;
								cube_grid[i*2+1] = z;
								o_cube[i].MakeKinematic();
//								outputln("MAKE KINEMATIC");
								o_cube[i].SetRotation(-90,[1,0,0]);
								
								mat_obj = sel_obj;
								sel_obj = 0;
								
								
								aadd(matched_cubes,mat_obj);
								
								for(var j=0; j<len(free_cubes); j++)
									if(free_cubes[j]==mat_obj)
										adel(free_cubes,j);										
								
								SoundFX[SFX_CLACK].Play();
								manager_psx.DisableCollision(0,mat_obj);
								
								for(var j=0; j<NUM_CUBES; j++)
									manager_psx.DisableCollision(mat_obj,j+1);
								
								
								grasp_on=0;	// RELEASE CUBE
							} //end ifxy
						} //end ifmod
						if(grasp_on==0)	break;
					}// end forx
					if(grasp_on==0)	break;
				}// end forz										
			}//end ifmodv
		}//end ifo_cube		
} //end function attachCube

// Attach the cube to the nearest grid-clock position
// if it's in the right place plays a sound and makes the cube inamovable
function attachClock()
{
	var i=sel_obj-1;	// SELECTED CUBE

	if (( i!=-1 )&&( o_cube[i].type==PHX_DYNAMIC ))
	{
			cubePos = o_cube[i].GetPosition();
			o_cube[i].GetVelocity(v);
			// MODULUS OF DISTANCE BETWEEN SELECTED CUBE AND ITS RIGHT CLOCK POSITION
			mod = modulus(cubePos - [ clock_position[i][0],cube_size,clock_position[i][2] ] );
			
			// IF CUBE IS CLOSE TO THE RIGHT POSITION...
			if(mod < cube_size/3)
			{
				o_cube[i].SetPosition([ clock_position[i][0],cube_size,clock_position[i][2] ]);
				m_cube[i].SubsetModulateMaterial(1,[1.0,1.0,1.0]);
				o_cube[i].LinkToMesh(m_cube[i]);
				o_cube[i].MakeKinematic();
//				outputln("MAKE KINEMATIC");
				o_cube[i].SetRotation(-90,[1,0,0]);
				o_cube[i].Setgravity(false);
				o_cube[i].Setvisible(true);
				mat_obj = sel_obj;
				sel_obj = 0;
				
				aadd(matched_cubes,mat_obj);
				
				for(var j=0; j<len(free_cubes); j++)
					if(free_cubes[j]==mat_obj)
						adel(free_cubes,j);
				
				SoundFX[SFX_CLACK].Play();
				manager_psx.DisableCollision(0,mat_obj);	// DISABLE COLLISION WITH PROXY
				
				// DISABLE COLLISION WITH THE OTHER CUBES
				for(var j=0; j<NUM_CUBES; j++)
					manager_psx.DisableCollision(mat_obj,j+1);
				
				
				grasp_on=0;	// RELEASE CUBE
				clock_inc+=1;
			} //end ifmod
			
			if(grasp_on==0)
			{
				
				LoadCube();
				break;
			}
	}//end ifo_cube		
} //end function attachClock


#define CAMERA_SPEED 0.97//0.97
#define CAMERA_DIST  0.05
#define CAMERA_ROT	0.96//0.94
#define ALPHA_TOL	0.002
#define TARGET_SPEED 0.95//0.95
#define TARGET_DIST  0.0001
#define ALPHAOFF	0.0
/****************************************/
/*		  	    MoveCameraTo			*/
/****************************************/
function MoveCameraTo(x,y,z,startangle)
{
	var temp;
	var dist;
	var camdir;
	var axis;
	var speed=CAMERA_SPEED;
	var alphaspeed=CAMERA_ROT;
	static var alpha=0;

	temp=CameraGetPosition();
	camdir=Cameragetdirection();
	// UPDATING ORIENTATION (ONLY FOR 2D)...
	if(abs(startangle)>0.0)	alpha = (startangle+ALPHAOFF) - ( (startangle+ALPHAOFF) - alpha )*alphaspeed;

	// UPDATING POSITION...
	temp[0] = x - (x-temp[0])*speed;
	temp[1] = y - (y-temp[1])*speed;
	temp[2] = z - (z-temp[2])*speed;

	dist=((temp[0]-x)^2)+((temp[1]-y)^2)+((temp[2]-z)^2);
	
	if(dist>=CAMERA_DIST)	CameraSetPosition(temp);
	if(abs(startangle)>0.0)
	{
		CameraFree();
		CameraRotate(alpha,-camdir);
	}
	
	if(dist<CAMERA_DIST) 
	{
		if( ((abs(startangle)>0.0)&&(abs(startangle+ALPHAOFF-alpha)<ALPHA_TOL)) || (abs(startangle)==0.0))
		{
			return 1;
		}
		else return 0;
	}
	else return 0;
}

function ManageCollision()
{
	var init_radius;
	var init_ang;

	init_radius = CIRCLE_RADIUS*cube_size;
	
	if(session=="Clock")
	{
		for (var j=0;j<NUM_CUBES;j++)
		{	// SET VISIBLE ONLY THE FIRST CUBE IN THE CENTER OF THE "CLOCK"
			if(j>0)
			{
				manager_psx.DisableCollision(1,j+1);	// COLLISION AMONG FIRST AND ALL OTHER CUBES
				manager_psx.DisableCollision(0,j+1);	// COLLISION AMONG PROXY AND ALL OTHER CUBES
			}
		}
	}
	else
	{
		for (var j=0;j<NUM_CUBES;j++)
		{
			manager_psx.EnableCollision(floor_colgr,j+1);
			manager_psx.EnableCollision(0,j+1);
			for (var k=j;k<NUM_CUBES;k++)
				manager_psx.EnableCollision(j,k+1);
		}
		
		if(on_session[2]==1)
		{
			init_ang = 0;
			for(var j=NUM_CUBES; j<NUM_CUBES+3; j++)
			{
				cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*cube_size, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
				o_cube[j].SetPosition(cube_position[j]);
				o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
				init_ang = init_ang - 2*PI/12;
			}
		}		
	}
}

function InitPositions()
{
	var i,j;
	var init_radius;
	var init_ang;

	if(session=="Clock")
	{
		init_radius = CIRCLE_RADIUS*cube_size;
		init_ang = PI - 2*PI/12;	
		// DEFINE A GRID FOR THE POSITION OF CUBES AT THE CLOCK NUMBERS
		for (j=0;j<NUM_CUBES;j++)
		{	// INIT THE CUBEGRID FOR THE FINAL CHECK 
			cube_grid[j*2] = 0.0;
			cube_grid[j*2+1] = 0.0;			
			clock_position[j] = [ init_radius*sin(init_ang), 0.2*cube_size, init_radius*cos(init_ang) ] + CenterPuzzle;
			// INIT THE VIRTUAL CUBES OF CLOCK (FOR DEBUG)
			v_cube[j].SetPosition(clock_position[j]);
			v_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
			
			// INIT THE CUBE OBJECTS IN A VERTICAL QUEUE UNDER THE FLOOR
			if(j==0)
				cube_position[j] = [ 0.0, 0.0, 0.0 ] + CenterPuzzle;
			else
				cube_position[j] = [ 3*init_radius*sin(init_ang), 0.2*cube_size, 3*init_radius*cos(init_ang) ] + CenterPuzzle;
			
			o_cube[j].SetPosition(cube_position[j]);
			o_cube[j].SetRotation(-90,[1.0,0.0,0.0]);
			//o_cube[j].SetMass(0.1);
			init_ang = init_ang - 2*PI/12;
		}		
//		outputln("++++++++++++++++++++++++++++++");	
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
//		outputln("++++++++++++++++++++++++++++++");	
	
	}
	else
	{	
		init_radius = CIRCLE_RADIUS*cube_size;
		init_ang = 0;
		for (j=0;j<NUM_CUBES;j++)
		{
			i = IniGrid[j];
			// INIT THE CUBEGRID FOR FINAL CHECK 
			cube_grid[i*2] = 0;
			cube_grid[i*2+1] = 0;
			// THE CUBE_GRID REPRESENTS ONLY A INITIAL VIRTUAL DISPLACEMENT OF THE CUBES
			// THE SAME USED IN THE 3D VIEW
			cube_position[i] = [ init_radius*sin(init_ang), cube_size/2.0, init_radius*cos(init_ang) ] + CenterPuzzle;
			o_cube[i].SetVisible(true);	
			o_cube[i].SetPosition(cube_position[i]);
			o_cube[i].SetRotation(-90,[1.0,0.0,0.0]);
			init_ang = init_ang + 2*PI/9;
		}
		
//		outputln("++++++++++++++++++++++++++++++");	
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Type(",m,")=",o_cube[m].type);
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].getPosition());
//		for(var m=0; m<NUM_CUBES; m++)	outputln("Pos(",m,")=",o_cube[m].isvisible());
//		outputln("++++++++++++++++++++++++++++++");	
	}
	h_class = Help(NUM_CUBES, cube_size, centerpuzzle, centerbasket, clock_position);
	
	if(cube_to_reach != -1 && cube_to_reach <= 11){
		o_cube[cube_to_reach].SetVisible(true);	
	}		
	cube_to_reach = -1;
}

function DrawPolygonXZ(my_texture,fromx,tox,fromz,toz,y)
{
	SetActiveTexture(my_texture);
	glDisable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glRotate(0.0,0.0,1.0,0.0);
	glBegin(GL_QUADS);
		
	glTexCoord(1,0);
	glVertex(tox, y, toz);	
			
	glTexCoord(0,0);
	glVertex(fromx, y, toz);	
				
	glTexCoord(0,1);
	glVertex(fromx, y, fromz);	
				
	glTexCoord(1,1);
	glVertex(tox, y, fromz);	
	glEnd();

	glDisable(GL_TEXTURE_2D);
	
	glColor(0.61,0.1,0.12);
	glBegin(GL_QUADS);		
	glVertex(tox  +0.005, y-0.0025, toz  +0.005);					
	glVertex(fromx-0.005, y-0.0025, toz  +0.005);	
	glVertex(fromx-0.005, y-0.0025, fromz-0.005);	
	glVertex(tox  +0.005, y-0.0025, fromz-0.005);	
	glEnd();
	glEnable(GL_LIGHTING);
}

function DrawGrid()
{
	var i;
	var size = cube_size;
	glLineWidth(1);
	glBegin(GL_QUADS);
	for(i = -1; i<= 1; i++){
		glColor(0.7-i*0.3, 0.7-i*0.3, 0.7-i*0.3);
		glVertex(+size/2 + i *size, cube_size/2 + 0.001, -cube_size/2);
		glVertex(-size/2 + i *size, cube_size/2 + 0.001, -cube_size/2);
		glVertex(-size/2 + i *size, cube_size/2 + 0.001, -cube_size/2+size);
		glVertex(+size/2 + i *size, cube_size/2 + 0.001, -cube_size/2+size);
	}
	glEnd();
}

function DrawLine(pos1,pos2,r,g,b)
{
	glLineWidth(5);
	glColor(r, g, b);
	glEnable(GL_BLEND);
	glDisable(GL_LIGHTING);
	glBegin(GL_LINES);
	
	glVertex(pos1[0], pos1[1], pos1[2]);
	glVertex(pos2[0], pos2[1], pos2[2]);

	glEnd();
	glEnable(GL_LIGHTING);
	glDisable(GL_BLEND);
}

// simple receiver on udp port, eat all data
function ReceiveData(UDP_Channel)
{
	while(true)
	{
		var address;
		var data = NetVarReceiveFrom(UDP_Channel, &address);				
		if(data != Void) {				
		
			ProcessData(data);
		}
		else
			break;
	}
}

// simple sender on udp port, eat all data
function SendData(data)
{
	NetVarSendTo("127.0.0.1", GUI_port, data);
}

// Processes all instructions that are received from the UDP channel
function ProcessData(data)
{
	static var GravityPercentage=0.0;
	
	if(data[0] == "armLeft")
	{
		Device_xVR.Set_Index_To_Arm_Map(0,1);		
		Device_xVR.Disable_Index(1);		
		Device_xVR.Disable_Arm(0);
	}
	
	if(data[0] == "armRight")
	{
			Device_xVR.Set_Index_To_Arm_Map(0,0);		
			Device_xVR.Disable_Index(1);
			Device_xVR.Disable_Arm(1);
	}	
	
	// COMMAND TO CLOSE APPLICATION
	if(data[0] == "CloseApp") {
		SendData("EXT");
		application.quit();
		outputln("QUIT");
	}
	
// COMMAND TO LOAD THE PUZZLE
	if((session!="Clock")&&(data[0]=="PUZ"))
	{
		outputln(data[1]);
		if(data[1]=="Random")
		{
	 		puzzle=immagini[rand(len(immagini)-1)];	 		
//	 		ReloadPuzzle();
		}
		else
		{
			puzzle=data[1];
//			ReloadPuzzle();
		}

		temp_puzzle = puzzle;
	}	

	prev_session = session;
	switch(data[0])
	{
		case "Basket":		// SWITCH TO BASKET SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			on_session[1]=1;
			temp_puzzle = puzzle;
			puzzle="basket";
			ReloadPuzzle();
			stato=INTRO_;
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			InitPositions();			
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Puzzle":			// SWITCH TO PUZZLE SESSION
			session = data[0];
			NUM_CUBES=9;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9};
			total_time = 0.0;
			SetIniGrid();
			puzzle = temp_puzzle;	// LOAD THE PREVIOUS PUZZLE (BEFORE TO LOAD CLOCK OR BASKET)
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
		
		case "Clock":			// SWITCH TO CLOCK SESSION
			session = data[0];			
			NUM_CUBES=12;
			IsPressed = false;
			isSelected = false;
			grasp_on = 0;
			sel_obj	= 0;
			mat_obj = 0;
			matched_cubes = {};
			free_cubes = {1,2,3,4,5,6,7,8,9,10,11,12};
			total_time = 0.0;
			temp_puzzle = puzzle;
			puzzle = "clock";
			for(var i=0;i<NUM_CUBES;i++)	IniGrid[i] = i;
			ReloadPuzzle();
			stato=INTRO_;
			InitPositions();
			startedtask=false;
			reqscore = false;
			scoreloaded = false;
		break;
	}
	
// ============== SELECT THE GRASPING THRESHOLD ==============
	if(data[0] == "GraspingValue")
	{
		ADC_TSHOLD = data[1];		
	}
// ===========================================================


// ============== SELECT THE DAMPING FACTOR ==============
	if(data[0] == "ViscosityValue") 
	{
		damper = data[1];	// DAMPING FACTOR
	}
// ===========================================================



// ============== RECEIVE SCORE DATA ==============
	if((data[0]=="SCORE")&&(!scoreloaded))
	{
		scores = data[1];
		scoreloaded = true;
	}
// ====================================================


// ============== PLOT DATA ==============
	if((data[0]=="PlotData")&&(stato==INTRO_))
	{
		plotdataon = !plotdataon;
	}
// ====================================================


// ============== COMMAND TO ENABLE FORCE ==============
	if(data[0] == "ForceOn")
	{
	    isForceEnabled=!isForceEnabled;
	}
	if(isForceEnabled)	ForceStatus=1;
	else				ForceStatus=0;
// ====================================================

// ============== COMMAND TO ENABLE CLOSE CONTROL FORCE OR FEEDFORWARD FRICTION MODEL ==============
	if(data[0] == "Compensation")
	{
		forcecontrol_flag = data[1];	
	}
// ====================================================


// ============== PATIENTS LIST FEEDBACK ==============
// Protocol: <"Patients",size,nome[0],nome[1],...,nome[size-1]>
//			 < data[0],data[1],data[2],....>
	if(data[0] == "Patients")
	{
		for (var j=0;j<data[1];j++)		aadd(lista_pazienti,data[j+2]);
	}
// ====================================================

// ========== SCALE & REPLACEMENT COMMANDS ============
// CHANGE ONLY IF FORCE IS DISABLED
	if(data[0] == "SetOffset")
	{
		offset_x = pos[0];
		offset_y = pos[1];
		offset_z = pos[2];
		senddata(sprintf("offset_x,%f",pos[0]));
		senddata(sprintf("offset_y,%f",pos[1]));	
		senddata(sprintf("offset_z,%f",pos[2]));		
	}		
			
	if(data[0] == "offset_x_Saved")	
		offset_x = data[1];
		
	if(data[0] == "offset_y_Saved")
		offset_y = data[1];
		
	if(data[0] == "offset_z_Saved")
		offset_z = data[1];		
	
	if(data[0] == "SetOffsetDefault")
	{
		offset_x = 0;
		offset_y = 0;
		offset_z = 0;	
	}					
			
	if(data[0] == "ScaleValueX")		
		scale_x=data[1]+3;
		
	if(data[0] == "ScaleValueY")
		scale_y=data[1]+3;
		
	if(data[0] == "ScaleValueZ")
		scale_z=data[1]+3;

// ====================================================

// ========== LOG COMMAND ============
	if (data[0]=="StartLog")
	{
	}
	if (data[0]=="StopLog")
	{
	}
	if (data[0]=="SaveLog")
	{
	}

// ========== GRAVITY COMPENSATION COMMAND ============
	if(data[0] == "ChangeBodyMass") {
		BodyMass = data[1];
		if(BodyMass < 30.0)	BodyMass = 30.0;
		if(BodyMass > 120.0)	BodyMass = 120.0;
	}

	if(data[0] == "ChangeGravityCompensation") {
		GravityPercentage = 0.01*data[1];
		if(GravityPercentage < 0.0)
			GravityPercentage = 0.0;
	}

	if(data[0] == "GravCompOn") {
		GravityOn = 1.0;
	}
	if(data[0] == "GravCompOff") {
		GravityOn = 0.0;
	}

	GravityComp = GravityOn * GravityPercentage;
// ===============================================


  	if (data[0]=="StartPos")
  	{
  		activeInitPos =true;
  		Init_pos=true;  		
  	}


	if(data[0] == "EnableHelp")
	{
		h_required=true;		
	}
	
	if(data[0] == "DisableHelp")
	{
		h_required=false;		
	}
	
	if(data[0]=="AutoGraspOn")
	{
		autoGrasp=true;
	}
	
	if(data[0]=="AutoGraspOff")
	{
		autoGrasp=false;
	}

}

function disp(x,y,stri,row,col,fontsize,trasparency)
{
	var len_stri=len(stri)*tofloat(fontsize)/3400.0;
	var h = tofloat(fontsize)/600.0;
	var xs = x-len_stri/2;
	var ys = y-row*h;
	ConsoleFont("Impact",fontsize);
	ConsoleColor(1.0,1.0,1.0,0.7*trasparency);
	ConsoleFilledRect(xs-0.01, ys+h*5.0/6.0, len_stri+0.0, h);
	
	switch(upper(col))
	{
		case "K":	ConsoleColor(0.0,0.0,0.0,trasparency);break;
		case "R":	ConsoleColor(1.0,0.0,0.0,trasparency);break;
		case "B":	ConsoleColor(0.0,0.0,1.0,trasparency);break;
		case "G":	ConsoleColor(0.0,1.0,0.0,trasparency);break;
		default:	ConsoleColor(1.0,1.0,1.0,trasparency);break;
	}
	
	Consoletext(xs,ys,stri);
}

function plot(data,title)
{
	var t, w, h, h_1;
	var text;
	var x_0, y_0, x_1; 	// BAR DATA ORIGIN
	var alpha = 0.7;		// TRANSPARENCY
	var red = [1.0,0.0,0.0,alpha];
	var blue = [0.0,0.0,1.0,alpha];
	var green = [0.0,1.0,0.0,alpha];
	var black = [0.0,0.0,0.0,alpha];
	var gray = [0.5,0.5,0.5,alpha];
	var white = [1.0,1.0,1.0,alpha];
	var delta;	// SPACE AMONG BARS
	var wb;		// WIDTH AND HEIGHT OF EACH BAR
	var s;		// b+delta
	var max_label;
	var max_data=0;
	var xlabel="";
	var y_tick = {0.0};
	
	w = 0.6;
	x_0 = 0.6 - w/2;
	y_0 = 0.2;
	h = 0.6;
	h_1 = 0.8*h;
	t = 3;
	s = w / len(data);
	delta = 0.2*s;
	wb = s - delta;
	max_data=max(data);
	max_label=sprintf("%3.1f",h*max_data/h_1);

	// FILL PLOT
	ConsoleColor(white.r,white.g,white.b,1);
	ConsoleFilledRect(x_0,y_0,w,-h);
	ConsoleWidth(t);
	// DATA LABEL
	var tick = ceil(max_data / 4);

	if(tick>=100)
		tick=ceil(tick/100)*100;
	else
		if(tick>=10)
			tick=ceil(tick/10)*10;
		else
			tick=ceil(tick);

	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleFont("Arial",30);
	for(var i=0;i<6;i++)
	{
		Consoletext( x_0 - len(sprintf("%d",y_tick[i]))*0.025, y_0 +(h_1/max_data*y_tick[i])-0.015, sprintf("%d",y_tick[i]) );
		ConsoleLines( [x_0, y_0, x_0 - 0.01, y_0] );
		if(i>0)
		{
			ConsoleColor(gray.r,gray.g,gray.b,gray.a);
			ConsoleLines( [x_0, y_0 +(h_1/max_data*y_tick[i]), x_0 + w, y_0 +(h_1/max_data*y_tick[i])] );
			ConsoleColor(black.r,black.g,black.b,black.a);
		}
		aadd(y_tick, i*tick);
	}
	if((max_data - y_tick[5])>=tick)
	{
		Consoletext( x_0 - len(max_label)*0.02, y_0 + h - 0.015, max_label);
		ConsoleLines( [x_0, y_0 + (h-0.002), x_0 - 0.01, y_0 + (h-0.002)] );
	}	
	// PLOT DATA
	ConsoleColor(green.r,green.g,green.b,green.a);
	x_1 = x_0 + delta/2;
	for(var i=0;i<(len(data)-1);i++)
	{
		ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[i]) );
		if( ((wb<0.05)&&((i==0)||(i==4)||(i==9))) || (wb>=0.05) )
		{
			// X LABEL
			ConsoleFont("Arial",30);
			ConsoleColor(black.r,black.g,black.b,black.a);
			xlabel = sprintf("%d",i+1);
			Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);
		}
		ConsoleColor(green.r,green.g,green.b,green.a);
		x_1 = x_1 + wb + delta;
	}
	ConsoleColor(red.r,red.g,red.b,red.a);
	ConsoleFilledRect(x_1 ,y_0,wb,-(h_1/max_data*data[len(data)-1]) );
	// X LABEL
	ConsoleFont("Arial",30);
	ConsoleColor(black.r,black.g,black.b,black.a);
	xlabel = sprintf("%d",len(data));
	Consoletext( x_1 + wb/2 - len(xlabel)*0.01/2, y_0 - 0.05, xlabel);
	// BORDER PLOT
	ConsoleColor(black.r,black.g,black.b,black.a);
	ConsoleRect(x_0,y_0,w,-h);
	// X LABEL
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0 + w/2 - 0.015*len("SESSIONI")/2, y_0 - 0.1, "SESSIONI");
	// Y LABEL
	var x_0label = 0.045;
	ConsoleFont("Arial",40);
	ConsoleColor(red.r,red.g,red.b,1);
	Consoletext( x_0  - (x_0label+0.008)*len("TEMPO"), y_0 + h/2, "TEMPO");
	Consoletext( x_0  - x_0label*len("TOTALE"), y_0 + h/2 - 0.05, "TOTALE");
	Consoletext( x_0  - (x_0label+0.015)*len("(s)"), y_0 + h/2 - 2*0.05, "(s)");
	// TITLE
	if(len(title)>0)
	{
		var fontsize=50;
		ConsoleFont("Arial",fontsize);
		ConsoleColor(red.r,red.g,red.b,1);
		Consoletext( x_0 + w/2 - 0.04*len(title)/2, y_0 + (h+0.05), title);
	}
}

function TaskBar()
{
	var grasp=0;
	var dark = [0.5,0.5,0.5];
	var light = [0.8,0.8,0.8];
	var plane = [0.7,0.7,0.7];
	var stri = "";
	var dim;
	var dot=0.0008;
	var x_s = 0;	// X separator
	var x_t = 0;	// X text
	var fonttype = "Impact";
	var fontsize = 25;
	var wt = fontsize*0.0005;	// Width of a char in normalized coordinates of consoletext
	var h = 0.05;
	// GRASPING
	var ref=2.5;
	var value=Fgrab;
	var maxF=6.0, max=0.1;
	var red=0.0, green=0.0;
	
	ConsoleColor(plane.r,plane.g,plane.b);
	ConsoleWidth(1);
	ConsoleFilledRect(0.0,1.0, 1.0,h);	
	// SHADOWED BORDER
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([0.0,1.0, 0.0,0.95, 1.0,0.95]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(2);
	ConsoleLines([0.0,1.0, 1.0,1.0, 1.0,0.95]);
	// PHASE NAME
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
	if(paziente=="<Paziente>")
		stri = sprintf("Name:%s",session);
	else
		stri = sprintf("%s:%s",paziente,session);
	dim=len(stri)*wt;
	x_t = x_s + wt;
	x_s = x_t + dim + 0.01*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// FORCE FEEDBACK ENABLE
	ConsoleFont(fonttype,fontsize);	
	ModuleForce=0;
	stri = sprintf("%2.1fN",ModuleForce);//"FORCE";//(F7)";
	ConsoleColor(0.3,1.0,0.3,1.0);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);	
	// GRASPING FORCE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = "GRASP";
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.01*wt;
	Consoletext(x_t,0.965,stri);
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleFilledRect(x_s,1-10*dot,max,h-20*dot);
	if (ref>1)
	{
		if (value<ref)
		{
			red=1.0;
			green=0.0;
		}
		else
		{
			red=0.0;
			green=1.0;
		}
	}
	else
	{
		red=1.0;
		green=0.0;
	}
	ConsoleColor(red,green,0.0,1.0);
	ConsoleWidth(1);
	ConsoleFilledRect(x_s, 1-10*dot, max/maxF*value, h-20*dot);
	if ((abs(ref)>=0.0)&&(abs(ref)<=maxF))
	{
		// BLUE REF BAR LINE
		ConsoleColor(0.0,0.0,1.0,1.0);
		ConsoleWidth(2);
		ConsoleLines([x_s+max/maxF*ref, 1-h+10*dot, x_s+max/maxF*ref, 1-10*dot ]);
	}
	x_s = x_s + max + 0.01;
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// RADIUS
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0,1.0);
 	//stri = sprintf("Radius=%2.1fcm",(CIRCLE_RADIUS*cube_size/3.0)*100*2);
 	if(temp_check_force)
 	 grasp = 1;
 	else
 	 grasp=0;
 	 stri = sprintf("Status %2d ",grasp);	
 	//stri = sprintf("Force=%2.1f %2.1f %2.1f",HFor[0],HFor[1],HFor[2]);		
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// BODY MASS - PERCENTAGE
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("%1.0f%%OF%2.0fkg",GravityComp*100,BodyMass);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
	// DAMPER
	ConsoleFont(fonttype,fontsize);
	ConsoleColor(0.0,0.0,0.0);
	stri = sprintf("VISC:%1.0fNs/m",damper);
	dim=len(stri)*wt;
	x_t = x_s + 0.5*wt;
	x_s = x_t + dim + 0.5*wt;
	Consoletext(x_t,0.965,stri);
	// SHADOWED SEPARATOR
	ConsoleColor(dark.r,dark.g,dark.b);
	ConsoleWidth(1);
	ConsoleLines([x_s,0.995, x_s,0.955]);
	ConsoleColor(light.r,light.g,light.b);
	ConsoleWidth(1);
	ConsoleLines([x_s-dot,0.995, x_s-dot,0.955]);
}

function modul(v)
{
	return sqrt(v[0]^2+v[1]^2+v[2]^2);
}

function max(a)
{
	var max=0.0;
	max = a[0];
	for(var i=1;i<len(a);i++)
	{
		if(a[i]>max)
		{
		max = a[i];
		}
	}
	return max;
}

function view_plot()
{
	if(!reqscore) //IF NOT ALREADY REQUESTED...
	{
		senddata(sprintf("LOAD,%s",session));		// RECEIVE SCORE HISTORY FROM GUI
		reqscore = true;		
	}

	if(valtype(scores)=="A")	// IF SCORES IS AN ARRAY
	{
		if(len(scores)>1)	// AND IF ITS LENGTH IS GREATER THAN 1
		{
			plot(scores,"");
		}
		else
		{			
			disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
		}
	}
	else	// IF FIRST TRIAL FOR THE ACTUAL PATIENT
	{
		disp(0.47,0.8,"NO DATA TO PLOT",0,"R",60,1);
	}
}

/**
 * Retrives the Camera Transofmration Matrix
 */
function GetCameraTransfMatrix(){
	var camera_RM = CameraGetCurrent().GetRotationMatrix3();
	var camera_TM = CameraGetCurrent().GetRotationMatrix();		
	var camera_POS = CameraGetCurrent().GetPosition();
	camera_TM[3] = camera_POS[0];
	camera_TM[7] = camera_POS[1];
	camera_TM[11] = camera_POS[2];
	
	var camera_RMt = vector(9);
	camera_RMt = MatrixTranspose_3(camera_RM);
	var neg_camera_RMt = vector(9);
	for (var i=0;i<len(camera_RMt);i++){
		if(camera_RMt[i] != 0)
			neg_camera_RMt[i]=camera_RMt[i]*(-1);
	}
		
	var camera_POSi = vector(3);
	camera_POSi[0] = neg_camera_RMt[0]*camera_POS[0] + neg_camera_RMt[1]*camera_POS[1] + neg_camera_RMt[2]*camera_POS[2];
	camera_POSi[1] = neg_camera_RMt[3]*camera_POS[0] + neg_camera_RMt[4]*camera_POS[1] + neg_camera_RMt[5]*camera_POS[2];
	camera_POSi[2] = neg_camera_RMt[6]*camera_POS[0] + neg_camera_RMt[7]*camera_POS[1] + neg_camera_RMt[8]*camera_POS[2];
	
	var camera_TMi = vector(16);
	camera_TMi[0] = camera_RMt[0];	camera_TMi[1] = camera_RMt[1]; 	camera_TMi[2] = camera_RMt[2];	camera_TMi[3] = camera_POSi[0];
	camera_TMi[4] = camera_RMt[3];	camera_TMi[5] = camera_RMt[4]; 	camera_TMi[6] = camera_RMt[5];	camera_TMi[7] = camera_POSi[1];
	camera_TMi[8] = camera_RMt[6];	camera_TMi[9] = camera_RMt[7]; 	camera_TMi[10] = camera_RMt[8];	camera_TMi[11] = camera_POSi[2];
	camera_TMi[12] = 0;				camera_TMi[13] = 0; 			camera_TMi[14] = 0;				camera_TMi[15] = 1;

	matrixCamera_DEV_to_XVR = camera_TM;
	matrixCamera_XVR_to_DEV = camera_TMi;
}

function GetDevXVR_cameraPos(pos){
	var ee_position_4 = vector(4);
	var ee_position_3 = vector(3);
	ee_position_4 = [pos[0], pos[1], pos[2], 1];
	ee_position_4 = MatrixMultiplyVector_4(matrixCamera_DEV_to_XVR,ee_position_4);
	ee_position_3 = [ee_position_4[0],ee_position_4[1],ee_position_4[2]]; 
	return ee_position_3;
}

function GetXVRDev_cameraPos(pos){
	var ee_position_4 = vector(4);
	var ee_position_3 = vector(3);
	ee_position_4 = [pos[0], pos[1], pos[2], 1];
	ee_position_4 = MatrixMultiplyVector_4(matrixCamera_XVR_to_DEV,ee_position_4);
	ee_position_3 = [ee_position_4[0],ee_position_4[1],ee_position_4[2]]; 
	return ee_position_3;
}

function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false;				
	static var PrecX = 0, PrecY = 0;			

	// Change these values to modify the mouse sensitivity
	var TR_SENSITIVITY  = 0.001;
	var ROT_SENSITIVITY = 0.01;

	if (Mouse.ButtonL && !Mouse.ButtonR)
	{
		/* left button: camera rotation */
		if (InMouseL)
		{			
			CameraRotate((Mouse.X - PrecX) * ROT_SENSITIVITY, 0, 1, 0);
			CameraRotateABS((Mouse.Y - PrecY) * ROT_SENSITIVITY, 1, 0, 0);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseL = true;
		InMouseR = false;
	}
	else if (Mouse.ButtonR)
	{
		/* right button: camera translation */
		if (InMouseR)
		{
			var CameraMatrix = CameraGetMatrix();
			var CameraPos = CameraGetPosition();
			if (!Mouse.ButtonL)
			{
				var z_trasl = CameraGetZAxis() * (Mouse.y - PrecY);
				var x_trasl = CameraGetXAxis() * (Mouse.X - PrecX);
				CameraPos += (TR_SENSITIVITY * (z_trasl + x_trasl));
			}
			else
			{
				var y_trasl = CameraGetYAxis() * (Mouse.y - PrecY); 
				CameraPos -= (TR_SENSITIVITY * y_trasl);
			}
			CameraSetPosition(CameraPos);		
		}
		else
		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
		}
		InMouseR = true;
		InMouseL = false;
	}	
	else
	{
		InMouseR = false;
		InMouseL = false;
	}

}