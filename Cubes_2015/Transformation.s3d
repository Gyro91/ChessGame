Class Transformation
{
	var scale;	
	var offset;
	var offsetInv;
	var matRot;
	var matRotTrp;
	var matRotTrpNeg;
	var type;
	var angle;
	
	GetPos_DevToXvr(pos_dev);
	SetPos_XvrToDev(pos_xvr);
	GetVect_DevToXvr_WS(vect_dev);
	SetUpRotationMatrix(type,angle);
};

function Transformation::Transformation(scl, off,type,angle){
	scale = scl;	
	offset = off;
	matRot = SetUpRotationMatrix(type,angle);		 
	matRotTrp=MatrixTranspose_3(matRot);
	matRotTrpNeg=vector(9);	
	for (var i=0;i<len(matRotTrp);i++)
	{
		if (matRotTrp[i]!=0)	
			matRotTrpNeg[i]=matRotTrp[i]*(-1);				
	}
	offsetInv = MatrixMultiplyVector_3(matRotTrpNeg,offset);		
}

function Transformation::GetPos_DevToXvr(pos_dev){
	var pos_xvr = vector(3);
	
	for(var i=0; i<3; i++)
		pos_dev[i] = pos_dev[i]*scale[i];
		
	pos_xvr[0]=(matRot[0]*pos_dev[0])+offset[0];
	pos_xvr[1]=(matRot[4]*pos_dev[1])+(matRot[7]*pos_dev[2])+offset[1];
	pos_xvr[2]=(matRot[5]*pos_dev[1])+(matRot[8]*pos_dev[2])+offset[2];
	return pos_xvr;
}

function Transformation::GetVect_DevToXvr_WS(vect_dev){
	var vect_xvr = vector(3);
	
	vect_xvr[0]=(matRot[0]*vect_dev[0]);
	vect_xvr[1]=(matRot[4]*vect_dev[1])+(matRot[7]*vect_dev[2]);
	vect_xvr[2]=(matRot[5]*vect_dev[1])+(matRot[8]*vect_dev[2]);
	return vect_xvr;
}

function Transformation::SetPos_XvrToDev(pos_xvr){	
	var pos_dev = vector(3);
	pos_dev[0]=(matRotTrp[0]*pos_xvr[0])+offsetInv[0];
	pos_dev[1]=(matRotTrp[4]*pos_xvr[1])+(matRotTrp[7]*pos_xvr[2])+offsetInv[1];
	pos_dev[2]=(matRotTrp[5]*pos_xvr[1])+(matRotTrp[8]*pos_xvr[2])+offsetInv[2];
	
	for(var i=0; i<3; i++)
		pos_dev[i] = pos_dev[i]/scale[i];
	
	return pos_dev;	
}

/*!
 * \param	angle	float	rotation angle in radiants
 */
function Transformation::SetUpRotationMatrix(type,angle)
{
	var RotationMatrix;
	switch(type)
	{
		case "x":
		RotationMatrix=[1,0,0,0,cos(angle),sin(angle),0,-sin(angle),cos(angle)];		 
		break;
		
		case "y":
		RotationMatrix=[cos(angle),0,-sin(angle),0,1,0,sin(angle),0,cos(angle)];
		break;
		
		case "z":
		RotationMatrix=[cos(angle),sin(angle),0,-sin(angle),cos(angle),0,0,0,1];
		break;
	}
	return RotationMatrix;
}





