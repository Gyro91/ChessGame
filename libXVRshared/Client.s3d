 /*
  *  This library implements all the classes and functions for the Client side
  * 
  */
 #include "Packet.s3d"
 #include "HandClass.s3d"
 
 class Client {
 	
 	var server_address;
	var udp_server_port;
 	var udp_client_port;
 	var id_channel;
 	var pkt_hand_l, pkt_hand_r;
 	var remote_hand_r; 
 	var remote_hand_l; 
 	
 	conf(s_address, s_port, c_port);
 	init();
 	step(hand_r, hand_l);
 	send(data);
 	recv();
 	
 };
 
 /* This function is used to configure address and ports. */
 
 function Client::conf(s_address, s_port, c_port)
 {	
 	server_address = s_address;
 	udp_server_port = s_port;
 	udp_client_port = c_port;		
 }
 
 /* This function is used from the Client to do all the init operations */
 
 function Client::init()
 {	
 	id_channel = NetCreateChannel(udp_client_port, 
 									server_address, VR_NO_BLOCKING);
 	if (id_channel == -1)
 		outputln("Error creating channel");	
 		
 	pkt_hand_l = Packet();
 	pkt_hand_r = Packet();
 	
 	remote_hand_r = Hand();
 	remote_hand_l = Hand();
 	
 	init_HandPayload(pkt_hand_r);
	init_HandPayload(pkt_hand_l);
	
	remote_hand_r.init(1);
 	remote_hand_l.init(0);
			
 }
 

 function Client::send(data)
 {
	NetVarSendTo(server_address, udp_server_port, data);
 }

 function Client::recv()
 {	
 	var pkt = Packet();
 	
 	pkt = NetVarReceiveFrom(id_channel, server_address);
 	if (pkt != NULL)
 		return pkt;
 }
 
 function Client::step(hand_r, hand_l)
 {	
	if (hand_r.is_active == 1) {
		pkt_hand_r.payload.raw_data = hand_r.get_raw_data();
		pkt_hand_r.payload.is_right = 1;
		send(pkt_hand_r);
	}
	
	if (hand_l.is_active == 1) {
		pkt_hand_l.payload.raw_data = hand_l.get_raw_data();
		pkt_hand_l.payload.is_right = 0;
		send(pkt_hand_l);
	}
	while (NetDataReady(id_channel) == TRUE) {
		var data = recv();
		if (data != NULL) {
			if (data.payload.is_right == 1) {
				remote_hand_r.push_raw_data(data.payload.raw_data);
			}
			else if (data.payload.is_right == 0) {
				remote_hand_l.push_raw_data(data.payload.raw_data);
				
			}
		}	
	}
	
	// It has to be inserted a timeout due to the ghost effect
	
	remote_hand_l.draw();
	remote_hand_r.draw();
 }