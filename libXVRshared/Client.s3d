 /*
  *  This library implements all the classes and functions for the Client side
  * 
  */
 //#define HI_RES 
  
 #include "Packet.s3d"
 #include "HandClass.s3d"
 #include "LevelClass.s3d"
 
 class Client {
 	
 	var server_address;
	var udp_server_port;
 	var udp_client_port;
 	var id_channel;
 	var pkt_hand_l, pkt_hand_r;
 	var pkt_piece;
 	var remote_hand_r; 
 	var remote_hand_l; 
 	
 	conf(s_address, s_port, c_port);
 	init();
 	step(hand_r, hand_l);
 	send(data);
 	recv();
 	draw();
 	
 };
 
 /* This function is used to configure address and ports. */
 
 function Client::conf(s_address, s_port, c_port)
 {	
 	server_address = s_address;
 	udp_server_port = s_port;
 	udp_client_port = c_port;		
 }
 
 /* This function is used from the Client to do all the init operations */
 
 function Client::init()
 {	
 	id_channel = NetCreateChannel(udp_client_port, 
 									server_address, VR_NO_BLOCKING);
 	if (id_channel == -1)
 		outputln("Error creating channel");	
 		
 	pkt_hand_l = Packet();
 	pkt_hand_r = Packet();
 	pkt_piece = Packet();
 	
 	remote_hand_r = Hand();
 	remote_hand_l = Hand();
 	
 	init_HandPayload(pkt_hand_r);
	init_HandPayload(pkt_hand_l);
	init_PiecePayload(pkt_piece);
	
	remote_hand_r.init(1);
 	remote_hand_l.init(0);
	
	level_init();		
 }
 

 function Client::send(data)
 {
	NetVarSendTo(server_address, udp_server_port, data);
 }

 function Client::recv()
 {	
 	var pkt = Packet();
 	
 	pkt = NetVarReceiveFrom(id_channel, server_address);
 	if (pkt != NULL)
 		return pkt;
 }
 
 function Client::step(hand_r, hand_l)
 {	
	if (hand_r.is_active == 1) {
		pkt_hand_r.payload.raw_data = hand_r.get_raw_data();
		pkt_hand_r.payload.is_right = 1;
		pkt_hand_r.payload.status_hand = 1;
		send(pkt_hand_r);
	} 
	if (hand_r.is_active == 0 && hand_r.first_time_not_active == true) {
		hand_r.first_time_not_active = false;
		pkt_hand_r.payload.raw_data = 0;
		pkt_hand_r.payload.is_right = 1;
		pkt_hand_r.payload.status_hand = 0;
		send(pkt_hand_r);
	}
	if (hand_l.is_active == 1) {
		pkt_hand_l.payload.raw_data = hand_l.get_raw_data();
		pkt_hand_l.payload.is_right = 0;
		pkt_hand_l.payload.status_hand = 1;
		send(pkt_hand_l);
	}
	if (hand_l.is_active == 0 && hand_l.first_time_not_active == true) {
		hand_l.first_time_not_active = false;
		pkt_hand_l.payload.raw_data = 0;
		pkt_hand_l.payload.is_right = 0;
		pkt_hand_l.payload.status_hand = 0;
		send(pkt_hand_l);
	}
	while (NetDataReady(id_channel) == TRUE) {
		var data = recv();
		if (data != NULL) {
			switch(data.type) {
			case TYPE_HAND_PAYLOAD:
				if (data.payload.is_right == 1) 
					remote_hand_r.push_raw_data(data.payload.raw_data);
				else if (data.payload.is_right == 0) 
					remote_hand_l.push_raw_data(data.payload.raw_data);
				break;
			case TYPE_PIECE_PAYLOAD:
				my_level.PieceUpdate(data.payload.id, data.payload.pos, data.payload.angle,
					data.payload.axis);
				break;	
			}
		}
	}	
	
	// It has to be inserted a timeout due to the ghost effect

 }
 
 
 function Client::draw()
 {
 	remote_hand_l.draw();
	remote_hand_r.draw();
	
	my_level.Draw();
 }