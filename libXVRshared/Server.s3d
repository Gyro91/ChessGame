/*
 *  This library implements all the classes and functions for the Server side
 * 
 */
#include "Networking.s3d"
 
 var status_new = 0;

 
 /* This class has 4 ports for the communication:
  * - A TCP port for the status of the communication and data;
  * - 3 UDP ports, two for the hand (left and right) and one for the chess pieces;
  * 
  * It is provided:
  * - an conf function to set the ports;
  * - an init function for the initilization operations (accept, ...)
  * - a function to send the status;
  * - a function to receive the status from the other client;
  * - a function to receive the objects from the client;
  * - a function to send the updated objects;
  * 
  */
 
 class Server {
 	
 	var TCP_port;
 	var TCP_socket_id; // for data exchange
 	var TCP_channel_id;
 	var addr_client;	
 	var UDP_port_hand_l, UDP_port_hand_r, UDP_port_pieces;
 	
 	conf(address, port0, port1, port2, port3);
 	init();
 	send_status(status_server);
 	send_objects();
 	recv_objects();
 	step(hand_l, hand_r, pieces, status_server);
 	
 };
 
 /* This function is used to configure the Server. */
 
 function Server::conf(address, port0, port1, port2, port3)
 {	
 	addr_client = address;
 	TCP_port = port0;
 	UDP_port_hand_l = port1;
 	UDP_port_hand_r = port2;
 	UDP_port_pieces = port3;
 }
 
 /* All the operations for the Server initialization 
  * are encapsulated in this function.
  */
  
 function Server::init()
 {
 	TCP_channel_id = NetCreateChannelTCP(TCP_port, 0, VR_NO_BLOCKING);
 	if (TCP_channel_id == -1)
 		outputln("Error creating channel TCP");
 
 	do {TCP_socket_id = NetAcceptTCP(TCP_channel_id);}
 	while (TCP_socket_id <= 0);

 }
 
 function Server::send_status(status_server)
 {	
 	NetVarSendToTCP(TCP_socket_id, status_server);
 }
 
 
 /* This function checks if an hand is active and updates eventually the server status */
 
 function check_status_hands(hand_l, hand_r, status_server) 
 {
 	if (hand_l.is_active == 1 && hand_l.is_active != status_server.hand_l_status) {
 		status_server.hand_l_status = hand_l.is_active;
		status_new = 1; 	
 	}
 	else if (hand_l.is_active == 0 && hand_l.is_active != status_server.hand_l_status) {
 		status_server.hand_l_status = 0;
 		status_new = 1;
 	}
 	if (hand_r.is_active == 1 && hand_r.is_active != status_server.hand_r_status) {
 		//outputln(status_server.hand_r_status);
 		status_server.hand_r_status = hand_r.is_active;
		status_new = 1; 	
 	}
 	else if (hand_r.is_active == 0 && hand_r.is_active != status_server.hand_r_status) {
 		status_server.hand_r_status = 0;
 		status_new = 1;
 	}
 }
 
 function Server::step(hand_l, hand_r, status_server, pieces)
 {
 	
 	check_status_hands(hand_l, hand_r, status_server);
 	
 	/* The status is forwarded only if changed after the last time */	
 	if (status_new == 1) {
 		this.send_status(status_server);
 		status_new = 0;
 	}
 	
 }	