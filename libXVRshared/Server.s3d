/*
 *  This library implements all the classes and functions for the Server side
 *  
 */
#include "Packet.s3d"
#include "HandClass.s3d"
 
#define PHYSX
#include "LevelClass.s3d"
#include "Hand_SM.s3d"
 
#define CLIENT_1 0
#define CLIENT_2 1
#define NUM_REMOTE_HANDS 4
#define PL1_HND_R 0
#define PL1_HND_L 1
#define PL2_HND_R 2
#define PL2_HND_L 3



class Server {
	var server_address;
 	var udp_server_port1, udp_server_port2;
 	var addr_client1, addr_client2;	
 	var udp_client1_port, udp_client2_port;
 	var id_channel_client1, id_channel_client2;
 	var pkt_hand;
 	var pkt_piece;
 	
 	var remote_hands;
 	
 	conf(s_address, s_port1, s_port2, c_address1, 
 		c_port1, c_address2, c_port2
 	);
 	init();
 	recv(client);
 	send(data, client);
 	step();
 	toHandSM(pkt,client);
 	
};
 
/* This function is used to configure the Server. */
 
function Server::conf(s_address, s_port1, s_port2, c_address1, 
 		c_port1, c_address2, c_port2)
{	
	server_address = s_address;
	udp_server_port1 = s_port1;
	udp_server_port2 = s_port2;
	
	addr_client1 = c_address1;
	addr_client2 = c_address2;
	
	udp_client1_port = c_port1;
	udp_client2_port = c_port2;
}
 
/* All the operations for the Server initialization 
 * are encapsulated in this function.
 */
  
function Server::init()
{
 	id_channel_client1 = NetCreateChannel(udp_server_port1, 
 										addr_client1, VR_NO_BLOCKING);
 	if (id_channel_client1 == -1)
 		outputln("Error creating channel client1");	
 		
	 id_channel_client2 = NetCreateChannel(udp_server_port2, 
 											addr_client2, VR_NO_BLOCKING);
 	if (id_channel_client2 == -1)
 		outputln("Error creating channel client2");	 
 
 	pkt_piece = Packet();
 	init_PiecePayload(pkt_piece);
 	
 	level_init(PHYSICAL_LVL);
 	
 	remote_hands = Array(NUM_REMOTE_HANDS); 
 	
 	for (var i = 0; i < NUM_REMOTE_HANDS; i++) {
		remote_hands[i] =  Hand_SM();
	}
	remote_hands[PL1_HND_R].init(PLAYER_1);
	remote_hands[PL1_HND_L].init(PLAYER_1);
	remote_hands[PL2_HND_R].init(PLAYER_2);
	remote_hands[PL2_HND_L].init(PLAYER_2);	
	
}
 
 /* This function is used by the Server to receive a packet from a specified
  * client.
  */
  
function Server::recv(client)
{	
 	var pkt = Packet();
 	
 	/*
 	 * Elaborate the packet
 	 */

 	
 	if (client == CLIENT_1) {
 		pkt = NetVarReceiveFrom(id_channel_client1, addr_client1);

 		if (pkt != NULL) {
 			if (pkt.type == TYPE_HAND_PAYLOAD)
 				toHandSM(pkt,client);
 			return pkt;	
		}
 	}
 	else if (client == CLIENT_2) {
 		pkt = NetVarReceiveFrom(id_channel_client2, addr_client2);
 		if (pkt != NULL) {
 			if (pkt.type == TYPE_HAND_PAYLOAD)
 				toHandSM(pkt,client);
 			return pkt;	
		}
 	}
}
 
 /* This function is used by the Server to send a packet to the specified
  * client.
  */
  
function Server::send(data, client)
{	
 	if (client == CLIENT_1)
 		NetVarSendTo(addr_client1, udp_client1_port, data);
 	else if (client == CLIENT_2)
 		NetVarSendTo(addr_client2, udp_client2_port, data);
}
 
function Server::step()
{	
	var sim_res;
	static var pos = KING_POS;
	static var rot =  [0.0, 0.0, 0.0];
	
	pkt_piece.payload.pos = pos;
	pkt_piece.payload.rot = rot;
	pkt_piece.payload.id = KING_ID;
	send(pkt_piece, CLIENT_1);
	pos+= [0.0, 0.1, 0.0];
	
	while (NetDataReady(id_channel_client2) == TRUE) {
		var data = recv(CLIENT_2);
		if (data != NULL) {
			send(data, CLIENT_1);
		}	
	}
	while (NetDataReady(id_channel_client1) == TRUE) {
		var data = recv(CLIENT_1);
		if (data != NULL) {
			send(data, CLIENT_2);
		}	
	}
	
	manager_psx.Simulate(DELTA_T);
	sim_res = GetPhysicsResults();
	
	
}	

/*
 * This function elaborate data from real hand and steps its correspondent Hand_SM 
 */
function Server::toHandSM(pkt,client)
{
	var smPaketTemp = smPaket();
	smPaketTemp.init(pkt);
	
	/*
	 * Routing data from the packet
	*/
	if (pkt.payload.is_right == 1) {
		if (client == CLIENT_1)
			remote_hands[PL1_HND_R].step(smPaketTemp);
		else
			remote_hands[PL2_HND_R].step(smPaketTemp);
	} else {
		if (client == CLIENT_1)
			remote_hands[PL1_HND_L].step(smPaketTemp);
		else
			remote_hands[PL2_HND_L].step(smPaketTemp);		
	}
	
}

