//#include "Packet.s3d"

#define SM_STATE_WAIT 0
#define SM_STATE_OPEN 1
#define SM_STATE_CLOSED 2
#define SM_STATE_GRABBED 3

//#define GRAB_THRESH 30
#define GRAB_THRESH 0.05*SIM_SCALE
#define LPF_TRESH 10
/*
 * 
 */
class smPaket {
	var lenght;
	var position;
	var status_hand;
	
	init(pkt);
};

function smPaket::init(pkt) 
{
	position = Vector(NUM_COORD);
	lenght = 0;
 	//var smPaketTemp = smPaket();
 	//smPaketTemp.init();
 	var thumbTip = Vector(NUM_COORD);
 	var middleTip = Vector(NUM_COORD);
 	
 	status_hand = pkt.payload.status_hand;
 	
 	if (status_hand == 1)
 	{
		/*
		 * thumb 
		 */
		write_vector(&thumbTip, &pkt.payload.raw_data, 6 + (F_THUMB *  NUM_COORD * NUM_JOINTS) + (F_TP * NUM_COORD));
		//outputln(thumbTip);
		/*
		 * middle
		 */
		write_vector(&middleTip, &pkt.payload.raw_data, 6 + (F_MIDDLE *  NUM_COORD * NUM_JOINTS) + (F_TP * NUM_COORD));
		//outputln(middleTip);
		/*
		 * lenght
		 */
		lenght = modulus(middleTip - thumbTip);
		//outputln(lenght);
		 
		 
		position = (middleTip + thumbTip)/2;
		//outputln(position);
	}

}



/* 
 * 
 * The class manage the status of an hand and it allows object grabbing. 
 * It receives packet from the Server and according with the Architect it
 * modify pieces position. 
 * 
 */
 
 class Hand_SM {
 	
 	var current_state;
 	var id_piece;
 	var my_name;
 	var currPkt;
 	var my_player;
 	var architect_service;
 	
 	var lpf_close_to_open; // low pass filter
 	var lpf_grabbed_to_open;
 	
 	step(pkt);
 	init(nm,pl);
 	
 };
 
 function Hand_SM::init(nm,pl) 
 {
 	current_state = SM_STATE_WAIT;
 	my_name = nm;
 	id_piece = -1;
 	//currPkt = smPaket();
 	lpf_close_to_open = LPF_TRESH;
 	lpf_grabbed_to_open = LPF_TRESH;
 	my_player = pl;
 	architect_service = Architect();
 }
 
 function Hand_SM::step(pkt)
 {
 	currPkt = pkt;
 	/*
 	 * decode the packet
 	 */
 	 var lenght = pkt.lenght; // poi verrà messa con il valore letto dal pacchetto
 	 var position = pkt.position;
 	 var is_hand = pkt.status_hand;
 	 
 	 /*
 	  * transitions
 	  */
 	if (is_hand == 0) {
 		current_state = SM_STATE_WAIT;
 		output(my_name);
 		outputln(" SM_STATE_WAIT");
 		
 		/*
 		 * Unlock the object if grabbed
 		 */

		if (id_piece >= 0)
			architect_service.grab_release(id_piece);
 
	} else {
		switch (current_state) {
		case SM_STATE_WAIT:
	      	if (lenght >= GRAB_THRESH) {
	      		current_state = SM_STATE_OPEN;
	      		output(my_name);
	      		outputln(" SM_STATE_OPEN");
      		}
	    	break;
		case SM_STATE_OPEN:
			if (lenght < GRAB_THRESH) {
				current_state = SM_STATE_CLOSED;
				output(my_name);
				outputln("SM_STATE_CLOSED");
				/*
				 * Request to the Architect
				 */
				 
				 id_piece = architect_service.grab_request(position, my_player);
				 outputln(id_piece);
				//id_piece = ARCHITETTO.grab_request(position, my_name)

				if (id_piece >= 0) {
					current_state = SM_STATE_GRABBED;
					outputln("SM_STATE_GRABBED");	
				}
			}				
	    	break;
		case SM_STATE_CLOSED:
	      	if (lenght >= GRAB_THRESH) {
	      		lpf_close_to_open--;
	      		/*
	      		 * Low pass filter to give more robustness to closed state
	      		 */
		      	if (lpf_close_to_open == 0) {
		      		lpf_close_to_open = LPF_TRESH;
		      		current_state = SM_STATE_OPEN;
		      		output(my_name);
		      		outputln(" SM_STATE_OPEN");
	      		}
      		}
      		else
	      		lpf_close_to_open = LPF_TRESH;
	    	break;
		case SM_STATE_GRABBED:
	      	if (lenght >= GRAB_THRESH) {
	      		lpf_grabbed_to_open--;
		      	if (lpf_grabbed_to_open == 0) {
		      		lpf_grabbed_to_open = LPF_TRESH;
		      		current_state = SM_STATE_OPEN;
		      		output(my_name);
		      		outputln(" SM_STATE_OPEN");
	      		
		      		/*
		      		 * unlock the object
		      		 */
		      		 
		      		architect_service.grab_release(id_piece, my_player);
	
	      		}
	      		
      		} else {
      			
      			/*
      			 * Update piece position
      			 */
      			output("position: ");
      			outputln(position);
      			my_level.PieceUpdate(id_piece, position, 0, [0.0, 0.0, 0.0]);
      		}
	    	break;
	    default :
	      current_state = SM_STATE_WAIT;
		}
	} 
 }