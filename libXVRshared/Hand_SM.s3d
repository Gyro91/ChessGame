//#include "Packet.s3d"

#define SM_STATE_WAIT 0
#define SM_STATE_OPEN 1
#define SM_STATE_CLOSED 2
#define SM_STATE_GRABBED 3

#define GRAB_THRESH 30
/*
 * 
 */
class smPaket {
	var lenght;
	var position;
	var status_hand;
	
	init(pkt);
};

function smPaket::init(pkt) 
{
	position = Vector(NUM_COORD);
	lenght = 0;
 	//var smPaketTemp = smPaket();
 	//smPaketTemp.init();
 	var thumbTip = Vector(NUM_COORD);
 	var middleTip = Vector(NUM_COORD);
 	
 	status_hand = pkt.payload.status_hand;
 	
 	if (status_hand == 1)
 	{
		/*
		 * thumb 
		 */
		write_vector(&thumbTip, &pkt.payload.raw_data, 6 + (F_THUMB *  NUM_COORD * NUM_JOINTS) + (F_TP * NUM_COORD));
		//outputln(thumbTip);
		/*
		 * middle
		 */
		write_vector(&middleTip, &pkt.payload.raw_data, 6 + (F_MIDDLE *  NUM_COORD * NUM_JOINTS) + (F_TP * NUM_COORD));
		//outputln(middleTip);
		/*
		 * lenght
		 */
		lenght = modulus(middleTip - thumbTip);
		//outputln(lenght);
		 
		 
		position = (middleTip + thumbTip)/2;
		//outputln(position);
	}

}



/* 
 * 
 * The class manage the status of an hand and it allows object grabbing. 
 * It receives packet from the Server and according with the Architect it
 * modify pieces position. 
 * 
 */
 
 class Hand_SM {
 	
 	var current_state;
 	var id_piece;
 	var my_name;
 	var currPkt;
 	
 	step(pkt);
 	init(nm);
 	
 };
 
 function Hand_SM::init(nm) 
 {
 	current_state = -1;
 	current_state = SM_STATE_WAIT;
 	my_name = nm;
 	id_piece = -1;
 	//currPkt = smPaket();
 }
 
 function Hand_SM::step(pkt)
 {
 	currPkt = pkt;
 	/*
 	 * decode the packet
 	 */
 	 var lenght = pkt.lenght; // poi verrà messa con il valore letto dal pacchetto
 	 var position = pkt.position;
 	 var is_hand = pkt.status_hand;
 	 
 	 /*
 	  * transitions
 	  */
 	if (is_hand == 0) {
 		current_state = SM_STATE_WAIT;
 		outputln("SM_STATE_WAIT");
 		/*
 		 * Unlock the object if grabbed
 		 */
 		/* 
 		if (id_piece >= 0)
 			ARCHITETTO.grab_release(id_piece, my_name);
		*/
	} else {
		switch (current_state) {
		case SM_STATE_WAIT:
	      	if (lenght >= GRAB_THRESH) {
	      		current_state = SM_STATE_OPEN;
	      		outputln("SM_STATE_OPEN");
      		}
	    	break;
		case SM_STATE_OPEN:
			if (lenght < GRAB_THRESH) {
				current_state = SM_STATE_CLOSED;
				outputln("SM_STATE_CLOSED");
				/*
				 * Request to the Architect
				 */
				 
				//id_piece = ARCHITETTO.grab_request(position, my_name)

				if (id_piece >= 0) {
					current_state = SM_STATE_GRABBED;
					outputln("SM_STATE_GRABBED");	
				}
			}				
	    	break;
		case SM_STATE_CLOSED:
	      	if (lenght >= GRAB_THRESH) {
	      		current_state = SM_STATE_OPEN;
	      		outputln("SM_STATE_OPEN");
      		}
	    	break;
		case SM_STATE_GRABBED:
	      	if (lenght >= GRAB_THRESH) {
	      		current_state = SM_STATE_OPEN;
	      		
	      		/*
	      		 * unlock the object
	      		 */
	      		 
	      		//ARCHITETTO.grab_release(id_piece, my_name);	
	      		
      		} else {
      			
      			/*
      			 * Update piece position
      			 */
      			 
      			//LIVELLO.UpdatePosition(my_name, id_piece, position);
      		}
	    	break;
	    default :
	      current_state = SM_STATE_WAIT;
		}
	} 

	
 }
 
 