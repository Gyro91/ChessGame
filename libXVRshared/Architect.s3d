/* This class implements the entity that has to decide result
 * of grabbing. The Architect is the only entity that could 
 * change the physic type.
 * 
 */
#define  RELEASE_SPEED [0.0, -0.01, 0.0]

class Architect {
	/* Map for the grab state of the pieces. 
	 * FALSE if a piece is free,
	 * TRUE if a piece is already grabbed.
	 */
	var is_grabbed;
	
	grab_request(cc, player_id); // This function has to return the id piece
	grab_release(piece_id); 
	
};

function Architect::Architect() 
{
	is_grabbed = Array(NUM_PIECES);
	
	for (var i = 0; i < NUM_PIECES; i++) {
		is_grabbed[i] = false;
	}
}

function Architect::grab_request(cc, player_id) 
{	
	var piece, bb_piece, id;
	
	// Checking every pieces of the player
	for(var i = 0; i < (NUM_PIECES / 2); i++) {
		piece = my_level.GetPiece(player_id + i);
		bb_piece = piece.mesh.GetBoundingBox();
		// Checking if the cc is inside the Bounding Box
		if (check_collision(cc, bb_piece, piece.GetPosition()) == true
			&& is_grabbed[player_id + i] == false) {
				is_grabbed[player_id + i] = true;
				id = player_id + i;
				piece.SetKinematic();
				return id;
			}
	}
	
	return -2;
}

function Architect::grab_release(piece_id) 
{	
	var piece = my_level.GetPiece(piece_id);
	
	piece.SetDynamic();
	piece.SetVelocity(RELEASE_SPEED);
	
	is_grabbed[piece_id] = false;
}