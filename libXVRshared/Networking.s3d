/*
 *  This library provides an extension to the UDP protocol 
 *  for sequencing communication.
 * 
 */
 
#include "HandClass.s3d"
  
var local_tx_seq_number = 0; /* This index rappresents the id used from the trasnmitter 
							  * for the sequencing control 
 							  */  

var last_rx_seq_number = 0; /* This is the id sequence number for the last packet received */ 							  

/*
 * A packet has an id to identify the sequence and the data
 * This is the packet sended by the transmitter
 */
 
class Packet {	
	
	var sequence_remote_id;
	var data;
};

/* This packet is derived from the Packet and allows an error handling for the receiver */

class Packet_err: Packet {
	var type_error;
};
 

class Player {
	
	var id;
	var port;
	var ip;
	var channel;
	
	init(id, port, ip, ch);
	send(pkt);	
	rcv();
};

/* Function to initialize the player */

function Player::init(id_p, port_p, ip_p, ch_p)
{
	id = id_p;
	port = port_p;
	ip = ip_p;
	channel = ch_p;
}

/* This function sends the packet passed as argument to the player */

function Player::send(pkt)
{
	NetVarSendTo(ip, port, pkt);
}

/* This function returns the packet from the other player 
 * with an information to the caller about an eventually
 * error:
 *  (-1) if a packet is not received 
 * 	(-2) if a packet does not respect the sequence
 *  (0)  if everything went well
 */

function Player::rcv()
{
	var pkt_e = Packet_err();
	var pkt = NetVarReceiveFrom(channel, ip);
	
	if (pkt == NULL) 
		pkt_e.type_error = -1;		
	else if (pkt.sequence_remote_id < last_rx_seq_number)  
		pkt_e.type_error = -2;
	else {
		pkt_e.type_error = 0;
		pkt_e.data = pkt.data;
		pkt_e.sequence_remote_id = pkt.sequence_remote_id;
		last_rx_seq_number = pkt.sequence_remote_id;
	}
	
	return pkt_e;
}

/* This function updates the packet increasing the sequence id 
 * and retrieving the raw data from the Hand object.
 */

function update_pkt(hand, pkt)
{
	local_tx_seq_number++;
	pkt.sequence_remote_id = local_tx_seq_number;
	pkt.data = hand.get_raw_data();
}