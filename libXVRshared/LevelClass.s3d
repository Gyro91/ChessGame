#include "../physics/physics.s3d"

#define NUM_PIECES		32

/* Players IDs */
#define PLAYER_1		0
#define PLAYER_2		16

/* Pieces IDs */
#define CHESSBOARD_ID	-1
#define KING_ID			0
#define QUEEN_ID		1
#define ROOK0_ID		2
#define ROOK1_ID		3
#define KNIGHT0_ID		4
#define KNIGHT1_ID		5
#define BISHOP0_ID		6
#define BISHOP1_ID		7
#define PAWN0_ID		8
#define PAWN1_ID		9
#define PAWN2_ID		10
#define PAWN3_ID		11
#define PAWN4_ID		12
#define PAWN5_ID		13
#define PAWN6_ID		14
#define PAWN7_ID		15

#define PIECE_DENSITY	1

/* Pieces meshes */
#define CHESSBOARD_MESH	"../../meshes/chessboard.aam"

#ifdef	HI_RES

#define KING_MESH		"../../meshes/king.aam"
#define QUEEN_MESH		"../../meshes/queen.aam"
#define ROOK_MESH		"../../meshes/rook.aam"
#define KNIGHT_MESH		"../../meshes/knight.aam"
#define BISHOP_MESH		"../../meshes/bishop.aam"
#define PAWN_MESH		"../../meshes/pawn.aam"

#else 
/* LOW_RES */
#define KING_MESH		"../../meshes/king_low.aam"
#define QUEEN_MESH		"../../meshes/queen_low.aam"
#define ROOK_MESH		"../../meshes/rook_low.aam"
#define KNIGHT_MESH		"../../meshes/knight_low.aam"
#define BISHOP_MESH		"../../meshes/bishop_low.aam"
#define PAWN_MESH		"../../meshes/pawn_low.aam"

#endif

/* Actually the chessboard mesh has a size of 9.6x9.6x1.2 meters, 
 * we scale it in order to have a 30x30 centimeters chessboard.
 */
#define SIM_SCALE			100
#define CHESSBOARD_SCALE	SIM_SCALE * [0.03125, 0.03125, 0.03125]
#define CHESSBOARD_SIZE		SIM_SCALE * 0.3
#define SQUARE_SIZE			SIM_SCALE * 0.0375
#define SQUARE_VECT			[SQUARE_SIZE, 0.0, 0.0]
/* The pawn has a diameter of about 3.4 meters. usually
 * a square in the chessboard has a side size which is
 * twice the pawn base diameter. So, in our case we want
 * a pawn with a base diameter of 1.87 centimeters.
 */
#define PIECE_SCALE		SIM_SCALE * [0.0055, 0.0055, 0.0055]
/* The bishop has a different dimension */
#define BISHOP_SCALE	PIECE_SCALE * 2.4089
	
#define X_OFFSET		SQUARE_SIZE*0.5
#define Y_OFFSET		SQUARE_SIZE*1.1
#define Z_OFFSET		SQUARE_SIZE*0.5
#define PAWN_Z			SQUARE_SIZE*2.5		

/* Macros for pieces positions. */
#define CHESSBOARD_POS	[CHESSBOARD_SIZE/2, 0.0, CHESSBOARD_SIZE/2]
#define OPP_PAWN_Z		SQUARE_SIZE*5
#define OPP_OTHER_Z		SQUARE_SIZE*7
#define OPP_PAWN_VECT	[0.0, 0.0, OPP_PAWN_Z]
#define OPP_OTHER_VECT	[0.0, 0.0, OPP_OTHER_Z]
#define NO_ROT			[0.0, 0.0, 0.0]
#define OPP_ROT			[0.0, 180, 0.0]
#define	PAWN0_POS		[SQUARE_SIZE*0.5, Y_OFFSET, SQUARE_SIZE*1.5]
#define ROOK0_POS		[SQUARE_SIZE*0.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define ROOK1_POS		[SQUARE_SIZE*7.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define KNIGHT0_POS		[SQUARE_SIZE*1.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define KNIGHT1_POS		[SQUARE_SIZE*6.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define BISHOP0_POS		[SQUARE_SIZE*2.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define BISHOP1_POS		[SQUARE_SIZE*5.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define KING_POS		[SQUARE_SIZE*3.5, Y_OFFSET, SQUARE_SIZE*0.5]
#define QUEEN_POS		[SQUARE_SIZE*4.5, Y_OFFSET, SQUARE_SIZE*0.5]

#define PHYSICAL_LVL	0
#define GRAPHICAL_LVL	1

/* Global Level object */
var my_level;

/*
 * CLASS DECLARATIONS
 */

/* Level class declaration. */
class Level {
	var type;
	var pieces;
	var chessboard;
	var table;
	
	GetTable();
	GetPiece(piece_id);
	
	PieceUpdate(player_id, piece_id, pos, rot);
	TableUpdate();
	
	Draw();
};

/* Piece class declaration. */
class Piece {
	var id;
	var player_id;
	var obj;
	var mesh;
	var psx;
	var pos;
	var rot;
	
	GetObj();
	GetPosition();
	GetRotation();
	Update(p_pos, p_rot);
};

/*
 * Utility Functions
 */

function level_init(type) {
	if (type == PHYSICAL_LVL) {
	/* Initlialize Physx engine */
	InitPhysicsEngine();
	/* Set the gravity */
	manager_psx.SetSceneGravity([0.0,-9.8,0.0]);
	}
	
	/* Initialize the level */
	my_level = Level(type);
}

/*
 * Level Class Member Functions
 */
 
function Level::Level(level_t) {
	var rot, pos;
	type = level_t;
	pieces = Array(NUM_PIECES);
	
	/* Initial piece positions */
	var pos_other = {KING_POS, QUEEN_POS, ROOK0_POS, ROOK1_POS, KNIGHT0_POS, KNIGHT1_POS, 
		BISHOP0_POS, BISHOP1_POS};
	/* Pieces meshes */
	var mesh_pieces = {KING_MESH, QUEEN_MESH, ROOK_MESH, ROOK_MESH, KNIGHT_MESH, KNIGHT_MESH,
		BISHOP_MESH, BISHOP_MESH};
	/* Instantiate the chessboard */
	chessboard = Piece(CHESSBOARD_ID, CHESSBOARD_MESH, CHESSBOARD_POS, NO_ROT, type);
	/* Instantiate all the other pieces */
	for (var i=0; i<NUM_PIECES/2; i++) {
		if (i < 8) {
			/* It's not a pawn. */
			pieces[PLAYER_1 + i] = Piece(PLAYER_1 + i, mesh_pieces[i], pos_other[i], NO_ROT, type);
			pieces[PLAYER_2 + i] = Piece(PLAYER_2 + i, mesh_pieces[i], pos_other[i] + OPP_OTHER_VECT, OPP_ROT, type);
		} else {
			/* It's a pawn. */
			pieces[PLAYER_1 + i] = Piece(PLAYER_1 + i, PAWN_MESH, PAWN0_POS + SQUARE_VECT*(i-8), NO_ROT, type);
			pieces[PLAYER_2 + i] = Piece(PLAYER_2 + i, PAWN_MESH, PAWN0_POS + SQUARE_VECT*(i-8) + OPP_PAWN_VECT, OPP_ROT, type);
		}
	}
	
	if (type == PHYSICAL_LVL) {
		table = Array(NUM_PIECES);
		for (var i=0; i<NUM_PIECES; i++) {
			table[i] = Array(6);
			pos = pieces[i].GetPosition();
			rot = pieces[i].GetRotation();
			table[i] = [pos[0], pos[1], pos[2], rot[0], rot[1], rot[2]];
		}
	} else {
		table = NULL;
	}
}

function Level::PieceUpdate(player_id, piece_id, pos, rot) {
	pieces[player_id + piece_id].Update(pos, rot);
}

function Level::TableUpdate() {
	var rot, pos;
	for (var i=0; i<NUM_PIECES; i++) {
		pos = pieces[i].GetPosition();
		rot = pieces[i].GetRotation();
		table[i] = [pos[0], pos[1], pos[2], rot[0], rot[1], rot[2]];
	}
}

function Level::GetTable() {
	return table;
}

function Level::Draw() {
	for (var i=0; i<NUM_PIECES; i++) {
		pieces[i].GetObj().Draw();
	}
	chessboard.GetObj().Draw();
}

/*
 * Piece Class Member Functions
 */

function Piece::Piece(p_id, p_mesh, init_pos, init_rot, type) {
	var p2, bb;
	
	/* Check if the piece belongs to player 2 */
	if (p_id >= PLAYER_2) {
		p2 = 1;
		id = p_id - PLAYER_2;
		player_id = PLAYER_2;
	} else {
		p2 = 0;
		id = p_id;
		player_id = PLAYER_1;
	}
	pos = init_pos;
	rot = init_rot;
	
	switch(id) {
		case CHESSBOARD_ID: 
			mesh = CVmNewMesh(CHESSBOARD_MESH);
			mesh.Scale(CHESSBOARD_SCALE);
			break;
		case KING_ID:
			mesh = CVmNewMesh(KING_MESH);
			mesh.Scale(PIECE_SCALE);
			break;
		case QUEEN_ID:
			mesh = CVmNewMesh(QUEEN_MESH);
			mesh.Scale(PIECE_SCALE);
			break;
		case ROOK0_ID:
		case ROOK1_ID:
			mesh = CVmNewMesh(ROOK_MESH);
			mesh.Scale(PIECE_SCALE);
			break;
		case KNIGHT0_ID:
		case KNIGHT1_ID:
			mesh = CVmNewMesh(KNIGHT_MESH);
			mesh.Scale(PIECE_SCALE);
			break;
		case BISHOP0_ID:
		case BISHOP1_ID:
			mesh = CVmNewMesh(BISHOP_MESH);
			mesh.Scale(BISHOP_SCALE);
			break;
		case PAWN0_ID:
		case PAWN1_ID:
		case PAWN2_ID:
		case PAWN3_ID:
		case PAWN4_ID:
		case PAWN5_ID:
		case PAWN6_ID:
		case PAWN7_ID:
			mesh = CVmNewMesh(PAWN_MESH);
			mesh.Scale(PIECE_SCALE);
			break;
		default:
			outputln("Invalid ID when creating Piece object!");
			break;
	}
	
	/* Move the mesh reference frame to the base of the mesh  */
	mesh.CenterBoundingBox();
	bb = mesh.GetBoundingBox();
	/* bb[4] contains the y_max coordinate of the BB */
	mesh.Translate([0.0, bb[4], 0.0]);
	
	if (p2 == 1) {
		mesh.ModulateMaterials([1,0.0,0.0]);
	}
	if (type == PHYSICAL_LVL) {
		/* Instanciate the physical object */
		obj = NULL;
		if (id == CHESSBOARD_ID) {
			psx = manager_psx.AddPhConvexShape(pos, rot, mesh, PHX_FIXED, PIECE_DENSITY, 10, rigidMaterial);
		} else {
			psx = manager_psx.AddPhConvexShape(pos, rot, mesh, PHX_DYNAMIC, PIECE_DENSITY, 10, rigidMaterial);
		}
	} else {
		psx = NULL;
		obj = CVmObj(mesh);
		this.Update(pos,rot);
	}
}

function Piece::GetPosition() {
	return pos;
}

function Piece::GetRotation() {
	return rot;
}

function Piece::GetObj() {
	return obj;
}

function Piece::Update(p_pos, p_rot) {
	var quat;
	var matrix3 = vector(9);
	var matrix4 = vector(16);
		
	pos = p_pos;
	rot = p_rot;
	
	obj.SetPosition(pos);
	
	quat = EulerToQuaternion(rot);
	matrix3 = QuaternionToMatrix3(quat); 
	matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
	matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
	matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
	matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
	
	obj.SetRotationMatrix(matrix4);
}