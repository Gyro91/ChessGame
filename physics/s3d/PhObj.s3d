#ifndef __USE_PHOBJ
#define __USE_PHOBJ

#define PHX_DYNAMIC		1
#define PHX_FIXED 		2
#define PHX_KINEMATIC	4

#define PHX_BOX			0
#define PHX_SPHERE		1
#define PHX_CYLINDER	2
#define PHX_CAPSULE		3
#define PHX_CONE		4
#define PHX_CONEFRUSTUM	5
#define PHX_NONE		6
#define PHX_PLANE		7
#define PHX_PYRAMID		8
#define PHX_TERRAIN		9
#define PHX_CVSHAPE		10
#define PHX_TRISHAPE 	11

#define	DEFAULT_ERROR				-1
#define	MATERIAL_NOT_FOUND			-2
#define	ACTOR_NOT_FOUND				-3
#define	SHAPE_NOT_FOUND				-4
#define	JOINT_NOT_FOUND				-5
#define	TRIANGLE_MESH_NOT_FOUND		-6
#define	CONVEX_MESH_NOT_FOUND		-7
#define	MATERIAL_NOT_CREATED		-8
#define	ACTOR_NOT_CREATED			-9
#define	SHAPE_NOT_CREATED			-10
#define	JOINT_NOT_CREATED			-11
#define	TRIANGLE_MESH_NOT_CREATED	-12
#define	CONVEX_MESH_NOT_CREATED		-13
#define HEIGHTFIELD_NOT_CREATED		-14
#define ACTOR_DIFFERENT_TYPE		-15
#define JOINT_DIFFERENT_TYPE		-16
#define MATERIAL_ERROR				-17
#define SHAPE_ERROR					-18
#define TRIANGLE_MESH_ERROR			-19
#define CONVEX_MESH_ERROR			-19
#define COOKING_ERROR				-20
#define ATTRIBUTE_NOT_SET			-21
#define FIXED_NOT_ALLOWED			-22
#define QUATERNION_NOT_SANE			-23

#define TOUCH_FOUND			0
#define TOUCH_PERSISTS		1
#define TOUCH_LOST			2

#include "util.s3d"

var PhysXVR;		//! Global variable for function call

/*!
 * Load the physic library and add the function of the library to the XVR object 
 */
 function loadLib(){
 	outputln("\nLoading PhysXVR library...");
	PhysXVR  = CVmExternDLL("PhysXVR.dll");
	
	PhysXVR.__AddFunction(C_INT,	"Init", C_VOID);
	//PhysXVR.__AddFunction(C_INT,	"GetID", C_VRLIB_OBJ);

	//STATIC ACTORS
	PhysXVR.__AddFunction(C_INT,	"NewPlane", C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"NewTerrain", C_PFLOAT, C_INT, C_INT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"NewStaticBox", C_PFLOAT, C_PFLOAT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"NewStaticSphere", C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"NewStaticConvexShape", C_INT, C_PFLOAT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"NewStaticTriangleShape", C_INT, C_PFLOAT, C_PFLOAT, C_INT);

	//DYNAMIC ACTOR
	PhysXVR.__AddFunction(C_INT,	"NewCompObject", C_PFLOAT, C_PFLOAT, C_INT, C_INT);
	//PhysXVR.__AddFunction(C_INT,	"Link", C_VRLIB_OBJ, C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"DeleteObj", C_INT);

	//SHAPE
	PhysXVR.__AddFunction(C_INT,	"AddBoxShape", C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"AddCapsuleShape", C_INT, C_FLOAT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"AddConvexShape", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"AddSphereShape", C_INT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"AddTriangleShape", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_FLOAT,C_INT);
	
	PhysXVR.__AddFunction(C_INT,	"RemoveShape", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"GetNumShapes", C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetContactOffsetToShape", C_INT, C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetRestOffsetToShape", C_INT, C_INT, C_FLOAT);

	//GLOBAL
	PhysXVR.__AddFunction(C_VOID,	"StartPhysics", C_FLOAT);
	PhysXVR.__AddFunction(C_VOID,	"GetPhysicsResults", C_VOID);
	//PhysXVR.__AddFunction(C_VOID,	"UpdateGraphics", C_VOID);
	PhysXVR.__AddFunction(C_VOID,	"SetSceneGravity", C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"GetObjectNumber", C_VOID);
	PhysXVR.__AddFunction(C_INT,	"GetJointNumber", C_VOID);
	PhysXVR.__AddFunction(C_VOID,	"ShutDown", C_VOID);

	//SINGLE OBJECT
	//PhysXVR.__AddFunction(C_INT,	"UpdateObjGraphic", C_INT);
	PhysXVR.__AddFunction(C_INT,	"EnableKinematic", C_INT);
	PhysXVR.__AddFunction(C_INT,	"DisableKinematic", C_INT);
	PhysXVR.__AddFunction(C_INT,	"Halt", C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetGravity", C_INT, C_INT);

	//ATTRIBUTES
	PhysXVR.__AddFunction(C_INT,	"GetPosition", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetPosition", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetKPosition", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"Translate", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"KTranslate", C_INT, C_PFLOAT);

	PhysXVR.__AddFunction(C_INT,	"GetInertiaTensor", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetInertiaTensor", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetLinearDamping", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetAngularDamping", C_INT, C_FLOAT);

	PhysXVR.__AddFunction(C_INT,	"GetMass", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetMass", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetBarycenterREL", C_INT, C_PFLOAT);

	PhysXVR.__AddFunction(C_INT,	"GetVelocity", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetVelocity", C_INT, C_PFLOAT);

	PhysXVR.__AddFunction(C_INT,	"GetAngularVelocity", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetAngularVelocity", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetMaxAngularVelocity", C_INT, C_FLOAT);
	
	PhysXVR.__AddFunction(C_INT,	"SetIterationCount", C_INT, C_INT);

	PhysXVR.__AddFunction(C_INT,	"GetRotation", C_INT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"GetRotationMatrix", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"GetTransformationMatrix", C_INT, C_PFLOAT, C_INT);	
	PhysXVR.__AddFunction(C_INT,	"SetRotation", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetRotationSingleAxis_X", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetRotationSingleAxis_Y", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetRotationSingleAxis_Z", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotation", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotationSingleAxis_X", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotationSingleAxis_Y", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotationSingleAxis_Z", C_INT, C_FLOAT);
	
	PhysXVR.__AddFunction(C_INT,	"SetRotationMatrix44", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetRotationMatrix33", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetTransformationMatrix", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotationMatrix44", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetKRotationMatrix33", C_INT, C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetKTransformationMatrix", C_INT, C_PFLOAT, C_INT);
		
	PhysXVR.__AddFunction(C_INT,	"Rotate", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"KRotate", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"RotateABS", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"KRotateABS", C_INT, C_FLOAT, C_PFLOAT);

	//SLEEP
	PhysXVR.__AddFunction(C_INT,	"IsSleeping", C_INT);
	PhysXVR.__AddFunction(C_INT,	"SetSleepThreshold", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetWakeCounter", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"WakeUp", C_INT);
	PhysXVR.__AddFunction(C_INT,	"PutToSleep", C_INT);

	//FORCE
	PhysXVR.__AddFunction(C_INT,	"AddForce", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"AddForceAtLocalPos", C_INT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"AddForceAtPos", C_INT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"AddLocalForceAtLocalPos", C_INT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"AddLocalForceAtPos", C_INT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"AddTorque", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);

	//JOINTS
	PhysXVR.__AddFunction(C_INT,	"NewCylindricalJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);

	PhysXVR.__AddFunction(C_INT,	"NewFixedJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	
	PhysXVR.__AddFunction(C_INT,	"NewPrismaticJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"PrismaticJointSetLinearHardLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"PrismaticJointSetLinearSoftLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);

	PhysXVR.__AddFunction(C_INT,	"NewRevoluteJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointGetAngle", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointGetAngularVelocity", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetMotor", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetMotorVelocity", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetForceLimit", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetMotorGearRatio", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetAngularHardLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointSetLinearSoftLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointEnableMotor", C_INT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointDisableMotor", C_INT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointEnableMotorFreeSpin", C_INT);
	PhysXVR.__AddFunction(C_INT,	"RevoluteJointDisableMotorFreeSpin", C_INT);

	PhysXVR.__AddFunction(C_INT,	"NewDistanceJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"DistanceJointSetMinDistance", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"DistanceJointSetMaxDistance", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"DistanceJointEnableSpring", C_INT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"DistanceJointDisableSpring", C_INT);
	PhysXVR.__AddFunction(C_INT,	"DistanceJointSetTolerance", C_INT, C_FLOAT);

	PhysXVR.__AddFunction(C_INT,	"NewD6Joint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetDOF", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointFreeDOF", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointLockDOF", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointLimitDOF", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetLinearHardLimit", C_INT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetLinearSoftLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetHardAngularTwistLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetSoftAngularTwistLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetHardSwingConeLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetSoftSwingConeLimit", C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetLinearDrive", C_INT, C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetAngularDrive", C_INT, C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetDrivePosition", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetDriveVelocity", C_INT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetDriveSwingSwing", C_INT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointSetDriveOrientation", C_INT, C_FLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"D6JointRemoveDrive", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointDriveLimitsAreForces", C_INT);
	PhysXVR.__AddFunction(C_INT,	"D6JointDriveLimitsAreImpulses", C_INT);
	PhysXVR.__AddFunction(C_INT,	"EnableRotationD6JointForObj", C_INT);
	PhysXVR.__AddFunction(C_INT,	"DisableRotationD6JointForObj", C_INT);

	PhysXVR.__AddFunction(C_INT,	"NewSphericalJoint", C_INT, C_INT, C_PFLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SphericalJointSetHardLimitCone", C_INT, C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SphericalJointSetSoftLimitCone", C_INT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);

	PhysXVR.__AddFunction(C_INT,	"JointSetBreakable", C_INT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"JointSetProjection", C_INT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"JointDisableProjection", C_INT);
	PhysXVR.__AddFunction(C_INT,	"JointEnableLimit", C_INT);
	PhysXVR.__AddFunction(C_INT,	"JointDisableLimit", C_INT);
	PhysXVR.__AddFunction(C_INT,	"DeleteJoint", C_INT);

	//MATERIALS
	PhysXVR.__AddFunction(C_INT,	"NewMaterial", C_FLOAT, C_FLOAT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetMaterial", C_INT, C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"GetRestitution", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"GetStaticFriction", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"GetDynamicFriction", C_INT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetRestitution", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetStaticFriction", C_INT, C_FLOAT);
	PhysXVR.__AddFunction(C_INT,	"SetDynamicFriction", C_INT, C_FLOAT);

	//COLLISION
	PhysXVR.__AddFunction(C_INT,	"SetupCollisionReport", C_INT, C_INT, C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"InTouch", C_INT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"GetGlobalCollision", C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"AssignCollisionGroup", C_INT, C_INT, C_INT);
	PhysXVR.__AddFunction(C_VOID,	"EnableCollision", C_INT, C_INT);
	PhysXVR.__AddFunction(C_VOID,	"DisableCollision", C_INT, C_INT);

	PhysXVR.__AddFunction(C_INT,	"Raycast", C_PFLOAT, C_PFLOAT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"OverlapSphereShapes", C_PFLOAT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"OverlapBoxShapes", C_PFLOAT, C_PFLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);
	PhysXVR.__AddFunction(C_INT,	"OverlapCapsuleShapes", C_PFLOAT, C_PFLOAT, C_FLOAT, C_FLOAT, C_PFLOAT, C_PFLOAT, C_PFLOAT);

	//OTHER FUNCTIONS
	PhysXVR.__AddFunction(C_INT,	"CookConvexMesh", C_PFLOAT, C_INT);
	PhysXVR.__AddFunction(C_INT,	"CookMesh", C_PFLOAT, C_INT, C_PFLOAT, C_INT);
	
	outputln("PhysXVR library correctly loaded.\n");	
 }
 
 /*!
 * Checks the "check" flag: if is false, an error occurred and it is wrote on the console.
 * \param	check		int		flag of the error
 * \param	funcName	string	name of the PhysXVR.dll function that has generated the error
 */
function CheckForErrorMessage(check, funcName){ 	
	if(check < 0){
		switch(check){
			case DEFAULT_ERROR:
				outputln("ERROR: generic error in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case MATERIAL_NOT_FOUND:
				outputln("ERROR: Material not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case ACTOR_NOT_FOUND:
				outputln("ERROR: Actor not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case SHAPE_NOT_FOUND:
			outputln("ERROR: Shape not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case JOINT_NOT_FOUND:
				outputln("ERROR: Joint not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case TRIANGLE_MESH_NOT_FOUND:
				outputln("ERROR: Triangle Mesh not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case CONVEX_MESH_NOT_FOUND:
				outputln("ERROR: Convex Mesh not found in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case MATERIAL_NOT_CREATED:
				outputln("ERROR: Material not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case ACTOR_NOT_CREATED:
				outputln("ERROR: Actor not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case SHAPE_NOT_CREATED:
				outputln("ERROR: Shape not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case JOINT_NOT_CREATED:
				outputln("ERROR: Joint not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case TRIANGLE_MESH_NOT_CREATED:
				outputln("ERROR: Triangle Mesh not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case CONVEX_MESH_NOT_CREATED:
				outputln("ERROR: Convex Mesh not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case HEIGHTFIELD_NOT_CREATED:
				outputln("ERROR: Heightfield not created in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case ACTOR_DIFFERENT_TYPE:
				outputln("WARNING: The function required is not allowed for the selected Actor Type; in PhysXVR.dll function \"" + funcName + "\"");
				break;
			case JOINT_DIFFERENT_TYPE:
				outputln("WARNING: The function required is not allowed for the selected Joint type; in PhysXVR.dll function \"" + funcName + "\"");
				break;
			case MATERIAL_ERROR:
				outputln("ERROR: Generic error on Material management in PhysXVR.dll function \"" + funcName + "\" (if you see this you are probably in trouble)");
				quit();
				break;
			case SHAPE_ERROR:
				outputln("ERROR: Generic error on Shape management in PhysXVR.dll function \"" + funcName + "\" (if you see this you are probably in trouble)");
				quit();
				break;
			case TRIANGLE_MESH_ERROR:
				outputln("ERROR: Generic error on Triangle Mesh management in PhysXVR.dll function \"" + funcName + "\" (if you see this you are probably in trouble)");
				quit();
				break;
			case CONVEX_MESH_ERROR:
				outputln("ERROR: Generic error on Convex Mesh management in PhysXVR.dll function \"" + funcName + "\" (if you see this you are probably in trouble)");
				quit();
				break;
			case COOKING_ERROR:
				outputln("ERROR: Coocking Error in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
			case ATTRIBUTE_NOT_SET:
				outputln("WARNING: The required attribute has not been set in PhysXVR.dll function \"" + funcName + "\"");
				break;
			case FIXED_NOT_ALLOWED:
				outputln("WARNING: The function required is not allowed for FIXED object; in PhysXVR.dll function \"" + funcName + "\"");
				break;
			case QUATERNION_NOT_SANE:
				outputln("ERROR: Insane Quaternion in PhysXVR.dll function \"" + funcName + "\"");
				quit();
				break;
		}	
	}	
}
 
class CVmPhObj{
 	var mesh;					//! The mesh of the object
	var obj;					//! The graphical object moved with the physical one
//	var material;				//! ---->Graphic material
//	var texture;				//! ---->Grpahic texture
		
	var actor;					//! Index of the corresponding PxActor in the list of PhysXVR	
//	var shapes_handler;			//! Index of the corresponding PxShape in the list of PhysXVR		
	
	var type;					//! Type of object, PHX_FIXED, PHX_DYNAMIC or PHX_CINEMATIC
	
	var visible;				//! If true the object will be drawn
	
	Draw(flags, x, y);
	GetObj();
	GetMesh();
	GetActor();
	LinkToMesh(m);
	SetVisible(v);
	IsVisible();
	
	NewCompObject(pos, rot, isStatic);
	NewCube(pos, rot, dim, isStatic, density, segs, mat);
	NewSphere(pos, rot, radius, isStatic, density, segs, mat);
	NewPlane(nor, dist, mat);
	NewTerrain(pos, rows, cols, sample, thickness, dimX, dimZ, minY, maxY, mat);
	NewCone(pos, rot, radius, height, isStatic, density, segs, mat, mng);
	NewConeFrustum(pos, rot, minRadius, maxRadius, height, isStatic, density, segs, mat, mng);
	NewPyramid(pos, rot, side, height, isStatic, density, segs, mat, mng);
	NewCylinder(pos, rot, radius, height, isStatic, density, segs, mat, mng);
	NewCvShape(pos, rot, mesh, isStatic, density, segs, mat, mng);
	NewTriShape(pos, rot, mesh, isStatic, density, segs, mat, mng);
	
	AddBoxShape(pos, rot, dim, density, mat, segs, addMesh);
	AddConeShape(pos, rot, radius, height, density, mat, mng, segs, addMesh);
	AddConeFrustumShape(pos, rot, minRadius, maxRadius, height, density, mat, mng, segs, addMesh);
	AddPyramidShape(pos, rot, side, height, density, mat, mng, segs, addMesh);
	AddCylinderShape(pos, rot, radius, height, density, mat, mng, segs, addMesh);
	AddConvexShape(mesh, pos, rot, density, mat, mng, addMesh);
	AddSphereShape(pos, radius, density, mat, segs, addMesh);
	AddTriangleShape(mesh, pos, rot, density, mat, mng, addMesh);
	GetNumShapes();
	RemoveShape(shape);
	SetContactOffset(offset, shape);
	SetRestOffset(offset, shape);
	
	MakeKinematic();
	MakeDynamic();
	Halt();
	SetGravity(g);
	
	GetPosition();
	SetPosition(pos);
	Translate(dp);
	
	GetInertiaTensor();
	SetInertiaTensor(inertia);
	SetLinearDamping(d);
	SetAngularDamping(d);
	
	GetMass();
	SetMass(m);
	SetBarycenterREL(b);
	
	GetVelocity();
	SetVelocity(v);
	
	GetAngularVelocity();
	SetAngularVelocity(v);
	SetMaxAngularVelocity(mav);
	
	SetIterationCount(iCount);
	
	GetRotation(angle, axis);
	GetRotationMatrix(rows);
	GetTransformationMatrix(rows);
	SetRotation(alpha, axis);
	SetRotationSingleAxis_X(alpha);
	SetRotationSingleAxis_Y(alpha);
	SetRotationSingleAxis_Z(alpha);
	SetRotationMatrix44(matrix, rows);
	SetRotationMatrix33(matrix, rows);
	SetTransformationMatrix(matrix, rows);
	Rotate(alpha, axis);
	RotateABS(alpha, axis);
	
	IsSleeping();
	SetSleepThreshold(th);
	SetWakeCounter(value);
	WakeUp();
	PutToSleep();
	
	AddForce(x, y, z);
	AddForceAtLocalPos(pos, x, y, z);
	AddForceAtPos(pos, x, y, z);
	AddLocalForceAtLocalPos(pos, x, y, z);
	AddLocalForceAtPos(pos, x, y, z);
	AddTorque(x, y, z);
	
	EnableRotationD6Joint();
	DisableRotationD6Joint();
	
	SetMaterial(mat, shape);
	
	AssignCollisionGroup(cg, shape);
	
	NewFromGivenMesh(m, pos, rot, isStatic,density, mat, mng);	
	
};

 
 /*!
  * Draws the object if it has a linked mesh, the parameters are the same of XVR standard object draw()
  * 
  * \param	flags	Contains a combination of one or more of the values contained in the Flag Table (see XVR documentation).
  * \param	x		Can assume different meanings depending on the specified flags or on the entity linked to the object
  * \param	y		Can assume different meanings depending on the specified flags or on the entity linked to the object
  */
function CVmPhObj::Draw(flags, x, y){ 	
 	if(mesh != void && visible){
		obj.Draw(flags, x, y);
	}
 }
 
/*!
 * Retrieve the graphical object
 * This function is useful when you want change a graphical attribute of the
 * object, like the color or the texture.
 * Don't use this function to scale, rotate or move the object, cause it wont
 * move the physical instance of the object and in the next simulation step every
 * transformation will be replaced.
 * \return	the graphical object.
 */ 
function CVmPhObj::GetObj(){
	return obj;
}

/*!
 * Get the mesh of the object
 * This function is useful when you want to link the procedural mesh created by
 * the object to another obj.
 * \return	the mesh associated with the CVmPhObj 
 */
function CVmPhObj::GetMesh(){
	return mesh;
}

/*!
 * Get the handler of the object
 * Returns the number used to reference the object inside the library. 
 * \return	the handler of the actor
 */
function CVmPhObj::GetActor(){
	return actor;
}

/*!
 * Links the mesh to the object
 * After the link, the mesh is moved in the same position of frame reference of 
 * the physical object.
 * To have good looking result the mesh should have similar dimension and shape
 * of the physical object. 
 * The old mesh is replaced.
 * \param	m	CVmMesh new object mesh
 */
function CVmPhObj::LinkToMesh(m){
	mesh = m;
	obj.LinkToMesh(mesh);
}

/*!
 * Set the object visible or not visible.
 * If an object is visible, it will be drawn on the graphics. 
 * \param	v	boolean		true to set the object visible
 */
function CVmPhObj::SetVisible(v){
	visible = v;
}

/*!
 * Retrurns true if the object is visible. 
 * \return	return if the object is visible or not
 */
function CVmPhObj::IsVisible(){
	return visible;
}


/* ----- PHYSIX FUNCTIONS ----- */

/*!
 * Constructor
 */
function CVmPhObj::CVmPhObj(){
	obj = CVmObj();		
	visible = true;
}

/*!
 * WRITE ME
 */
function CVmPhObj::NewCompObject(pos, rot, isStatic){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
}

/*!
 * Add a Cube Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	dim			vector[3]		dimension in x, y and z of the cube
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 */
function CVmPhObj::NewCube(pos, rot, dim, isStatic, density, segs, mat){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	mesh = CVmNewMesh(VRP_BOX, segs, [0,0,0], dim); 
	mesh.CenterBoundingBox();
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticBox(pos, quat, dim, mat.handler);
		CheckForErrorMessage(actor, "NewStaticBox");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddBoxShape(actor, dim, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Cube Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	radius		float			sphere radius
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 */
function CVmPhObj::NewSphere(pos, rot, radius, isStatic, density, segs, mat){
	var quat = vector(4);
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	mesh = CVmNewMesh(VRP_SPHERE, segs, radius, 1.0, 1.0);
	mesh.CenterBoundingBox();
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticSphere(pos, radius, mat.handler);
		CheckForErrorMessage(actor, "NewStaticSphere");
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddSphereShape(actor, radius, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddSphereShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Plane Actor to the scene.
 * It will be only physical objects, there will not be created a graphical mesh..
 * \param	nor			vector[3]		x,y,z-coordinate of  the plane normal
 * \param	dist		float			distance from the origin
 * \param	mat			CVmPhMaterial	material to set to the shape
 */
function CVmPhObj::NewPlane(nor, dist, mat){
	
	if(valtype(nor) == "")
		nor = [0,1,0];
		
	if(valtype(dist) == "")
		dist = 0;
		
	type = PHX_FIXED;
	
	actor = PhysXVR.NewPlane(nor, dist, mat.handler); 
	CheckForErrorMessage(actor, "NewPlane");
}

/*!
 * Add a Terrain Actor to the scene.
 * It will be only physical objects, there will not be created a graphical mesh..
 * \param	pos			vector[3]		position
 * \param	rows		int				???
 * \param	cols		int				???
 * \param	sample		????			???
 * \param	thickness	float			???
 * \param	dimX		float			???
 * \param	dimZ		float			???
 * \param	minY		float			???
 * \param	maxY		float			???
 * \param	mat			CVmPhMaterial	material to set to the shape
 */
function CVmPhObj::NewTerrain(pos, rows, cols, sample, thickness, dimX, dimZ, minY, maxY, mat){
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	type = PHX_FIXED;
	
	actor = PhysXVR.NewTerrain(pos, rows, cols, sample, thickness, dimX, dimZ, minY, maxY, mat.handler); 
	CheckForErrorMessage(actor, "NewTerrain");
}

/*!
 * Add a Cone Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	radius		float			radius of the cone
 * \param	height		float			height of the cone
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewCone(pos, rot, radius, height, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
	
	mesh = CVmNewMesh(VRP_CONE, segs, radius, height, 1);
	mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Cone Frustum Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	minRadius	float			specifies the inside (smaller) radius of the object
 * \param	maxRadius	float			specifies the outside (greater) radius of the object
 * \param	height		float			height of the cone
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewConeFrustum(pos, rot, minRadius, maxRadius, height, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	mesh = CVmNewMesh(VRP_CONEFRUSTUM, segs, minRadius, height, maxRadius, 1);
	mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
		
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Pyramid Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	side		float			length of the bottom side of the object (base)
 * \param	height		float			height of the object
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewPyramid(pos, rot, side, height, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	mesh = CVmNewMesh(VRP_PYRAMID, segs, side, height);
	mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Cylinder Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	radius		float			radius of the cylinder
 * \param	height		float			height of the cylinder
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewCylinder(pos, rot, radius, height, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	mesh = CVmNewMesh(VRP_CYLINDER, segs, radius, height, 1);
	mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}

/*!
 * Add a Not-Standard Convex Shape Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	mesh		CVmMesh			new mesh
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewCvShape(pos, rot, mesh, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	this.mesh = mesh;
	this.mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(this.mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}
	
	if(this.mesh != void){
		obj.LinkToMesh(this.mesh);
	}	
}

/*!
 * Add a Not-Standard Triangle Shape Actor in the scene.
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	mesh		CVmMesh			new mesh
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */
function CVmPhObj::NewTriShape(pos, rot, mesh, isStatic, density, segs, mat, mng){
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
		
	this.mesh = mesh;
	this.mesh.CenterBoundingBox();
	cookIndex = mng.CookMesh(this.mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticTriangleShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticTriangleShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddTriangleShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddTriangleShape");
	}
	
	if(this.mesh != void){
		obj.LinkToMesh(this.mesh);
	}	
}


/*!
 * Adds a physical box to the object.
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	dim			vector[3]		dimension
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param 	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddBoxShape(pos, rot, dim, density, mat, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	if(type != PHX_FIXED){
		if(addMesh){
			mesh = CVmNewMesh(VRP_BOX, segs, [0,0,0], dim);
			mesh.CenterBoundingBox();			
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddBoxShape(actor, dim, pos, quat, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddBoxShape\" function");	
	}		
}

/*!
 * Adds a physical cone shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
* \param	radius		float			radius of the cone
 * \param	height		float			height of the cone
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddConeShape(pos, rot, radius, height, density, mat, mng, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	mesh = CVmNewMesh(VRP_CONE, segs, radius, height, 1);
	mesh.CenterBoundingBox();
	var cookIndex = mng.CookConvexMesh(mesh);		
		
	if(cookIndex < 0)
		quit("Convex Mesh handler not valid");
			
	if(type != PHX_FIXED){
		if(addMesh){					
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, pos, quat, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddBoxShape\" function");	
	}		
}

/*!
 * Adds a physical cone frustum shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	minRadius	float			specifies the inside (smaller) radius of the object
 * \param	maxRadius	float			specifies the outside (greater) radius of the object
 * \param	height		float			height of the cone
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddConeFrustumShape(pos, rot, minRadius, maxRadius, height, density, mat, mng, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	mesh = CVmNewMesh(VRP_CONEFRUSTUM, segs, minRadius, height, maxRadius, 1);
	mesh.CenterBoundingBox();
	var cookIndex = mng.CookConvexMesh(mesh);		
		
	if(cookIndex < 0)
		quit("Convex Mesh handler not valid");
			
	if(type != PHX_FIXED){
		if(addMesh){					
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, pos, quat, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddBoxShape\" function");	
	}		
}

/*!
 * Adds a physical pyramid shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	side		float			length of the bottom side of the object (base)
 * \param	height		float			height of the object
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddPyramidShape(pos, rot, side, height, density, mat, mng, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	mesh = CVmNewMesh(VRP_PYRAMID, segs, side, height);
	mesh.CenterBoundingBox();
	var cookIndex = mng.CookConvexMesh(mesh);		
		
	if(cookIndex < 0)
		quit("Convex Mesh handler not valid");
			
	if(type != PHX_FIXED){
		if(addMesh){					
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, pos, quat, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddBoxShape\" function");	
	}		
}

/*!
 * Adds a physical cylinder shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	radius		float			radius of the cylinder
 * \param	height		float			height of the cylinder
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddCylinderShape(pos, rot, radius, height, density, mat, mng, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	mesh = CVmNewMesh(VRP_CYLINDER, segs, radius, height, 1);
	mesh.CenterBoundingBox();
	var cookIndex = mng.CookConvexMesh(mesh);		
		
	if(cookIndex < 0)
		quit("Convex Mesh handler not valid");
			
	if(type != PHX_FIXED){
		if(addMesh){					
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, pos, quat, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddBoxShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddBoxShape\" function");	
	}		
}

/*!
 * Adds a generical physical convex shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * Convex shape can be used to approximate complex object. You can add more than one convex shape to create a concav object.
 * \param	mesh		CVmMesh			new mesh
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddConvexShape(mesh, pos, rot, density, mat, mng, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
		
	this.mesh = mesh;
	this.mesh.CenterBoundingBox();
	var cookIndex = mng.CookConvexMesh(this.mesh);
		
	if(type != PHX_FIXED){
		if(addMesh){			
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}	
		
		if(cookIndex < 0)
			quit("Convex Mesh handler not valid");
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, pos, rot, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddConvexShape\" function");	
	}		
}

/*!
 * Adds a physical sphere to the object.
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * \param	pos			vector[3]		position relative to the center of the object 
 * \param	radius		float			sphere radius
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape 
 * \param 	segs		int				the number of polygonal divisions in the graphic mesh
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddSphereShape(pos, radius, density, mat, segs, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];		
	
	if(valtype(addMesh) == "")
		addMesh = true;
	
	if(type != PHX_FIXED){
		if(addMesh){
			mesh = CVmNewMesh(VRP_SPHERE, segs, radius, 1.0, 1.0);
			mesh.CenterBoundingBox();			
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}		
		
		var shapeIndex = PhysXVR.AddSphereShape(actor, radius, pos, [0,0,0,1], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddSphereShape");	
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddSphereShape\" function");	
	}		
}

/*!
 * Adds a generic physical shape to the object
 * If it is required to add another shape to an object which already contains a shape the boolean "addMesh" must be set on "true" and another graphical shape will be added on the object.
 * Be carefull collision between two generic shapes is not supported by the engine. Use some tool to split your mesh into convex meshes, the simulation will run faster.
 * \param	mesh		CVmMesh			new mesh
 * \param	pos			vector[3]		position relative to the center of the object
 * \param	rot			vector[3]		rotation relative to the object frame (in euler angles convention, degrees)
 * \param	density		float			shape density
 * \param	mat			CVmPhMaterial	material to set to the shape  
 * \param	mng			CVmPhManager	physical manager for cooking
 * \param	addMesh		bool			if true, the graphical mesh will be added on the graphic object
 */
function CVmPhObj::AddTriangleShape(mesh, pos, rot, density, mat, mng, addMesh){
	var quat = vector(4);	
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
	
	if(valtype(addMesh) == "")
		addMesh = true;
			
	this.mesh = mesh;
	this.mesh.CenterBoundingBox();
	var cookIndex = mng.CookMesh(this.mesh);
	
	if(type != PHX_FIXED){
		if(addMesh){			
			var newObj = CVmObj(mesh);
			obj.AddChild(newObj);
			newObj.SetPosition(pos);
		}	
		
		if(cookIndex < 0)
			quit("Triangle Mesh handler not valid");
		var shapeIndex = PhysXVR.AddTriangleShape(actor, cookIndex, pos, rot, density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddTriangleShape");
	}		
	else{
		outputln("Warning: FIXED object don't support \"AddTriangleShape\" function");	
	}		
}

/*!
 * Returns the number of shapes of the object
 * \return	the number of shapes
 */
function CVmPhObj::GetNumShapes(){
	var shapeNumber = PhysXVR.GetNumShapes(actor);
	if(shapeNumber < 0)
		CheckForErrorMessage(shapeNumber, "GetNumShapes");
	return shapeNumber; 
}

/*!
 * Remove a shape from the actor
 * Remove a shape from the actor. The shape index is based on the order that you add the shape.
 * After you remove a shape the last shape will take its index number
 * \param	shape	int		shape handler (could be void)
 */
function CVmPhObj::RemoveShape(shape){
	if(shape == void)	{
		var shapeNumber = GetNumShapes();
		if(shapeNumber < 0)
		CheckForErrorMessage(shapeNumber, "GetNumShapes");
		for(var i = 0; i < shapeNumber; ++i)
			CheckForErrorMessage(PhysXVR.RemoveShape(actor, i), "RemoveShape");		
	}
	else	
		CheckForErrorMessage(PhysXVR.RemoveShape(actor, shape),"RemoveShape");
}

/*!
 * Sets the contact offset (replaces the old "SetSkinWidth" function)
 * Shapes whose distance is less than the sum of their contactOffset values will generate contacts. 
 * The contact offset must be positive and greater than the rest offset. Having a contactOffset 
 * greater than than the restOffset allows the collision detection system to predictively enforce 
 * the contact constraint even when the objects are slightly separated. This prevents jitter that 
 * would occur if the constraint were enforced only when shapes were within the rest distance.
 * \param	offset	float	contact offset
 * \param	shape	int		shape handler (could be void)
 */
function CVmPhObj::SetContactOffset(offset, shape){
	if(shape == void)	{
		var shapeNumber = GetNumShapes();
		if(shapeNumber < 0)
		CheckForErrorMessage(shapeNumber, "GetNumShapes");
		for(var i = 0; i < shapeNumber; ++i)
			CheckForErrorMessage(PhysXVR.SetContactOffsetToShape(actor, i, offset), "SetContactOffsetToShape");		
	}
	else	
		CheckForErrorMessage(PhysXVR.ShapeSetContactOffset(actor, shape, offset),"SetContactOffsetToShape");
}

/*!
 * Sets the rest offset (replaces the old "SetSkinWidth" function)
 * Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the 
 * restOffset is 0, they should converge to touching exactly. Having a restOffset greater than zero 
 * is useful to have objects slide smoothly, so that they do not get hung up on irregularities of 
 * each others' surfaces.
 * \param	offset	float	rest offset
 * \param	shape	int		shape handler (could be void)
 */
function CVmPhObj::SetRestOffset(offset, shape){
	if(shape == void)	{
		var shapeNumber = GetNumShapes();
		if(shapeNumber < 0)
			CheckForErrorMessage(shapeNumber, "GetNumShapes");
		
		for(var i = 0; i < shapeNumber; ++i)
			CheckForErrorMessage(PhysXVR.SetRestOffsetToShape(actor, i, offset), "SetRestOffsetToShape");		
	}
	else	
		CheckForErrorMessage(PhysXVR.SetRestOffsetToShape(actor, shape, offset),"SetRestOffsetToShape");
}

/*!
 * Changes the type of object to Kynematic
 */
function CVmPhObj::MakeKinematic(){
	if(type != PHX_FIXED){
		CheckForErrorMessage(PhysXVR.EnableKinematic(actor), "EnableKinematic");
		type = PHX_KINEMATIC;
	} else {
		outputln("Warning: FIXED object don't support \"MakeKinematic\" function");
	}
}

/*!
 * Change the type of object to Dynamic
 */
function CVmPhObj::MakeDynamic(){
	if(type != PHX_FIXED){
		CheckForErrorMessage(PhysXVR.DisableKinematic(actor), "DisableKinematic");
		type = PHX_DYNAMIC;
	} else {
		outputln("Warning: FIXED object don't support \"DisableKinematic\" function");
	}
}

/*!
 * Stops the object rotation and translation
 * this function don't stop the object linked with this one and can cause
 * instability if an high speed object is joined.
 */
function CVmPhObj::Halt(){
	if(type != PHX_FIXED){
		CheckForErrorMessage(PhysXVR.Halt(actor), "Halt");
		type = PHX_DYNAMIC;
	} else {
		outputln("Warning: FIXED object don't support \"Halt\" function");
	}	
}

/*!
 * Enables or disables the gravity of an object
 * \param	g	bool	true enable, false disable gravity
 */
function CVmPhObj::SetGravity(g){
	if(g == true)
		g = 1;
	else
		g = 0;
	CheckForErrorMessage(PhysXVR.SetGravity(actor, g), "SetGravity");
}

/*!
 * Returns the position of the object
 * Returns the current position of the frame reference object, the position is
 * valid after at least one simulation step. 
 * \return 	the position of the object
 */
function CVmPhObj::GetPosition(){
	static var temp = vector(3);	
	CheckForErrorMessage(PhysXVR.GetPosition(actor, &temp), "GetPosition");
	return temp;
}

/*!
 * Moves the object in the specified world coordinates
 * This operation is forbidden for FIXED object.
 * This function don't move the objects joined with this one. Moving objects
 * without moving the other joined can cause a big joint error and serious
 * instability.
 * \param	pos  vector[3]	new position of the object
 */
function CVmPhObj::SetPosition(pos){
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetPosition(actor, pos), "SetPosition");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKPosition(actor, pos), "SetKPosition");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetPosition\" function");
			break;	
	}
}

/*!
 * Moves the object of the specified amount along the main axes, this operation is forbidden in FIXED object
 * \param	dp	vector[3]	translation vector
 */
function CVmPhObj::Translate(dp){
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.Translate(actor, dp), "Translate");	
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.KTranslate(actor, dp), "KTranslate");		
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"Translate\" function");
			break;				
	}
}

/*!
 * Retrives the object inertia tensor
 * \return		object inertia tensor
 */
function CVmPhObj::GetInertiaTensor(){
	var temp = vector(3);
	CheckForErrorMessage(PhysXVR.GetInertiaTensor(actor, &temp), "GetInertiaTensor");	
	return temp;	
}

/*!
 * Manually sets the object inertia tensor
 * Object with a wrong inertia tensor will behave in strange way, the vector
 * define the inertia around the main axis (or the diagolan of the tensor).
 * \param	inertia vector[3]	inertia tensor
 */
function CVmPhObj::SetInertiaTensor(inertia){
	CheckForErrorMessage(PhysXVR.SetInertiaTensor(actor, inertia), "SetInertiaTensor");	
}

/*!
 * Sets the linear damping of an object, it's usefull to simulate air friction
 * linear damping reduce the velocity of the object proportionally to velocity.
 * It's useful to simulate air friction and reduce instability caused by fast
 * object 
 * \param	linDamp	damping
 */
function CVmPhObj::SetLinearDamping(d){
	CheckForErrorMessage(PhysXVR.SetLinearDamping(actor, d), "SetLinearDamping");	
}

/*!
 * Sets the angular damping of an object, slow down the object while it's rotating
 * \param	angDamp	damping
 */
function CVmPhObj::SetAngularDamping(d){
	CheckForErrorMessage(PhysXVR.SetAngularDamping(actor, d), "SetAngularDamping");	
}

/*!
 * Get the object mass
 * \return		object mass
 */
function CVmPhObj::GetMass(){
	var mass = 0.0;
	CheckForErrorMessage(PhysXVR.GetMass(actor, &mass), "GetMass");
	return mass;
}

/*!
 * Set the object mass
 * \param	m	float	object mass
 */
function CVmPhObj::SetMass(m){
	CheckForErrorMessage(PhysXVR.SetMass(actor, m), "SetMass");
}

 /*!
 * Sets the baricenter in object coordinate
 * The barycenter in not linked with position.
 * To achieve good result the barycenter (in convec shape) should be inside the
 * shape.
 * \param	b	vector[3]	barycenter
 */
function CVmPhObj::SetBarycenterREL(b){
	if(type != PHX_FIXED){
		CheckForErrorMessage(PhysXVR.SetBarycenterREL(actor, b), "SetBarycenterREL");
	} else {
		outputln("Warning: FIXED object don't support \"SetBarycenterREL\" function");
	}		
}

/*!
 * Gets the object velocity
 * \return		object velocity
 */
function CVmPhObj::GetVelocity(){
	var vel = vector(3);
	CheckForErrorMessage(PhysXVR.GetVelocity(actor, &vel), "GetVelocity");
	return vel;
}

/*!
 * Sets the obeject velocity
 * Setting an high speed to an object joined with other can cause instability
 * \param	v	vector[3]	new object velocity
 */
function CVmPhObj::SetVelocity(v){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.SetVelocity(actor, v), "SetVelocity");
	} else {
		outputln("Warning: FIXED object don't support \"SetVelocity\" function");
	}
}

/*!
 * Gets the object angular velocity
 * \return	object angular velocity
 */
function CVmPhObj::GetAngularVelocity(){
	var temp = vector(3);	
	CheckForErrorMessage(PhysXVR.GetAngularVelocity(actor, &temp), "GetAngularVelocity");
	return temp;
}

/*!
 * Sets the object angular velocity
 * \param	v	vector[3]	new object angular velocity
 */
function CVmPhObj::SetAngularVelocity(v){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.SetAngularVelocity(actor, v), "SetAngularVelocity");
	} else {
		outputln("Warning: FIXED object don't support \"SetVelocity\" function");
	}
}

/*!
 * Sets the max angular velocity for an object, it's usefull to make the simulation more stable
 * Object with a dimension very bigger then the other (like a pencil) can store a
 * lot of energy while rotating around a short axis.
 * This energy is converted to a very high rotational velocity when the shape
 * rotates around a longer axis.
 * High rotational velocities can lead to problems because certain linear
 * approximations of the rotational motion fail to hold.
 * For this reason, the engine automatically limits the rotational velocity of a
 * body to a user definable maximum value.
 * Because this may prevent intentional fast rotation in objects such as wheels,
 * the user can override it on a per body basis with this function.
 * \param	maxAngVel	float	maximum velocity
 */
function CVmPhObj::SetMaxAngularVelocity(mav){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.SetMaxAngularVelocity(actor, mav), "SetMaxAngularVelocity");
	} else {
		outputln("Warning: FIXED object don't support \"SetMaxAngularVelocity\" function");
	}
}

/*!
 * Set the iteration counter
 * This parameter specify the number of solver iterations performed when
 * processing joint or a contacts connected to this body.
 * Higher number stabilize the object, is very useful when you create a long 
 * chain of joint. 
 * \param iCount iteration counter Range: [1,255] Default: 4
 */
function CVmPhObj::SetIterationCount(iCount){
	CheckForErrorMessage(PhysXVR.SetIterationCount(actor, iCount), "SetIterationCount");
}

/*!
 * Get the rotation of the object in angle-axis representation
 * \param	angle	&float		rotation angle in degrees
 * \param	axis	vector[3]	rotation axis
 */
function CVmPhObj::GetRotation(angle, axis){	
	//PhysXVR.GetRotation(actor, &angle, &axis);
	CheckForErrorMessage(PhysXVR.GetRotation(actor, &angle, &axis), "GetRotation");
	angle = angle * 180.0/PI;
}

/*!
 * Get the 3x3 rotation matrix of the object
 * Get the rotation matrix of the frame reference of the object, this is valid
 * after at least one simulation step.
 * \param	rows	bool	true if you want the rotation matrix sorted by rows, false if you want the rotation matrix sorted by columns (true by default)
 * \return	a vector of 9 with the rotation matrix
 */
function CVmPhObj::GetRotationMatrix(rows){
	if(valtype(rows) == "")
		rows = true;
		
	var rowsInt = 0;
	if(rows){
		rowsInt = 1;
	}
	
	static var temp = vector(9);
	CheckForErrorMessage(PhysXVR.GetRotationMatrix(actor, &temp, rowsInt), "GetRotationMatrix");
	return temp;
}

/*!
 * Get the 4x4 transformation matrix of the object
 * Get the rotation matrix of the frame reference of the object, this is valid
 * after at least one simulation step.
* \param	rows	bool	true if you want the rotation matrix sorted by rows, false if you want the rotation matrix sorted by columns (true by default)
 * \return	a vector of 16 with the rotation matrix sorted by columns
 */
function CVmPhObj::GetTransformationMatrix(rows){
	if(valtype(rows) == "")
		rows = true;
		
	var rowsInt = 0;
	if(rows){
		rowsInt = 1;
	}
	static var temp = vector(16);
	CheckForErrorMessage(PhysXVR.GetTransformationMatrix(actor, &temp, rowsInt), "GetTransformationMatrix");
	return temp;
}
 
/*!
 * Sets the object orientation in the scene with angle-axis representation
 * \param	alpha	float	rotation angle in degrees
 * \param	axis	vector[3]	orientation axis
 */
function CVmPhObj::SetRotation(alpha, axis){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotation(actor, alpha_rad, axis), "SetRotation");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotation(actor, alpha_rad, axis), "SetKRotation");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotation\" function");
			break;
	}
}

/*
Sets the actor's rotation on the X-Axis with reference of the Global System Frame (without modifying YZ-Axes)
\param	alpha	float	rotation angle in degrees
*/
function CVmPhObj::SetRotationSingleAxis_X(alpha){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotationSingleAxis_X(actor, alpha_rad), "SetRotationSingleAxis_X");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotationSingleAxis_X(actor, alpha_rad), "SetKRotationSingleAxis_X");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotationSingleAxis_X\" function");
			break;
	}
}

/*
Sets the actor's rotation on the Y-Axis with reference of the Global System Frame (without modifying XZ-Axes)
\param	alpha	float	rotation angle in degrees
*/
function CVmPhObj::SetRotationSingleAxis_Y(alpha){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotationSingleAxis_Y(actor, alpha_rad), "SetRotationSingleAxis_Y");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotationSingleAxis_Y(actor, alpha_rad), "SetKRotationSingleAxis_Y");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotationSingleAxis_Y\" function");
			break;
	}
}

/*
Sets the actor's rotation on the Z-Axis with reference of the Global System Frame (without modifying XY-Axes)
\param	alpha	float	rotation angle in degrees
*/
function CVmPhObj::SetRotationSingleAxis_Z(alpha){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotationSingleAxis_Z(actor, alpha_rad), "SetRotationSingleAxis_Z");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotationSingleAxis_Z(actor, alpha_rad), "SetKRotationSingleAxis_Z");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotationSingleAxis_Z\" function");
			break;
	}
}

/*!
 * Sets the object orientation in the scene with 4x4 tranformation matrix
 * \param	matrix	vector[16]	transformation matrix
 * \param	rows	bool		true if you want the rotation matrix sorted by rows, false if you want the rotation matrix sorted by columns (true by default)
 */
function CVmPhObj::SetRotationMatrix44(matrix, rows){
	if(valtype(rows) == "")
		rows = true;
		
	var rowsInt = 0;
	if(rows){
		rowsInt = 1;
	}
	
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotationMatrix44(actor, matrix, rowsInt), "SetRotationMatrix44");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotationMatrix44(actor, matrix, rowsInt), "SetKRotationMatrix44");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotationMatrix44\" function");
			break;
	}
}

/*!
 * Sets the object orientation in the scene with 3x3 rotation matrix
 * \param	matrix	vector[9]	rotation matrix
 * \param	rows	bool		true if you want the rotation matrix sorted by rows, false if you want the rotation matrix sorted by columns (true by default)
 */
function CVmPhObj::SetRotationMatrix33(matrix, rows){
	if(valtype(rows) == "")
		rows = true;
		
	var rowsInt = 0;
	if(rows){
		rowsInt = 1;
	}
	
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetRotationMatrix33(actor, matrix, rowsInt), "SetRotationMatrix33");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKRotationMatrix33(actor, matrix, rowsInt), "SetKRotationMatrix33");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetRotationMatrix33\" function");
			break;
	}
}

/*!
 * Sets the object global pose in the scene with 4x4 transformation matrix
 * \param	matrix	vector[16]	transformation matrix
 * \param	rows	bool		true if you want the rotation matrix sorted by rows, false if you want the rotation matrix sorted by columns (true by default)
 */
function CVmPhObj::SetTransformationMatrix(matrix, rows){
	if(valtype(rows) == "")
		rows = true;
		
	var rowsInt = 0;
	if(rows){
		rowsInt = 1;
	}
	
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.SetTransformationMatrix(actor, matrix, rowsInt), "SetTransformationMatrix");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.SetKTransformationMatrix(actor, matrix, rowsInt), "SetKTransformationMatrix");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"SetTransformationMatrix\" function");
			break;
	}
}

/*!
 * Rotates the object of the specified amount along the main axes, this operation is forbidden in FIXED object
 * \param	alpha	float		specifies rotation angle in degrees
 * \param	axis	vector[3]	specifies rotation axis
 */
function CVmPhObj::Rotate(alpha, axis){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.Rotate(actor, alpha_rad, axis), "Rotate");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.KRotate(actor, alpha_rad, axis), "KRotate");			
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"Rotate\" function");
			break;
	}		
}

/*!
 * Rotates the object of the specified amount along the global axes, this operation is forbidden in FIXED object
 * \param	alpha	float	specifies rotation angle in degrees
 * \param	axis	vector[3]	specifies rotation axis
 */
function CVmPhObj::RotateABS(alpha, axis){
	var alpha_rad = alpha * PI/180.0;
	switch(type){
		case PHX_DYNAMIC:
			CheckForErrorMessage(PhysXVR.RotateABS(actor, alpha_rad, axis), "RotateABS");
			break;
		case PHX_KINEMATIC:
			CheckForErrorMessage(PhysXVR.KRotateABS(actor, alpha_rad, axis), "KRotateABS");
			break;
		case PHX_FIXED:
			outputln("Warning: FIXED object don't support \"RotateABS\" function");
			break;
	}
}

/*!
 * Tells if the object is sleeping
 * \return true if the object is sleeping
 */
function CVmPhObj::IsSleeping(){
	var result = false;	
	if(type != PHX_FIXED){	
		var isSleep = PhysXVR.IsSleeping(actor);
		if(isSleep == 1)
			result = true;
		else if(isSleep == 0)
			result = false;
		else
			CheckForErrorMessage(isSleep, "IsSleeping");			
	} else {
		outputln("Warning: FIXED object don't support \"IsSleeping\" function");
	}	
	return result;
}

/*!
 * Set the minimum energy that the object should have before go to sleep automatically
 * If threshold is set to a negative value the default value (0.005) will be taken.
 * \param th	float	 minium energy
 */
function CVmPhObj::SetSleepThreshold(th){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.SetSleepThreshold(actor, th), "SetSleepThreshold");
	} else {
		outputln("Warning: FIXED object don't support \"SetSleepThreshold\" function");
	}
}

/*!
 * Sets the wake counter for the actor
 * \param	value	float	wake counter value
 */
function CVmPhObj::SetWakeCounter(value){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.SetWakeCounter(actor, value), "SetWakeCounter");
	} else {
		outputln("Warning: FIXED object don't support \"SetWakeCounter\" function");
	}
}

/*!
 * Wakes up the actor if it is sleeping
 */
function CVmPhObj::WakeUp(){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.WakeUp(actor), "WakeUp");
	} else {
		outputln("Warning: FIXED object don't support \"WakeUp\" function");
	}
}

/*!
 * Forces the actor to sleep
 */
function CVmPhObj::PutToSleep(){
	if(type != PHX_FIXED){	
		CheckForErrorMessage(PhysXVR.PutToSleep(actor), "PutToSleep");
	} else {
		outputln("Warning: FIXED object don't support \"PutToSleep\" function");
	}
}

/*!
 * Applies a force defined in the global coordinate frame to the actor
 * This function works only on dynamic object
 * \param	x	x-force component in the global frame
 * \param	y	y-force component in the global frame
 * \param	z	z-force component in the global frame
 */
function CVmPhObj::AddForce(x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddForce(actor, x, y, z), "AddForce");	
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddForce\" function");
	}		
}

/*!
 * Applies a force defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor
 * This function works only on dynamic object
 * \param	pos	vector[3]	position in the local frame to add the force at
 * \param	x	float		x-force component in the global frame
 * \param	y	float		y-force component in the global frame
 * \param	z	float		z-force component in the global frame
 */
function CVmPhObj::AddForceAtLocalPos(pos, x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddForceAtLocalPos(actor, pos, x, y, z), "AddForceAtLocalPos");
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddForceAtLocalPos\" function");
	}		
}

/*!
 * Applies a force defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor
 * This function works only on dynamic object
 * \param	pos	vector[3]	position in the global frame to add the force at
 * \param	x	float		x-force component in the global frame
 * \param	y	float		y-force component in the global frame
 * \param	z	float		z-force component in the global frame
 */
function CVmPhObj::AddForceAtPos(pos, x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddForceAtPos(actor, pos, x, y, z), "AddForceAtPos");	
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddForceAtPos\" function");
	}		
}

/*!
 * Applies a force defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor
 * This function works only on dynamic object
 * \param	pos	vector[3]	position in the local frame to add the force at
 * \param	x	float		x-force component in the local frame
 * \param	y	float		y-force component in the local frame
 * \param	z	float		z-force component in the local frame
 */
function CVmPhObj::AddLocalForceAtLocalPos(pos, x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddLocalForceAtLocalPos(actor, pos, x, y, z), "AddLocalForceAtLocalPos");	
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddLocalForceAtLocalPos\" function");
	}		
}

/*!
 * Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor
 * This function works only on dynamic object
 * \param	pos	vector[3]	position in the global frame to add the force at
 * \param	x	float		x-force component in the local frame
 * \param	y	float		y-force component in the local frame
 * \param	z	float		z-force component in the local frame
 */
function CVmPhObj::AddLocalForceAtPos(pos, x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddLocalForceAtPos(actor, pos, x, y, z), "AddLocalForceAtPos");	
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddLocalForceAtPos\" function");
	}		
}

/*!
 * Applies a torque to the object defined in the global coordinate frame, this function works only on dynamic object
 * \param	x	float		x-force component in the global frame
 * \param	y	float		y-force component in the global frame
 * \param	z	float		z-force component in the global frame
 */
function CVmPhObj::AddTorque(x, y, z){
	if(type == PHX_DYNAMIC){
		CheckForErrorMessage(PhysXVR.AddTorque(actor, x, y, z), "AddTorque");	
	} else {
		outputln("Warning: FIXED and KINEMATIC objects don't support \"AddTorque\" function");
	}		
}

/*!
 * Enables rotation for the joint with the father actor.
 * \return	the father handler (which is actor0 of the PxD6Joint)
 */
function CVmPhObj::EnableRotationD6Joint(){
	var father_handler = PhysXVR.EnableRotationD6JointForObj(actor);
	CheckForErrorMessage(father_handler, "EnableRotationD6JointForObj");	
	return father_handler;
}

/*!
 * Disables rotation for the joint with the father actor.
 * \return	the father handler (which is actor0 of the PxD6Joint)
 */
function CVmPhObj::DisableRotationD6Joint(){
	var father_handler = PhysXVR.DisableRotationD6JointForObj(actor);
	CheckForErrorMessage(father_handler, "DisableRotationD6JointForObj");	
	return father_handler;
}

/*!
 * Change the material to the selected shape
 * if no shape is specified the material is applied to every shape in the object.
 * The first shape you insert into the object have index 0, the second index 1 
 * and so on.
 * \param	mat		CVmPhMaterial	material to set
 * \param	shape	int				handler of the shape (could be void)
 */
function CVmPhObj::SetMaterial(mat, shape){
	if(shape == void)	{
		var shapeNumber = GetNumShapes();
		if(shapeNumber < 0)
			CheckForErrorMessage(shapeNumber, "GetNumShapes");
		for(var i = 0; i < shapeNumber; ++i)
			CheckForErrorMessage(PhysXVR.SetMaterial(actor, i, mat.handler), "SetMaterial");		
	}
	else	
		CheckForErrorMessage(PhysXVR.SetMaterial(actor, shape, mat.handler),"SetMaterial");
}

/*!
 * Assigns a collision group to a shape of an object.
 * If you don't assign a collision group to an object after you have created it, it will take the default collision group 0.
 * If you specified a collision group for an object using this AssignCollisionGroup to an object (and its shapes) it will collide with the other objects belonging to the other collisions groups.
 * If you want to disable the collision between different collision groups, you can use DisableCollision method of the PhManager.
 * Objects which belong to the same Collisiong Group will collide each other.
 * If no shape is specified the collision group is modified to every shape in the
 * object.
 * The first shape you insert into the object have index 0, the second index 1 
 * and so on. 
 * \param	cg		int	collision group
 * \param	shape 	int	index of the shape (could be void)
 */
function CVmPhObj::AssignCollisionGroup(cg, shape){
	if(shape == void)	{
		var shapeNumber = GetNumShapes();
		if(shapeNumber < 0)
			CheckForErrorMessage(shapeNumber, "GetNumShapes");
		for(var sh = 0; sh < shapeNumber; ++sh)
			CheckForErrorMessage(PhysXVR.AssignCollisionGroup(actor, sh, cg), "AssignCollisionGroup");		
	}
	else	
		CheckForErrorMessage(PhysXVR.AssignCollisionGroup(actor, shape, cg),"AssignCollisionGroup");
}

/*!
 * Add a m - Actor in the scene.
 * \param	m			mesh			used mesh
 * \param	pos			vector[3]		initial position
 * \param	rot			vector[3]		initial rotation (in euler angles convention, degrees)
 * \param	isStatic	int				specifies the type of the object
 * 										- PHX_DYNAMIC (default): the object is affected by gravity and collision
 * 										- PHX_KINEMATIC: the object is not affected by forces but can be moved with the SetPosition
 * 										- PHX_FIXED: the object is static and can't be moved. Other objects collide with it.
 * \param	density		float			object density, this parameter is ignored if the object is FIXED
 * \param	mat			CVmPhMaterial	material to set to the shape
 * \param	mng			CVmPhManager	physical manager for cooking
 */

function CVmPhObj::NewFromGivenMesh(m, pos, rot, isStatic, density, mat, mng) {
	var quat = vector(4);	
	var cookIndex;
	
	if(valtype(pos) == "")
		pos = [0,0,0];
		
	if(valtype(rot) == "")
		rot = [0,0,0];
		
	quat = EulerToQuaternion(rot);
		
	if(valtype(isStatic) == "")
		type = PHX_DYNAMIC;
	else
		type = isStatic;
		
	if(type != PHX_FIXED){	
		actor = PhysXVR.NewCompObject(pos, quat, type, 0);	
		CheckForErrorMessage(actor, "NewCompObject");
	}
	mesh = m;
	//mesh.CenterBoundingBox();
	cookIndex = mng.CookConvexMesh(mesh);
	if(type == PHX_FIXED){
		actor = PhysXVR.NewStaticConvexShape(cookIndex, pos, quat, mat.handler);
		CheckForErrorMessage(actor, "NewStaticConvexShape");		
		var matrix3 = vector(9);
		matrix3 = QuaternionToMatrix3(quat); 
		var matrix4 = vector(16);
		matrix4[0] = matrix3[0];	matrix4[1] = matrix3[1];	matrix4[2] = matrix3[2];	matrix4[3] = 0.0;
		matrix4[4] = matrix3[3];	matrix4[5] = matrix3[4];	matrix4[6] = matrix3[5];	matrix4[7] = 0.0;
		matrix4[8] = matrix3[6];	matrix4[9] = matrix3[7];	matrix4[10] = matrix3[8];	matrix4[11] = 0.0;
		matrix4[12] = 0.0;			matrix4[13] = 0.0;			matrix4[14] = 0.0;			matrix4[15] = 1.0;
		obj.SetPosition(pos);
		obj.SetRotationMatrix(matrix4);
	} else {
		var shapeIndex = PhysXVR.AddConvexShape(actor, cookIndex, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], density, mat.handler);
		CheckForErrorMessage(shapeIndex, "AddConvexShape");
	}
	
	if(mesh != void){
		obj.LinkToMesh(mesh);
	}	
}	

#endif
